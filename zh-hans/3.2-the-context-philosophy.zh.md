# **专题解析之：`Context` 的设计哲学 — Actor 的世界观**

在我们的框架中，每一个被调用的 `Actor` 方法都会收到一个名为 `context` 的特殊参数。它并非一个简单的工具包，而是 Actor 与其宿主环境 (`ActrSystem`) 之间唯一的、受控的、安全的交互界面。

理解 `Context` 的设计哲学，是掌握本框架精髓、编写出专业级 Actor 的关键。

`Context` 的设计哲学，建立在三大支柱之上：它是**桥梁**，是**上下文**，也是**媒介**。

### 支柱一：作为“请求的桥梁” — 副作用的优雅分离

Actor 模型的核心思想是逻辑的纯粹性。为了保护这种纯粹性，所有与外部世界的交互（即“副作用”）都必须被严格管理。`Context` 在此扮演了“桥梁”的角色，它遵循 **“请求，而非命令” (Ask, Don't Command)** 的原则。

*   **Actor 不命令**: 业务逻辑不应直接执行文件写入、网络请求、定时休眠等操作。
*   **Actor 只请求**: 业务逻辑应通过 `Context`，向 `ActrSystem` 的后台服务发出“请求”，例如：
    *   `context.logger.info(...)`: 请求记录一条日志。
    *   `context.schedule_tell(...)`: 请求在未来某个时间点发送一个消息。
    *   `context.publish_event(...)`: 请求向外部世界发布一个事件。

这种模式将耗时、易变的 I/O 操作与核心业务逻辑解耦，有助于提升系统的可测试性和韧性。在单元测试中，我们可以用一个 `MockContext` 来捕获这些出站的“请求”，从而在不执行任何真实 I/O 的情况下，验证 Actor 行为的正确性。

### 支柱二：作为“请求的上下文” — 环境信息的传递者

`Context` 的名字本身就蕴含了它的第二个核心职责：作为当前**请求环境信息**的载体。

`Context` 对象随着每一个外部请求的到达而被创建，它像一个只读的快照，封装了关于“这一次调用”的所有背景信息。开发者可以通过它安全地获知：

*   **调用者**: `ctx.caller_id()` 返回本次请求的来源对等端 (Peer) 的唯一标识。
*   **追踪ID**: `ctx.trace_id()` 返回贯穿整个调用链的唯一追踪ID，是实现分布式链路追踪的基础。
*   **安全凭证 (未来)**: `ctx.credentials()` 可以用于获取与本次请求相关的认证信息，如用户令牌或权限等级。
*   **截止时间 (未来)**: `ctx.deadline()` 可以告知 Actor 本次请求的剩余处理时间，使其能主动放弃超时任务，避免资源浪费。

将这些信息统一封装在 `Context` 中，极大地净化了业务方法的签名，并为实现健壮的、可观测的系统提供了统一的入口。

### 支柱三：作为“对话的媒介” — 分层的通信模式

当一个 Actor 需要与另一个 Actor 通信时，`Context` 充当了它们之间唯一的“通信媒介”。为了兼顾精确控制和高度解耦，框架提供了两层截然不同的通信 API：

#### **层级一：直接寻址通信（底层手工发送 API）**

这是底层的、精确指向的通信方式。当你的 Actor **明确知道** 目标（本地 Workload、远程 Actor、或 Shell 侧）时，使用这组 API。

**设计定位**：这是底层 API，面向需要完全控制消息参数的场景。不追求简洁性，而是确保所有参数和能力完整可用。

**三种目标类型（Dest）**：

```rust
/// 目标标识（actr-framework）
pub enum Dest {
    /// Workload → App 侧 (inproc 反向通道)
    Shell,

    /// 本地 Workload (从 App: inproc, 从 Workload: outproc 短接)
    Local,

    /// 远程 Actor (完整 outproc 通信)
    Actor(ActrId),
}
```

##### **Context 结构字段**

```rust
pub struct Context {
    /// 当前 Actor 的标识
    pub self_id: ActrId,

    /// 调用方 Actor 的标识（如果有）
    /// - Some(caller): 当前处理的是来自 caller 的请求
    /// - None: 当前处理的是内部事件或生命周期钩子
    pub caller_id: Option<ActrId>,

    /// 分布式追踪 ID
    /// 贯穿整个调用链的唯一标识，用于关联分布式系统中的多个调用
    pub trace_id: String,

    /// 请求唯一 ID
    /// 标识单次 RPC 调用，用于关联请求和响应
    pub request_id: String,


##### **RpcEnvelope 结构（完整参数说明）**

所有底层消息发送都需要手工构造 `RpcEnvelope`：

```rust
/// RPC 消息封装（Protobuf 定义）
pub struct RpcEnvelope {
    /// 路由键（必填）
    /// 格式："{package}.{Service}.{Method}"
    /// 示例：
    /// - "acme.user.v1.UserService.GetUser"
    /// - "acme.echo.v1.EchoService.Echo"
    ///
    /// 用途：
    /// - 接收方根据此字段路由消息到对应的处理方法
    /// - 框架使用静态 match 表达式进行零成本分发（5-10ns）
    pub route_key: String,

    /// 消息负载（必填）
    /// 格式：Protobuf 编码的字节流
    ///
    /// 构造方式：
    /// ```rust
    /// use prost::Message;
    /// let req = GetUserRequest { user_id: 123 };
    /// let payload = req.encode_to_vec().into();
    /// ```
    ///
    /// 注意：
    /// - 必须使用 Protobuf 编码（框架不支持其他序列化格式）
    /// - 接收方会根据 route_key 推断类型并反序列化
    pub payload: Bytes,

    /// 分布式追踪 ID（必填）
    ///
    /// 用途：
    /// - 关联分布式系统中的多个调用
    /// - 实现分布式链路追踪（OpenTelemetry/Jaeger）
    ///
    /// 最佳实践：
    /// - 从上游请求的 Context 传播：`ctx.trace_id.clone()`
    /// - 新发起的调用链：`Uuid::new_v4().to_string()`
    pub trace_id: String,

    /// 请求唯一 ID（必填）
    ///
    /// 用途：
    /// - 标识单次 RPC 调用
    /// - 用于关联请求和响应（send_request 模式）
    /// - 用于幂等性检测和去重
    ///
    /// 生成方式：
    /// - `Uuid::new_v4().to_string()`
    /// - 或单调递增的序列号
    pub request_id: String,

    /// 元数据（可选）
    ///
    /// 用途：
    /// - 传递应用层的扩展信息（不影响路由和序列化）
    /// - 典型场景：
    ///   - 用户认证 token：`{"auth_token": "..."}`
    ///   - 租户隔离标识：`{"tenant_id": "..."}`
    ///   - 自定义追踪信息：`{"parent_span_id": "..."}`
    ///
    /// 格式：
    /// ```rust
    /// pub struct MetadataEntry {
    ///     pub key: String,
    ///     pub value: String,
    /// }
    /// ```
    ///
    /// 示例：
    /// ```rust
    /// metadata: vec![
    ///     MetadataEntry {
    ///         key: "auth_token".to_string(),
    ///         value: "Bearer xxx".to_string(),
    ///     },
    /// ],
    /// ```
    pub metadata: Vec<MetadataEntry>,

    /// 超时时间（毫秒，必填）
    ///
    /// 用途：
    /// - send_request: 等待响应的最大时间
    /// - send_message: 传输层提交的最大时间
    ///
    /// 建议值：
    /// - 快速查询：100-500ms
    /// - 普通 RPC：1000-3000ms
    /// - 批量操作：5000-10000ms
    /// - 长时任务：30000ms+（考虑使用异步回调模式）
    ///
    /// 超时行为：
    /// - send_request: 超时后返回 Err(ActorError::Timeout)
    /// - send_message: 超时后返回 Err(ActorError::TransportTimeout)
    pub timeout_ms: i64,
}
```

##### **完整手工发送示例**

```rust
use actr_framework::{Context, Dest};
use actr_protocol::{ActrId, RpcEnvelope, MetadataEntry};
use prost::Message;
use uuid::Uuid;

/// 示例：手工发送请求并等待响应（远程 Actor）
async fn manual_call_example(ctx: &Context, target_id: ActrId) -> ActorResult<GetUserResponse> {
    // 1. 构造请求消息
    let request = GetUserRequest { user_id: 123 };

    // 2. 序列化为 Protobuf bytes
    let payload = request.encode_to_vec().into();

    // 3. 构造完整的 RpcEnvelope
    let envelope = RpcEnvelope {
        route_key: "acme.user.v1.UserService.GetUser".to_string(),
        payload,
        trace_id: ctx.trace_id.clone(),  // 传播追踪 ID
        request_id: Uuid::new_v4().to_string(),
        metadata: vec![
            MetadataEntry {
                key: "auth_token".to_string(),
                value: "Bearer xxx".to_string(),
            },
        ],
        timeout_ms: 3000,  // 3 秒超时
    };

    // 4. 通过 gate 发送并等待响应（使用 Dest::Actor）
    let response_bytes = ctx.gate.send_request(&Dest::Actor(target_id), envelope).await?;

    // 5. 手工反序列化响应
    let response = GetUserResponse::decode(&*response_bytes)?;

    Ok(response)
}

/// 示例：手工发送单向消息（本地 Workload）
async fn manual_tell_example(ctx: &Context) -> ActorResult<()> {
    let notification = UserNotification {
        user_id: 123,
        message: "Hello".to_string(),
    };

    let envelope = RpcEnvelope {
        route_key: "acme.user.v1.UserService.Notify".to_string(),
        payload: notification.encode_to_vec().into(),
        trace_id: ctx.trace_id.clone(),
        request_id: Uuid::new_v4().to_string(),
        metadata: vec![],  // 单向消息可以不带 metadata
        timeout_ms: 1000,  // 传输层提交超时
    };

    // send_message 立即返回，不等待对方处理结果（使用 Dest::Local）
    ctx.gate.send_message(&Dest::Local, envelope).await?;

    Ok(())
}
```

##### **使用场景**

这组底层 API 适用于以下场景：

1. **需要完全控制消息参数**：
   - 自定义超时策略
   - 传递复杂的元数据
   - 精确控制追踪 ID 的传播

2. **动态目标选择**：
   - 根据运行时条件选择目标 Actor
   - 实现自定义的负载均衡或路由策略

3. **基于实例的通信架构**：
   - Actor 之间直接点对点通信
   - 有状态 Actor 的实例级交互

4. **框架内部实现**：
   - 代码生成器生成的高级 API（`call`/`tell`）底层就是调用这些方法
   - 测试框架和 Mock 实现

##### **性能特性**

*   **零拷贝**：`payload` 使用 `bytes::Bytes`，支持引用计数的零拷贝传递
*   **零序列化开销**：手工控制序列化时机，避免不必要的编解码

#### **层级二：基于类型的通信 (编译时生成)**

这是更高层、更推荐的解耦通信方式。当你的 Actor 只关心“需要什么类型的服务”，而**不关心由谁、在哪里提供服务**时，就应该使用此模式。

框架通过编译时代码生成，为每个在 `Actr.toml` 中 `[dependencies]` 部分声明的**依赖别名**，创建对应的客户端方法。

*   **声明依赖**:
    ```toml
    # Actr.toml
    [dependencies]
    # "user_api" 是我们为 "user-service" 这个 ActrType 定义的本地别名
    user_api = { actr_type = "acme:user-service" }
    ```

*   **生成客户端**: `actr gen` 会读取上述配置，并为 `Context` 生成一个名为 `user_api` 的方法，该方法返回一个包含了 `user-service` 所有 RPC 的客户端。

*   **在代码中调用**:
    ```rust
    // 业务逻辑中，通过别名来调用
    async fn some_logic(&self, ctx: &Context) {
        let profile = ctx.user_api()
                         .get_profile(GetUserRequest { ... })
                         .await?;
    }
    ```

这种设计将服务发现和实例选择的复杂性从业务代码中完全剥离，同时通过编译时代码生成保证了类型安全和良好的开发体验。这是实现“**基于类型的通信**”架构模式和构建可扩展、可维护系统的基石。

### 总结

`Context` 是框架设计中的一个核心概念。它通过三大支柱，将复杂的副作用、环境信息和 Actor 间通信，抽象为一套简洁、安全、高度可测试的 API。

通过强制采用“请求，而非命令”的交互模式，`Context` 将 `Actor` 从纷繁复杂的外部世界中隔离开来，让它回归为一个纯粹、专注、易于推理的状态机。当你下一次在方法签名中看到 `context` 时，请记住：它不仅仅是一个参数，更是你编写出健壮、可维护 `Actor` 的重要工具。