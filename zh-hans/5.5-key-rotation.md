# Actrix å¯†é’¥è½®æ¢ç­–ç•¥

## æ¦‚è¿°

å¯†é’¥è½®æ¢æ˜¯ Actrix è®¤è¯ç³»ç»Ÿçš„æ ¸å¿ƒå®‰å…¨æœºåˆ¶ï¼Œé€šè¿‡å®šæœŸæ›´æ¢åŠ å¯†å¯†é’¥æ¥é™ä½å¯†é’¥æ³„éœ²çš„é£é™©ã€‚Key Server (KS) è´Ÿè´£è‡ªåŠ¨ç®¡ç†å¯†é’¥çš„ç”Ÿæˆã€è½®æ¢å’Œè¿‡æœŸï¼Œè€Œå…¶ä»–æœåŠ¡ï¼ˆAISã€Signalingã€TURNï¼‰é€šè¿‡ç¼“å­˜æœºåˆ¶é«˜æ•ˆåœ°ä½¿ç”¨è¿™äº›å¯†é’¥ã€‚

## æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant ks as ks (åå°ä»»åŠ¡)
    participant db as æ•°æ®åº“
    participant ais as ais
    participant signaling as signaling

    Note over ks: å¯åŠ¨åå°è½®æ¢ä»»åŠ¡<br/>æ¯ 10 åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

    loop æ¯ 10 åˆ†é’Ÿ
        ks->>ks: 27. æ£€æŸ¥å½“å‰å¯†é’¥æœ‰æ•ˆæœŸ
        Note right of ks: è®¡ç®—: now() vs current_key.valid_until<br/>é˜ˆå€¼: 24 å°æ—¶

        alt è·ç¦»è¿‡æœŸ < å®¹å¿æ—¶é—´ï¼ˆ1 å°æ—¶ï¼‰
            ks->>ks: 28. ç”Ÿæˆæ–°å¯†é’¥
            Note right of ks: 1. ä½¿ç”¨ ECIES (secp256k1)<br/>2. ç”Ÿæˆå…¬é’¥/ç§é’¥å¯¹<br/>3. Base64 ç¼–ç <br/>4. åˆ†é…æ–° key_id (è‡ªå¢)

            ks->>db: 29. å­˜å‚¨æ–°å¯†é’¥
            Note right of ks: INSERT INTO keys:<br/>- key_id: u32<br/>- public_key: String (Base64)<br/>- secret_key: String (Base64)<br/>- created_at: Timestamp<br/>- valid_until: created_at + 24h

            db-->>ks: å­˜å‚¨æˆåŠŸ

            ks->>ks: 30. æ›´æ–°å½“å‰å¯†é’¥æŒ‡é’ˆ
            Note right of ks: current_key_id = new_key_id<br/>è§¦å‘æ‰€æœ‰ç¼“å­˜å¤±æ•ˆ

            Note over ks,ais: ğŸ”„ æ—§å¯†é’¥è¿›å…¥å®½é™æœŸ<br/>ä»å¯è§£å¯† 1 å°æ—¶å†…ç­¾å‘çš„å‡­è¯

        else å½“å‰å¯†é’¥ä»æœ‰æ•ˆ
            ks->>ks: 27a. è·³è¿‡è½®æ¢
            Note right of ks: ç­‰å¾…ä¸‹ä¸€æ¬¡æ£€æŸ¥
        end
    end

    Note over ks: å®½é™æœŸç»“æŸåï¼ˆè½®æ¢ + 1 å°æ—¶ï¼‰

    ks->>ks: 31. æ¸…ç†è¿‡æœŸå¯†é’¥ï¼ˆå¯é€‰ï¼‰
    Note right of ks: ç­–ç•¥:<br/>1. ä¿ç•™æœ€è¿‘ N ä¸ªå¯†é’¥ï¼ˆå¦‚ 10 ä¸ªï¼‰<br/>2. åˆ é™¤è¶…è¿‡ 30 å¤©çš„å¯†é’¥<br/>3. ä¼˜åŒ–å­˜å‚¨ç©ºé—´

    ks->>db: DELETE FROM keys WHERE...
    Note right of ks: created_at < now() - 30 days<br/>AND key_id NOT IN (æœ€è¿‘ 10 ä¸ª)

    Note over ais,signaling: CurrentKeyCache è‡ªåŠ¨æ›´æ–°<br/>SecretKeyCache ä¿ç•™å†å²å¯†é’¥

    ais->>ks: GetCurrentKeyRequest (ç¼“å­˜è¿‡æœŸ)
    Note right of ais: ç¼“å­˜ TTL: 10 åˆ†é’Ÿ

    ks-->>ais: GetCurrentKeyResponse
    Note left of ks: key_id: new_key_id<br/>public_key: new_public_key<br/>valid_until: now() + 24h

    ais->>ais: æ›´æ–° CurrentKeyCache
    Note right of ais: åç»­æ³¨å†Œ/ç»­æœŸä½¿ç”¨æ–°å¯†é’¥

    signaling->>ks: GetSecretKeyRequest (éªŒè¯æ—§å‡­è¯)
    Note right of signaling: key_id: old_key_id

    ks-->>signaling: GetSecretKeyResponse
    Note left of ks: secret_key: old_secret_key<br/>å†å²å¯†é’¥ä»å¯æŸ¥è¯¢

    signaling->>signaling: æ›´æ–° SecretKeyCache
    Note right of signaling: æ”¯æŒå¤šç‰ˆæœ¬å¯†é’¥<br/>ç¼“å­˜æ°¸ä¹…æœ‰æ•ˆ
```

---

## æ ¸å¿ƒæ¦‚å¿µ

### å¯†é’¥ç”Ÿå‘½å‘¨æœŸ

```
å¯†é’¥æ—¶é—´çº¿ï¼š
â”œâ”€ T0: å¯†é’¥ç”Ÿæˆ
â”‚  â”œâ”€ key_id: 5
â”‚  â”œâ”€ valid_until: T0 + 24h
â”‚  â””â”€ status: ACTIVE
â”‚
â”œâ”€ T0 - 24h + 1h (è·ç¦»è¿‡æœŸ 1 å°æ—¶): è§¦å‘è½®æ¢
â”‚  â”œâ”€ ç”Ÿæˆ key_id=6
â”‚  â”œâ”€ current_key_id: 5 â†’ 6
â”‚  â””â”€ key_id=5 è¿›å…¥å®½é™æœŸ (GRACE_PERIOD)
â”‚
â”œâ”€ T0 - 24h: key_id=5 æ­£å¼è¿‡æœŸ
â”‚  â”œâ”€ ä¸å†ç”¨äºç­¾å‘æ–°å‡­è¯
â”‚  â”œâ”€ ä»å¯è§£å¯†åœ¨å®½é™æœŸå†…ç­¾å‘çš„å‡­è¯
â”‚  â””â”€ status: EXPIRED
â”‚
â”œâ”€ T0 - 24h + 1h: å®½é™æœŸç»“æŸ
â”‚  â”œâ”€ ä½¿ç”¨ key_id=5 ç­¾å‘çš„æœ€åä¸€æ‰¹å‡­è¯è¿‡æœŸ
â”‚  â””â”€ key_id=5 å¯ä»¥è¢«æ¸…ç† (status: DEPRECATED)
â”‚
â””â”€ T0 + 30 days: æ¸…ç†ç­–ç•¥
   â”œâ”€ å¦‚æœ key_id=5 ä¸åœ¨æœ€è¿‘ 10 ä¸ªå¯†é’¥ä¸­
   â””â”€ ä»æ•°æ®åº“åˆ é™¤
```

---

### æ—¶é—´å‚æ•°é…ç½®

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| **KEY_VALIDITY** | 86400s (24h) | å¯†é’¥æœ‰æ•ˆæœŸ |
| **KEY_GRACE_PERIOD** | 3600s (1h) | å¯†é’¥è½®æ¢å®½é™æœŸ |
| **ROTATION_CHECK_INTERVAL** | 600s (10min) | è½®æ¢ä»»åŠ¡æ£€æŸ¥é—´éš” |
| **CREDENTIAL_TTL** | 3600s (1h) | å‡­è¯æœ‰æ•ˆæœŸ |
| **CURRENT_KEY_CACHE_TTL** | 600s (10min) | AIS å…¬é’¥ç¼“å­˜ TTL |
| **HISTORICAL_KEY_RETENTION** | 10 keys | ä¿ç•™å†å²å¯†é’¥æ•°é‡ |
| **KEY_ARCHIVE_DAYS** | 30 days | å¯†é’¥å½’æ¡£æ—¶é—´ |

**æ—¶é—´å…³ç³»çº¦æŸ**:
```
CREDENTIAL_TTL â‰¤ KEY_GRACE_PERIOD â‰¤ KEY_VALIDITY

åŸå› ï¼š
1. å‡­è¯å¿…é¡»åœ¨å¯†é’¥å®½é™æœŸå†…è¿‡æœŸï¼Œç¡®ä¿å¯éªŒè¯
2. å®½é™æœŸå¿…é¡»åœ¨å¯†é’¥æœ‰æ•ˆæœŸå†…ï¼Œé¿å…ä½¿ç”¨å®Œå…¨å¤±æ•ˆçš„å¯†é’¥
```

---

## KS å®ç°è¯¦è§£

### æ­¥éª¤ 27-28: è½®æ¢è§¦å‘é€»è¾‘

**åå°ä»»åŠ¡** (`actrix/crates/keyserver/src/server.rs`):

```rust
use tokio::time::{interval, Duration};

pub struct KeyServer {
    config: Config,
    storage: Arc<KeyStorage>,
    current_key_id: Arc<RwLock<u32>>,
}

#[derive(Clone)]
pub struct Config {
    /// å¯†é’¥æœ‰æ•ˆæœŸï¼ˆé»˜è®¤ 24 å°æ—¶ï¼‰
    pub key_validity: Duration,
    
    /// è½®æ¢å®½é™æœŸï¼ˆé»˜è®¤ 1 å°æ—¶ï¼‰
    pub grace_period: Duration,
    
    /// è½®æ¢æ£€æŸ¥é—´éš”ï¼ˆé»˜è®¤ 10 åˆ†é’Ÿï¼‰
    pub rotation_check_interval: Duration,
    
    /// å†å²å¯†é’¥ä¿ç•™æ•°é‡ï¼ˆé»˜è®¤ 10ï¼‰
    pub historical_key_retention: usize,
    
    /// å¯†é’¥å½’æ¡£å¤©æ•°ï¼ˆé»˜è®¤ 30 å¤©ï¼‰
    pub key_archive_days: u64,
}

impl KeyServer {
    /// å¯åŠ¨è‡ªåŠ¨è½®æ¢ä»»åŠ¡
    pub async fn start_auto_rotation(&self) {
        let mut check_interval = interval(self.config.rotation_check_interval);
        
        loop {
            check_interval.tick().await;
            
            if let Err(e) = self.check_and_rotate_if_needed().await {
                error!("Failed to check/rotate key: {}", e);
            }
        }
    }
    
    /// æ£€æŸ¥å¹¶è½®æ¢å¯†é’¥
    async fn check_and_rotate_if_needed(&self) -> Result<()> {
        let current_key_id = *self.current_key_id.read().await;
        
        // 1. è·å–å½“å‰å¯†é’¥ä¿¡æ¯
        let current_key = self.storage.get_key(current_key_id).await?;
        
        // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦è½®æ¢
        let now = SystemTime::now().as_secs();
        let time_until_expiry = current_key.valid_until.saturating_sub(now);
        
        if time_until_expiry <= self.config.grace_period.as_secs() {
            info!(
                "Key rotation triggered: current_key_id={}, time_until_expiry={}s",
                current_key_id, time_until_expiry
            );
            
            self.rotate_key().await?;
        } else {
            debug!(
                "Key still valid: current_key_id={}, time_until_expiry={}s",
                current_key_id, time_until_expiry
            );
        }
        
        Ok(())
    }
    
    /// æ‰§è¡Œå¯†é’¥è½®æ¢
    async fn rotate_key(&self) -> Result<()> {
        // 1. ç”Ÿæˆæ–°å¯†é’¥å¯¹
        let (secret_key, public_key) = self.generate_keypair()?;
        
        // 2. è®¡ç®—æœ‰æ•ˆæœŸ
        let now = SystemTime::now().as_secs();
        let valid_until = now + self.config.key_validity.as_secs();
        
        // 3. åˆ†é…æ–° key_idï¼ˆè‡ªå¢ï¼‰
        let new_key_id = self.storage.get_next_key_id().await?;
        
        // 4. å­˜å‚¨åˆ°æ•°æ®åº“
        let key_entry = KeyEntry {
            key_id: new_key_id,
            public_key: base64::encode(&public_key),
            secret_key: base64::encode(&secret_key),
            created_at: now,
            valid_until,
        };
        
        self.storage.store_key(key_entry).await?;
        
        // 5. æ›´æ–°å½“å‰å¯†é’¥æŒ‡é’ˆ
        *self.current_key_id.write().await = new_key_id;
        
        info!(
            "Key rotated successfully: old_key_id={}, new_key_id={}, valid_until={}",
            new_key_id - 1, new_key_id, valid_until
        );
        
        // 6. å¯é€‰ï¼šæ¸…ç†è¿‡æœŸå¯†é’¥
        self.cleanup_expired_keys().await?;
        
        Ok(())
    }
    
    /// ç”Ÿæˆ ECIES å¯†é’¥å¯¹
    fn generate_keypair(&self) -> Result<(Vec<u8>, Vec<u8>)> {
        use secp256k1::{Secp256k1, SecretKey, PublicKey};
        use rand::rngs::OsRng;
        
        let secp = Secp256k1::new();
        let mut rng = OsRng;
        
        // 1. ç”Ÿæˆç§é’¥ï¼ˆ32 å­—èŠ‚ï¼‰
        let secret_key = SecretKey::new(&mut rng);
        
        // 2. æ´¾ç”Ÿå…¬é’¥ï¼ˆ33 å­—èŠ‚ï¼Œå‹ç¼©æ ¼å¼ï¼‰
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);
        
        Ok((
            secret_key.secret_bytes().to_vec(),
            public_key.serialize().to_vec(),
        ))
    }
}
```

---

### æ­¥éª¤ 29: å¯†é’¥å­˜å‚¨

**æ•°æ®åº“ Schema**:

```sql
CREATE TABLE keys (
    key_id INTEGER PRIMARY KEY,
    public_key TEXT NOT NULL,        -- Base64 ç¼–ç çš„å…¬é’¥
    secret_key TEXT NOT NULL,        -- Base64 ç¼–ç çš„ç§é’¥ï¼ˆåŠ å¯†å­˜å‚¨ï¼‰
    created_at BIGINT NOT NULL,      -- Unix timestamp (ç§’)
    valid_until BIGINT NOT NULL,     -- Unix timestamp (ç§’)
    INDEX idx_valid_until (valid_until)
);

-- å½“å‰å¯†é’¥æŒ‡é’ˆï¼ˆå•è¡Œè¡¨ï¼‰
CREATE TABLE current_key (
    id INTEGER PRIMARY KEY DEFAULT 1,
    key_id INTEGER NOT NULL,
    updated_at BIGINT NOT NULL,
    FOREIGN KEY (key_id) REFERENCES keys(key_id)
);
```

**å­˜å‚¨å®ç°**:

```rust
use sqlx::SqlitePool;

pub struct KeyStorage {
    pool: SqlitePool,
}

impl KeyStorage {
    /// å­˜å‚¨æ–°å¯†é’¥
    pub async fn store_key(&self, entry: KeyEntry) -> Result<()> {
        sqlx::query!(
            "INSERT INTO keys (key_id, public_key, secret_key, created_at, valid_until)
             VALUES (?, ?, ?, ?, ?)",
            entry.key_id,
            entry.public_key,
            entry.secret_key,
            entry.created_at,
            entry.valid_until,
        )
        .execute(&self.pool)
        .await?;
        
        // æ›´æ–°å½“å‰å¯†é’¥æŒ‡é’ˆ
        self.set_current_key_id(entry.key_id).await?;
        
        Ok(())
    }
    
    /// è·å–å¯†é’¥
    pub async fn get_key(&self, key_id: u32) -> Result<KeyEntry> {
        let row = sqlx::query!(
            "SELECT key_id, public_key, secret_key, created_at, valid_until
             FROM keys WHERE key_id = ?",
            key_id,
        )
        .fetch_one(&self.pool)
        .await?;
        
        Ok(KeyEntry {
            key_id: row.key_id as u32,
            public_key: row.public_key,
            secret_key: row.secret_key,
            created_at: row.created_at as u64,
            valid_until: row.valid_until as u64,
        })
    }
    
    /// è·å–å½“å‰å¯†é’¥ ID
    pub async fn get_current_key_id(&self) -> Result<u32> {
        let row = sqlx::query!("SELECT key_id FROM current_key WHERE id = 1")
            .fetch_one(&self.pool)
            .await?;
        
        Ok(row.key_id as u32)
    }
    
    /// è®¾ç½®å½“å‰å¯†é’¥ ID
    async fn set_current_key_id(&self, key_id: u32) -> Result<()> {
        let now = SystemTime::now().as_secs();
        
        sqlx::query!(
            "INSERT OR REPLACE INTO current_key (id, key_id, updated_at)
             VALUES (1, ?, ?)",
            key_id,
            now,
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    /// è·å–ä¸‹ä¸€ä¸ª key_id
    pub async fn get_next_key_id(&self) -> Result<u32> {
        let row = sqlx::query!("SELECT COALESCE(MAX(key_id), 0) + 1 as next_id FROM keys")
            .fetch_one(&self.pool)
            .await?;
        
        Ok(row.next_id as u32)
    }
}
```

---

### æ­¥éª¤ 31: å¯†é’¥æ¸…ç†ç­–ç•¥

**æ¸…ç†é€»è¾‘**:

```rust
impl KeyServer {
    /// æ¸…ç†è¿‡æœŸå¯†é’¥
    async fn cleanup_expired_keys(&self) -> Result<()> {
        let now = SystemTime::now().as_secs();
        let archive_threshold = now - (self.config.key_archive_days * 86400);
        
        // 1. è·å–æœ€è¿‘ N ä¸ªå¯†é’¥çš„ IDï¼ˆä¸åˆ é™¤ï¼‰
        let recent_key_ids = self.storage.get_recent_key_ids(
            self.config.historical_key_retention
        ).await?;
        
        // 2. åˆ é™¤è¶…è¿‡å½’æ¡£å¤©æ•°ä¸”ä¸åœ¨ä¿ç•™åˆ—è¡¨ä¸­çš„å¯†é’¥
        let deleted = self.storage.delete_keys_before(
            archive_threshold,
            &recent_key_ids,
        ).await?;
        
        if deleted > 0 {
            info!("Cleaned up {} expired keys", deleted);
        }
        
        Ok(())
    }
}

impl KeyStorage {
    /// è·å–æœ€è¿‘ N ä¸ªå¯†é’¥çš„ ID
    pub async fn get_recent_key_ids(&self, limit: usize) -> Result<Vec<u32>> {
        let rows = sqlx::query!(
            "SELECT key_id FROM keys
             ORDER BY created_at DESC
             LIMIT ?",
            limit as i64,
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(rows.into_iter().map(|r| r.key_id as u32).collect())
    }
    
    /// åˆ é™¤æŒ‡å®šæ—¶é—´ä¹‹å‰çš„å¯†é’¥ï¼ˆæ’é™¤ä¿ç•™åˆ—è¡¨ï¼‰
    pub async fn delete_keys_before(
        &self,
        before: u64,
        except: &[u32],
    ) -> Result<u64> {
        // æ„é€  NOT IN å­å¥
        let placeholders = except.iter().map(|_| "?").collect::<Vec<_>>().join(",");
        let query = format!(
            "DELETE FROM keys WHERE created_at < ? AND key_id NOT IN ({})",
            placeholders
        );
        
        let mut query = sqlx::query(&query).bind(before as i64);
        for key_id in except {
            query = query.bind(*key_id as i64);
        }
        
        let result = query.execute(&self.pool).await?;
        Ok(result.rows_affected())
    }
}
```

**æ¸…ç†ç­–ç•¥ç¤ºä¾‹**:

```
å½“å‰æ—¶é—´: 2024-01-31 12:00:00
å½’æ¡£é˜ˆå€¼: 2024-01-01 12:00:00 (30 å¤©å‰)
ä¿ç•™æ•°é‡: 10 ä¸ª

æ•°æ®åº“ä¸­çš„å¯†é’¥:
â”œâ”€ key_id=1, created_at=2023-12-01 (60 å¤©å‰) âŒ åˆ é™¤
â”œâ”€ key_id=2, created_at=2023-12-15 (46 å¤©å‰) âŒ åˆ é™¤
â”œâ”€ key_id=3, created_at=2024-01-05 (26 å¤©å‰) âœ… ä¿ç•™ï¼ˆæœ€è¿‘ 10 ä¸ªï¼‰
â”œâ”€ ...
â”œâ”€ key_id=11, created_at=2024-01-29 (2 å¤©å‰) âœ… ä¿ç•™ï¼ˆæœ€è¿‘ 10 ä¸ªï¼‰
â””â”€ key_id=12, created_at=2024-01-31 (å½“å‰) âœ… ä¿ç•™ï¼ˆå½“å‰å¯†é’¥ï¼‰

æ¸…ç†ç»“æœ:
â”œâ”€ åˆ é™¤ key_id=1, 2
â”œâ”€ ä¿ç•™ key_id=3-12
â””â”€ èŠ‚çœå­˜å‚¨ç©ºé—´
```

---

## ç¼“å­˜åŒæ­¥æœºåˆ¶

### CurrentKeyCache (AIS)

**æ›´æ–°è§¦å‘**:

```rust
impl Issuer {
    /// è·å–å½“å‰å…¬é’¥ï¼ˆç¼“å­˜ä¼˜å…ˆï¼‰
    async fn get_current_public_key(&self) -> Result<(u32, String, u64)> {
        // 1ï¸âƒ£ æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.current_key_cache.read().await.as_ref() {
            let now = SystemTime::now();
            
            if now < cached.expires_at {
                debug!("CurrentKeyCache hit: key_id={}", cached.key_id);
                return Ok((
                    cached.key_id,
                    cached.public_key.clone(),
                    cached.valid_until,
                ));
            } else {
                debug!("CurrentKeyCache expired, refreshing");
            }
        }
        
        // 2ï¸âƒ£ ç¼“å­˜æœªå‘½ä¸­æˆ–è¿‡æœŸï¼Œè°ƒç”¨ KS
        let request = GetCurrentKeyRequest {};
        let response = self.ks_client.get_current_key(request).await?;
        
        // 3ï¸âƒ£ æ›´æ–°ç¼“å­˜
        let cache_entry = CurrentKeyEntry {
            key_id: response.key_id,
            public_key: response.public_key.clone(),
            valid_until: response.valid_until,
            expires_at: SystemTime::now() + Duration::from_secs(600),  // 10 åˆ†é’Ÿ
        };
        
        *self.current_key_cache.write().await = Some(cache_entry);
        
        info!("CurrentKeyCache updated: key_id={}", response.key_id);
        
        Ok((response.key_id, response.public_key, response.valid_until))
    }
}
```

**è½®æ¢åç¼“å­˜æ›´æ–°æ—¶é—´çº¿**:

```
T0: KS è½®æ¢å¯†é’¥ (key_id: 5 â†’ 6)
â”œâ”€ current_key_id æ›´æ–°ä¸º 6
â”‚
â”œâ”€ T0+1s: AIS1 å‘èµ·æ³¨å†Œè¯·æ±‚
â”‚  â”œâ”€ CurrentKeyCache ä»ç¼“å­˜ key_id=5ï¼ˆæœªè¿‡æœŸï¼‰
â”‚  â”œâ”€ ä½¿ç”¨ key_id=5 ç­¾å‘å‡­è¯ âœ… (åœ¨å®½é™æœŸå†…)
â”‚  â””â”€ å‡­è¯ valid_until: T0+1hï¼ˆåœ¨ key_id=5 å®½é™æœŸå†…ï¼‰
â”‚
â”œâ”€ T0+10min: AIS1 çš„ CurrentKeyCache è¿‡æœŸ
â”‚  â”œâ”€ ä¸‹æ¬¡æ³¨å†Œæ—¶è°ƒç”¨ GetCurrentKey
â”‚  â”œâ”€ KS è¿”å› key_id=6
â”‚  â””â”€ æ›´æ–°ç¼“å­˜ä¸º key_id=6
â”‚
â”œâ”€ T0+5min: AIS2 å‘èµ·æ³¨å†Œè¯·æ±‚
â”‚  â”œâ”€ CurrentKeyCache è¿‡æœŸï¼ˆåˆšå¯åŠ¨ï¼‰
â”‚  â”œâ”€ è°ƒç”¨ GetCurrentKey â†’ key_id=6
â”‚  â””â”€ ä½¿ç”¨ key_id=6 ç­¾å‘å‡­è¯ âœ…
â”‚
â””â”€ T0+1h: æ‰€æœ‰ AIS å®ä¾‹çš„ç¼“å­˜éƒ½å·²æ›´æ–°ä¸º key_id=6
```

---

### SecretKeyCache (Signaling)

**å¤šç‰ˆæœ¬æ”¯æŒ**:

```rust
pub struct CredentialVerifier {
    secret_key_cache: Arc<RwLock<HashMap<u32, SecretKeyEntry>>>,
}

impl CredentialVerifier {
    /// éªŒè¯å‡­è¯ï¼ˆæ”¯æŒå†å²å¯†é’¥ï¼‰
    pub async fn verify_credential(
        &self,
        credential: &str,
        encrypted_credential: &str,
    ) -> Result<IdentityClaims> {
        let encrypted_bytes = base64::decode(encrypted_credential)?;
        let key_id = u32::from_be_bytes(encrypted_bytes[0..4].try_into()?);
        
        // è·å–è§£å¯†å¯†é’¥ï¼ˆå¯èƒ½æ˜¯æ—§ç‰ˆæœ¬ï¼‰
        let secret_key = self.get_secret_key(key_id).await?;
        
        // ... è§£å¯†å’ŒéªŒè¯
    }
    
    /// è·å–è§£å¯†å¯†é’¥ï¼ˆæ”¯æŒå¤šç‰ˆæœ¬ç¼“å­˜ï¼‰
    async fn get_secret_key(&self, key_id: u32) -> Result<Vec<u8>> {
        // 1ï¸âƒ£ æ£€æŸ¥ç¼“å­˜ï¼ˆæ°¸ä¹…æœ‰æ•ˆï¼‰
        if let Some(entry) = self.secret_key_cache.read().await.get(&key_id) {
            debug!("SecretKeyCache hit: key_id={}", key_id);
            return Ok(entry.secret_key.clone());
        }
        
        // 2ï¸âƒ£ ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨ KS GetSecretKey
        let request = GetSecretKeyRequest { key_id };
        let response = self.ks_client.get_secret_key(request).await?;
        
        let secret_key = base64::decode(&response.secret_key)?;
        
        // 3ï¸âƒ£ å­˜å…¥ç¼“å­˜ï¼ˆä¸è®¾ç½®è¿‡æœŸæ—¶é—´ï¼‰
        self.secret_key_cache.write().await.insert(key_id, SecretKeyEntry {
            secret_key: secret_key.clone(),
            cached_at: SystemTime::now(),
        });
        
        info!("SecretKeyCache updated: key_id={}, cache_size={}",
              key_id, self.secret_key_cache.read().await.len());
        
        Ok(secret_key)
    }
}
```

**ä¸ºä»€ä¹ˆ SecretKeyCache æ°¸ä¹…æœ‰æ•ˆï¼Ÿ**

1. **å†å²å‡­è¯éªŒè¯**: æ—§å‡­è¯åœ¨æœ‰æ•ˆæœŸå†…ä»éœ€éªŒè¯
2. **å¯†é’¥ä¸å˜æ€§**: ä¸€æ—¦ç”Ÿæˆï¼Œsecret_key æ°¸ä¸æ”¹å˜
3. **å†…å­˜å¯æ§**: åªä¿ç•™æœ€è¿‘ 10 ä¸ªå¯†é’¥ï¼Œå†…å­˜å ç”¨ < 1KB

---

## å®½é™æœŸè¯¦è§£

### å®½é™æœŸçš„ä½œç”¨

**åœºæ™¯ 1: å¹³æ»‘è¿‡æ¸¡**

```
æ— å®½é™æœŸï¼š
â”œâ”€ T0: KS è½®æ¢å¯†é’¥ (key_id: 5 â†’ 6)
â”œâ”€ T0+1s: AIS1 ç¼“å­˜ä»æ˜¯ key_id=5
â”‚  â””â”€ ä½¿ç”¨ key_id=5 ç­¾å‘å‡­è¯
â”‚  â””â”€ Signaling æ— æ³•éªŒè¯ï¼ˆkey_id=5 å·²åˆ é™¤ï¼‰âŒ
â”‚  â””â”€ å®¢æˆ·ç«¯è®¤è¯å¤±è´¥
â”‚
â””â”€ ç»“æœï¼šæœåŠ¡ä¸­æ–­

æœ‰å®½é™æœŸï¼š
â”œâ”€ T0: KS è½®æ¢å¯†é’¥ (key_id: 5 â†’ 6)
â”œâ”€ T0+1s: AIS1 ç¼“å­˜ä»æ˜¯ key_id=5
â”‚  â””â”€ ä½¿ç”¨ key_id=5 ç­¾å‘å‡­è¯ âœ…
â”‚  â””â”€ Signaling å¯ä»¥éªŒè¯ï¼ˆkey_id=5 åœ¨å®½é™æœŸå†…ï¼‰
â”‚  â””â”€ å®¢æˆ·ç«¯è®¤è¯æˆåŠŸ
â”‚
â”œâ”€ T0+10min: AIS1 ç¼“å­˜æ›´æ–°ä¸º key_id=6
â”‚  â””â”€ åç»­ä½¿ç”¨ key_id=6 ç­¾å‘å‡­è¯
â”‚
â””â”€ T0+1h: æ‰€æœ‰ key_id=5 çš„å‡­è¯éƒ½å·²è¿‡æœŸ
   â””â”€ key_id=5 å¯ä»¥å®‰å…¨åˆ é™¤
```

---

**åœºæ™¯ 2: å¹¶å‘è¯·æ±‚ä¸€è‡´æ€§**

```
æ— å®½é™æœŸï¼š
â”œâ”€ T0: KS è½®æ¢å¯†é’¥
â”œâ”€ T0+1ms: å®¢æˆ·ç«¯ A æ³¨å†Œï¼ˆä½¿ç”¨ key_id=5ï¼‰
â”œâ”€ T0+2ms: å®¢æˆ·ç«¯ B æ³¨å†Œï¼ˆä½¿ç”¨ key_id=6ï¼‰
â”‚  â””â”€ ä¸¤ä¸ªå®¢æˆ·ç«¯è·å¾—ä¸åŒ key_id çš„å‡­è¯
â”‚  â””â”€ å¦‚æœ key_id=5 ç«‹å³å¤±æ•ˆï¼Œå®¢æˆ·ç«¯ A ç«‹å³æ— æ³•è®¤è¯ âŒ
â”‚
â””â”€ ç»“æœï¼šéƒ¨åˆ†å®¢æˆ·ç«¯è®¤è¯å¤±è´¥

æœ‰å®½é™æœŸï¼š
â”œâ”€ T0: KS è½®æ¢å¯†é’¥
â”œâ”€ T0+1ms: å®¢æˆ·ç«¯ A æ³¨å†Œï¼ˆä½¿ç”¨ key_id=5ï¼‰âœ…
â”œâ”€ T0+2ms: å®¢æˆ·ç«¯ B æ³¨å†Œï¼ˆä½¿ç”¨ key_id=6ï¼‰âœ…
â”‚  â””â”€ ä¸¤ä¸ªå‡­è¯éƒ½æœ‰æ•ˆ
â”‚
â”œâ”€ T0+1h: å®¢æˆ·ç«¯ A çš„å‡­è¯è¿‡æœŸï¼ˆè‡ªåŠ¨ç»­æœŸï¼‰
â”‚  â””â”€ ç»­æœŸæ—¶ä½¿ç”¨ key_id=6
â”‚
â””â”€ ç»“æœï¼šé›¶ä¸­æ–­
```

---

### å®½é™æœŸæ—¶é—´é€‰æ‹©

**ä¸ºä»€ä¹ˆé€‰æ‹© 1 å°æ—¶ï¼Ÿ**

1. **å‡­è¯æœ‰æ•ˆæœŸ**: å‡­è¯ TTL æ˜¯ 1 å°æ—¶ï¼Œå®½é™æœŸ â‰¥ å‡­è¯ TTL å¯ç¡®ä¿æ‰€æœ‰å‡­è¯å¯éªŒè¯
2. **ç¼“å­˜åˆ·æ–°**: CurrentKeyCache TTL æ˜¯ 10 åˆ†é’Ÿï¼Œ1 å°æ—¶å¯å®¹çº³ 6 æ¬¡ç¼“å­˜åˆ·æ–°
3. **å®¹é”™ç©ºé—´**: å…è®¸çŸ­æ—¶é—´çš„ç½‘ç»œæ•…éšœæˆ–æœåŠ¡é‡å¯

**å¦‚æœå®½é™æœŸ < å‡­è¯ TTL ä¼šæ€æ ·ï¼Ÿ**

```
é…ç½®:
â”œâ”€ KEY_GRACE_PERIOD: 30 åˆ†é’Ÿ
â””â”€ CREDENTIAL_TTL: 1 å°æ—¶

æ—¶é—´çº¿:
â”œâ”€ T0: KS è½®æ¢ (key_id: 5 â†’ 6)
â”œâ”€ T0+1min: å®¢æˆ·ç«¯æ³¨å†Œï¼ˆä½¿ç”¨ key_id=5, expires_at=T0+1hï¼‰
â”œâ”€ T0+30min: å®½é™æœŸç»“æŸï¼Œkey_id=5 è¢«æ ‡è®°ä¸ºå®Œå…¨è¿‡æœŸ
â”œâ”€ T0+31min: å®¢æˆ·ç«¯å°è¯•ä½¿ç”¨å‡­è¯
â”‚  â””â”€ Signaling è°ƒç”¨ GetSecretKey(key_id=5)
â”‚  â””â”€ KS æ‹’ç»è¿”å›ï¼ˆå·²è¿‡æœŸï¼‰âŒ
â”‚  â””â”€ è®¤è¯å¤±è´¥
â”‚
â””â”€ ç»“æœï¼šåˆæ³•å‡­è¯æ— æ³•ä½¿ç”¨
```

---

## KS gRPC æ¥å£

### GetCurrentKeyRequest/Response

**å®šä¹‰**:

```protobuf
message GetCurrentKeyRequest {
  // ç©ºè¯·æ±‚
}

message GetCurrentKeyResponse {
  required uint32 key_id = 1;
  required string public_key = 2;  // Base64 ç¼–ç 
  required uint64 valid_until = 3;  // Unix timestamp (ç§’)
}
```

**å®ç°**:

```rust
use tonic::{Request, Response, Status};

#[tonic::async_trait]
impl KeyService for KeyServer {
    async fn get_current_key(
        &self,
        _request: Request<GetCurrentKeyRequest>,
    ) -> Result<Response<GetCurrentKeyResponse>, Status> {
        let current_key_id = *self.current_key_id.read().await;
        
        let key = self.storage.get_key(current_key_id).await
            .map_err(|e| Status::internal(format!("Failed to get key: {}", e)))?;
        
        Ok(Response::new(GetCurrentKeyResponse {
            key_id: key.key_id,
            public_key: key.public_key,
            valid_until: key.valid_until,
        }))
    }
}
```

---

### GetSecretKeyRequest/Response

**å®šä¹‰**:

```protobuf
message GetSecretKeyRequest {
  required uint32 key_id = 1;
}

message GetSecretKeyResponse {
  required string secret_key = 1;  // Base64 ç¼–ç 
}
```

**å®ç°**:

```rust
#[tonic::async_trait]
impl KeyService for KeyServer {
    async fn get_secret_key(
        &self,
        request: Request<GetSecretKeyRequest>,
    ) -> Result<Response<GetSecretKeyResponse>, Status> {
        let key_id = request.get_ref().key_id;
        
        let key = self.storage.get_key(key_id).await
            .map_err(|e| Status::not_found(format!("Key not found: {}", e)))?;
        
        // å¯é€‰ï¼šæ£€æŸ¥å¯†é’¥æ˜¯å¦åœ¨å®½é™æœŸå†…
        let now = SystemTime::now().as_secs();
        let grace_period_end = key.valid_until + self.config.grace_period.as_secs();
        
        if now > grace_period_end {
            return Err(Status::not_found(format!(
                "Key expired beyond grace period: key_id={}, grace_period_end={}",
                key_id, grace_period_end
            )));
        }
        
        Ok(Response::new(GetSecretKeyResponse {
            secret_key: key.secret_key,
        }))
    }
}
```

---

## å®‰å…¨è€ƒè™‘

### 1. ç§é’¥å­˜å‚¨å®‰å…¨

**é—®é¢˜**: æ•°æ®åº“ä¸­çš„ `secret_key` æ˜¯æ˜æ–‡å­˜å‚¨çš„ï¼Œå¦‚æœæ•°æ®åº“æ³„éœ²ï¼Œæ‰€æœ‰å¯†é’¥éƒ½ä¼šæ³„éœ²ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

pub struct KeyStorage {
    pool: SqlitePool,
    master_key: Key<Aes256Gcm>,  // ä»ç¯å¢ƒå˜é‡æˆ– KMS è·å–
}

impl KeyStorage {
    /// å­˜å‚¨å¯†é’¥ï¼ˆåŠ å¯†ç§é’¥ï¼‰
    pub async fn store_key(&self, entry: KeyEntry) -> Result<()> {
        // 1. åŠ å¯† secret_key
        let cipher = Aes256Gcm::new(&self.master_key);
        let nonce = Nonce::from_slice(b"unique nonce");  // å®é™…åº”éšæœºç”Ÿæˆ
        
        let encrypted_secret = cipher.encrypt(nonce, entry.secret_key.as_bytes())
            .map_err(|e| Error::EncryptionFailed(e))?;
        
        // 2. å­˜å‚¨åŠ å¯†åçš„ç§é’¥
        sqlx::query!(
            "INSERT INTO keys (key_id, public_key, secret_key, created_at, valid_until)
             VALUES (?, ?, ?, ?, ?)",
            entry.key_id,
            entry.public_key,
            base64::encode(&encrypted_secret),  // å­˜å‚¨åŠ å¯†åçš„
            entry.created_at,
            entry.valid_until,
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
    
    /// è·å–å¯†é’¥ï¼ˆè§£å¯†ç§é’¥ï¼‰
    pub async fn get_key(&self, key_id: u32) -> Result<KeyEntry> {
        let row = sqlx::query!("SELECT * FROM keys WHERE key_id = ?", key_id)
            .fetch_one(&self.pool)
            .await?;
        
        // è§£å¯† secret_key
        let cipher = Aes256Gcm::new(&self.master_key);
        let nonce = Nonce::from_slice(b"unique nonce");
        
        let encrypted = base64::decode(&row.secret_key)?;
        let decrypted = cipher.decrypt(nonce, encrypted.as_slice())
            .map_err(|e| Error::DecryptionFailed(e))?;
        
        Ok(KeyEntry {
            key_id: row.key_id as u32,
            public_key: row.public_key,
            secret_key: String::from_utf8(decrypted)?,
            created_at: row.created_at as u64,
            valid_until: row.valid_until as u64,
        })
    }
}
```

---

### 2. è½®æ¢å¤±è´¥å¤„ç†

**é—®é¢˜**: å¦‚æœ KS åœ¨è½®æ¢è¿‡ç¨‹ä¸­å´©æºƒï¼Œå¯èƒ½å¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´ã€‚

**è§£å†³æ–¹æ¡ˆ: äº‹åŠ¡ä¿è¯**

```rust
impl KeyServer {
    async fn rotate_key(&self) -> Result<()> {
        // ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ç¡®ä¿åŸå­æ€§
        let mut tx = self.storage.pool.begin().await?;
        
        // 1. ç”Ÿæˆæ–°å¯†é’¥
        let (secret_key, public_key) = self.generate_keypair()?;
        let now = SystemTime::now().as_secs();
        let valid_until = now + self.config.key_validity.as_secs();
        let new_key_id = self.storage.get_next_key_id().await?;
        
        // 2. æ’å…¥æ–°å¯†é’¥ï¼ˆäº‹åŠ¡å†…ï¼‰
        sqlx::query!(
            "INSERT INTO keys (key_id, public_key, secret_key, created_at, valid_until)
             VALUES (?, ?, ?, ?, ?)",
            new_key_id,
            base64::encode(&public_key),
            base64::encode(&secret_key),
            now,
            valid_until,
        )
        .execute(&mut *tx)
        .await?;
        
        // 3. æ›´æ–°å½“å‰å¯†é’¥æŒ‡é’ˆï¼ˆäº‹åŠ¡å†…ï¼‰
        sqlx::query!(
            "UPDATE current_key SET key_id = ?, updated_at = ? WHERE id = 1",
            new_key_id,
            now,
        )
        .execute(&mut *tx)
        .await?;
        
        // 4. æäº¤äº‹åŠ¡
        tx.commit().await?;
        
        // 5. æ›´æ–°å†…å­˜çŠ¶æ€ï¼ˆåªåœ¨äº‹åŠ¡æˆåŠŸåï¼‰
        *self.current_key_id.write().await = new_key_id;
        
        info!("Key rotated successfully: new_key_id={}", new_key_id);
        Ok(())
    }
}
```

---

### 3. æ—¶é’ŸåŒæ­¥

**é—®é¢˜**: å¦‚æœ KSã€AISã€Signaling çš„ç³»ç»Ÿæ—¶é’Ÿä¸åŒæ­¥ï¼Œå¯èƒ½å¯¼è‡´éªŒè¯å¤±è´¥ã€‚

**è§£å†³æ–¹æ¡ˆ**:

1. **ä½¿ç”¨ NTP**: ç¡®ä¿æ‰€æœ‰æœåŠ¡å™¨æ—¶é’ŸåŒæ­¥
2. **æ—¶é—´å®¹å¿åº¦**: éªŒè¯æ—¶å…è®¸ Â±5 åˆ†é’Ÿçš„æ—¶é—´å·®

```rust
const TIME_TOLERANCE: u64 = 300;  // 5 åˆ†é’Ÿ

impl CredentialVerifier {
    fn verify_expiry(&self, credential_expires_at: u64) -> Result<()> {
        let now = SystemTime::now().as_secs();
        
        // å…è®¸ 5 åˆ†é’Ÿçš„æ—¶é’Ÿåå·®
        if now > credential_expires_at + TIME_TOLERANCE {
            return Err(Error::CredentialExpired {
                expired_at: credential_expires_at,
                now,
            });
        }
        
        Ok(())
    }
}
```

---

## ç›‘æ§æŒ‡æ ‡

### è½®æ¢å¥åº·åº¦

```rust
use prometheus::{IntCounter, IntGauge, Histogram};

struct KeyRotationMetrics {
    // è½®æ¢æ¬¡æ•°
    rotations_total: IntCounter,
    
    // è½®æ¢æˆåŠŸ/å¤±è´¥
    rotation_success_total: IntCounter,
    rotation_failure_total: IntCounter,
    
    // å½“å‰å¯†é’¥ ID
    current_key_id: IntGauge,
    
    // å½“å‰å¯†é’¥å‰©ä½™æœ‰æ•ˆæ—¶é—´ï¼ˆç§’ï¼‰
    current_key_time_until_expiry: IntGauge,
    
    // è½®æ¢å»¶è¿Ÿ
    rotation_duration: Histogram,
    
    // å†å²å¯†é’¥æ•°é‡
    historical_keys_count: IntGauge,
}
```

### å‘Šè­¦è§„åˆ™

```yaml
alerts:
  - name: key_expiring_soon
    expr: current_key_time_until_expiry < 7200  # å°äº 2 å°æ—¶
    severity: warning
    message: "å½“å‰å¯†é’¥å³å°†è¿‡æœŸï¼Œä½†æœªè§¦å‘è½®æ¢"
    
  - name: key_rotation_failure
    expr: increase(rotation_failure_total[1h]) > 0
    severity: critical
    message: "å¯†é’¥è½®æ¢å¤±è´¥"
    
  - name: current_key_cache_stale
    expr: time() - current_key_cache_updated_at > 1200  # è¶…è¿‡ 20 åˆ†é’Ÿæœªæ›´æ–°
    severity: warning
    message: "CurrentKeyCache å¯èƒ½æœªæ­£ç¡®æ›´æ–°"
    
  - name: too_many_historical_keys
    expr: historical_keys_count > 50
    severity: info
    message: "å†å²å¯†é’¥æ•°é‡è¿‡å¤šï¼Œå»ºè®®æ¸…ç†"
```

---

## é…ç½®ç¤ºä¾‹

### KS é…ç½®æ–‡ä»¶

```toml
# actrix/crates/keyserver/config.toml

[key_rotation]
# å¯†é’¥æœ‰æ•ˆæœŸï¼ˆé»˜è®¤ 24 å°æ—¶ï¼‰
validity_seconds = 86400

# è½®æ¢å®½é™æœŸï¼ˆé»˜è®¤ 1 å°æ—¶ï¼‰
grace_period_seconds = 3600

# è½®æ¢æ£€æŸ¥é—´éš”ï¼ˆé»˜è®¤ 10 åˆ†é’Ÿï¼‰
check_interval_seconds = 600

# å†å²å¯†é’¥ä¿ç•™æ•°é‡ï¼ˆé»˜è®¤ 10ï¼‰
historical_retention = 10

# å¯†é’¥å½’æ¡£å¤©æ•°ï¼ˆé»˜è®¤ 30 å¤©ï¼‰
archive_days = 30

[storage]
# æ•°æ®åº“è·¯å¾„
database_url = "sqlite:///var/lib/actrix/keys.db"

# ä¸»åŠ å¯†å¯†é’¥ï¼ˆä»ç¯å¢ƒå˜é‡è·å–ï¼‰
# master_key_env = "ACTRIX_MASTER_KEY"

[grpc]
# gRPC ç›‘å¬åœ°å€
listen_addr = "0.0.0.0:50051"
```

---

## ç›¸å…³æ–‡æ¡£

- [æ³¨å†Œæµç¨‹](./1-registration-flow.md)
- [ä¸šåŠ¡è¯·æ±‚è®¤è¯æµç¨‹](./2-authentication-flow.md)
- [TURN è®¤è¯æµç¨‹](./3-turn-authentication.md)
- [å‡­è¯æ›´æ–°æµç¨‹](./4-credential-update.md)
