# 专题解析：服务发现、指纹与兼容性协商

在 `actr` 构建的分布式网络中，一个核心问题是：消费者 Actor (Client) 如何安全、可靠地找到并连接到它所需要的生产者 Actor (Service)？更重要的是，当服务版本发生演进时，系统如何避免因不兼容的更新而导致大规模故障？

本框架通过一套“**基于服务指纹的精确发现**”和“**运行时兼容性协商**”的组合机制，优雅地解决了这个问题。

---

## 1. 协议指纹：服务的唯一身份标识

为了让服务网络中的每一个 Actor 都有一个可验证、不可篡改的身份标识，我们引入了“服务指纹”机制。

*   **服务指纹 (Service Fingerprint)**:
    一个基于协议**语义**的哈希值。它并非对 `.proto` 文件原始内容进行哈希，而是通过 `proto-sign` 库将其解析为抽象语法树（AST），然后对这个忽略了注释、空格等格式差异的标准化 AST 进行哈希，从而生成能够准确反映协议实质内容的指纹。

*   **计算过程**:
    1.  `actr gen` 在构建时，解析 `exports` 中所有 `.proto` 文件，并使用 `proto-regulate` 按 package 进行合并与规范化（merge_by_package），确保文件拆分方式不影响语义。
    2.  使用 `actr-version`（依赖 `proto-sign`）对每个合并后的 package 内容生成语义指纹（package 指纹）。
    3.  为了保证确定性，将所有 package 指纹根据其 package 名称进行字母序排序，然后组合起来计算一个最终的服务级指纹（可选：在组合中纳入 `MERGE_ALGORITHM_VERSION` 以便可追溯）。
    4.  这个最终的服务级指纹会被嵌入到构建产物中。

服务版本表示（消歧说明）：
- 每个 package 维护独立的语义版本（SemVer）。
- 服务层导出一个“组合服务版本字符串”（service_version），作为所有 package 版本的确定性汇总表示（例如按 package 名字母序拼接/编码后再做稳定摘要或派生 SemVer）。
- 运行时匹配策略：
  - 若消费者要求的 service_version 与实例的 service_version 完全一致，可直接判定“兼容”（快速兼容判定（不与“快车道”概念混淆）），无需展开逐包判断。
  - 若二者不一致，则进入“逐包兼容性检查”（由信令服务器集中执行并缓存），以 package 粒度严格判断 BackwardCompatible/Breaking。
- 注意：service_version 仅在“完全相同”时可直接作为兼容性判定；不相同时绝不能用它做近似判定，必须逐包展开。

*   **使用场景**:
    *   **服务注册**: Actor 启动时，SDK 读取其内嵌的“服务指纹”，并连同其 `type`（如 `order-service`）一起注册到信令服务器。
    *   **服务发现**: 当一个消费者需要调用 `order-service` 时，它的 `actr.lock.toml` 文件中已经记录了它所依赖的 `order-service` 的精确协议签名。消费者向信令服务器发起请求：“请给我一个 `type` 为 `order-service` 且服务指纹为 `sha256-abcde...` 的可用实例”。
    *   **精确匹配**: 信令服务器只返回完全匹配该指纹的服务实例，从而在连接建立之前就保证了双方的协议兼容性。

---

## 2. 服务版本共存与负载均衡

在真实的生产环境中，同一个 Actor 类型往往需要多个版本共存，以支持渐进式升级和灰度发布。

### **2.1. 多版本服务共存**

`actr` 框架原生支持同一服务类型的多个版本在网络中并存：

```
网络中的 user-service 实例：
┌─────────────────┬──────────────┬─────────────────────────────────┐
│ 实例ID          │ 版本         │ 服务指纹                        │
├─────────────────┼──────────────┼─────────────────────────────────┤
│ user-service-01 │ v1.0.0       │ sha256:a1b2c3d4...             │
│ user-service-02 │ v1.0.0       │ sha256:a1b2c3d4...             │
│ user-service-03 │ v1.1.0       │ sha256:b2c3d4e5...             │
│ user-service-04 │ v2.0.0       │ sha256:c3d4e5f6...             │
└─────────────────┴──────────────┴─────────────────────────────────┘
```

这种设计允许：
- **灰度发布**：新版本逐步替换旧版本
- **A/B测试**：不同版本并行服务不同用户群体
- **回滚能力**：快速回退到稳定版本

### **2.2. 智能负载均衡策略**

当存在多个匹配的服务实例时，`actr` 采用以下优先级策略：

1. **精确匹配优先**：完全匹配指纹的实例具有最高优先级
2. **版本新旧排序**：在兼容版本中，优先选择较新版本
3. **负载均衡次之**：在同等优先级实例间进行负载分布

```rust
// 负载均衡决策伪代码
fn select_service_instance(requested_fingerprint: &str, available_instances: &[ServiceInstance]) -> ServiceInstance {
    // 1. 寻找精确匹配
    if let Some(exact) = find_exact_match(requested_fingerprint, available_instances) {
        return load_balance_among(exact);
    }
    
    // 2. 寻找兼容匹配，按版本排序
    let compatible = find_compatible_instances(requested_fingerprint, available_instances)
        .sort_by_version_desc(); // 新版本优先
    
    if !compatible.is_empty() {
        return load_balance_among(compatible);
    }
    
    // 3. 无可用实例
    return Err(NoCompatibleInstance);
}
```

---

## 3. 运行时兼容性协商

这个机制解决了当消费者 Actor 启动时，在网络中找不到其 `actr.lock.toml` 中记录的、指纹完全匹配的提供者 Actor 这一关键问题。它为系统提供了面对版本演进时的韧性。

## 3. 运行时兼容性协商

这个机制解决了当消费者 Actor 启动时，在网络中找不到其 `actr.lock.toml` 中记录的、指纹完全匹配的提供者 Actor 这一关键问题。它为系统提供了面对版本演进时的韧性。

#### **协商工作流**

当一个消费者 Actor (我们称之为 `A`) 需要连接一个 `type` 为 `user-service` 的提供者 Actor 时，其 SDK 内部将执行以下协商流程：

1.  **第一步：理想路径 (Exact Match)**
    *   Actor `A` 从其 `actr.lock.toml` 中读取到它所依赖的 `user-service` 的精确**服务指纹** (例如 `fingerprint_ideal`)。
    *   它向信令服务器发起请求：“我需要一个 `type` 为 `user-service` 且服务指纹为 `fingerprint_ideal` 的实例”。
    *   **如果找到**，则连接成功，流程结束。

2.  **第二步：触发协商 (Match Failure)**
    *   信令服务器回复：“找不到完全匹配 `fingerprint_ideal` 的实例”。
    *   此时，Actor `A` **不会立即失败**，而是进入兼容性协商模式。

3.  **第三步：请求兼容性检查 (Offload to Server)**
    *   Actor `A` 向信令服务器发起第二次请求：“请为我寻找一个 `type` 为 `user-service` 且**向后兼容**于 `fingerprint_ideal` 的服务实例。”

4.  **第四步：信令服务器执行兼容性检查 (Centralized Computation)**
    *   **信令服务器**接收到请求后，负责执行兼容性检查的计算过程。
    *   它首先查找自己的**全局兼容性缓存**，看 `(fingerprint_ideal, a_candidate_fingerprint)` 的组合是否已有检查结果。
    *   如果缓存未命中，信令服务器（它必须能访问所有已注册服务的 `.proto` 定义）会使用内嵌的 `proto-sign` 库，在**服务端**对所有可用的 `user-service` 版本进行向后兼容性分析。
    *   检查结果（无论是兼容或不兼容）都会被存入全局缓存，以服务于后续来自其他客户端的相同请求。

    > [!NOTE]
    > **应对“惊群效应” (Thundering Herd)
    > **
    > 将兼容性计算集中在信令服务器，是为了利用服务端缓存来避免大量客户端重复进行相同的计算。然而，当一个核心服务更新后，大量客户端同时重启仍可能在短时间内发起海量的、针对新版本组合的兼容性检查请求。因此，信令服务器的实现**必须**包含**缓存（caching）**和**请求节流（throttling/request coalescing）**机制，以防止在部署和恢复期间被密集的协商请求压垮。

5.  **第五步：决策与执行**

    *   **情况 A：协商成功**
        1.  信令服务器找到了第一个**兼容**的备选版本（例如 `fingerprint_v2`），并将对应的可用实例地址返回给 Actor `A`。
        2.  Actor `A` 与该版本的服务实例建立连接。
        3.  **系统状态转换**：从“启动阶段”进入“亚健康运行”状态。
        4.  SDK 在本地创建/更新 `compat.lock.toml` 文件，记录这次成功的协商，以便下次快速启动：
            ```toml
            # compat.lock.toml - 兼容性协商缓存
            # This file indicates the system is in SUB-HEALTHY state.
            # Consider running 'actr install' to update dependencies.
            
            [[negotiation]]
            service_name = "user-service"
            requested_fingerprint = "sha256:a1b2c3d4e5f6789..."
            resolved_fingerprint = "sha256:b2c3d4e5f6789a1..."
            compatibility_check = "backward_compatible"
            negotiated_at = "2025-09-16T15:45:30Z"
            expires_at = "2025-09-17T15:45:30Z"  # 24小时缓存
            ```
        5.  运行时状态监控将发出警告：
            > **`WARN: 🟡 SYSTEM SUB-HEALTHY: Service 'user-service' using compatible fingerprint (sha256:b2c3...) instead of exact match (sha256:a1b2...). Run 'actr install' to restore health.`**

    *   **情况 B：协商失败**
        1.  信令服务器检查了所有可用的备选版本，没有发现任何一个是兼容的。
        2.  信令服务器向 Actor `A` 返回“无兼容实例”的错误。
        3.  **系统状态转换**：Actor `A` 启动失败，直接进入“失败退出”状态。
        4.  在日志中打印错误并终止：
            > **`ERROR: 🔴 SYSTEM FAILED: No compatible fingerprint found for service 'user-service' (requested: sha256:a1b2...). Available fingerprints incompatible.`**

### **系统健康状态机**

```
┌─────────────┐    精确匹配    ┌─────────────┐    依赖更新    ┌─────────────┐
│  启动阶段   │──────────────→│  健康运行   │──────────────→│  正常结束   │
│  Starting   │                │  Healthy    │                │  Shutdown   │
└─────────────┘                └─────────────┘                └─────────────┘
       │                              │                               ↑
       │ 兼容匹配                      │ 服务下线/升级                   │
       ↓                              ↓                               │
┌─────────────┐    服务恢复    ┌─────────────┐                        │
│  亚健康运行  │──────────────→│  健康运行   │────────────────────────┘
│ Sub-Healthy │                │  Healthy    │
└─────────────┘                └─────────────┘
       │
       │ 依赖更新/修复
       └────────────────────────────────────────────────────────────┘
```

**状态说明**：
- **健康运行**：所有依赖精确匹配，性能最优，无警告
- **亚健康运行**：存在兼容匹配，功能正常但需要关注
- **失败退出**：无法找到兼容依赖，服务无法启动

---

## 4. 兼容性缓存与全局优化

### **4.1. 本地兼容性缓存 (`compat.lock.toml`)**

`compat.lock.toml` 文件是运行时协商机制的关键产物，具有多重作用：

1. **系统健康指示器**：文件存在表示系统处于亚健康状态
2. **协商结果缓存**：避免重复进行昂贵的兼容性检查
3. **审计追踪**：记录所有兼容性协商的历史和原因
4. **快速启动**：后续启动时优先尝试已知兼容版本

#### **缓存生命周期管理**
```rust
impl CompatibilityCache {
    fn is_expired(&self, negotiation: &Negotiation) -> bool {
        negotiation.expires_at < Utc::now()
    }
    
    fn should_revalidate(&self, negotiation: &Negotiation) -> bool {
        // 24小时后重新验证兼容性
        self.is_expired(negotiation) || 
        // 或者发现更新的服务版本
        self.has_newer_service_version(&negotiation.service_name)
    }
}
```

### **4.2. 全局兼容性缓存**

信令服务器维护一个**全局兼容性知识库**，将所有客户端的兼容性检查结果进行汇聚和共享：

#### **全局缓存优势**
- **避免重复计算**：相同的版本组合兼容性只需计算一次
- **加速网络发现**：新加入的Actor可以直接受益于历史检查结果
- **集体智慧**：所有参与者共同构建兼容性知识图谱

#### **缓存共享机制**
```rust
// 兼容性结果上报
struct CompatibilityReport {
    from_fingerprint: String,
    to_fingerprint: String,
    service_type: String,
    compatibility_result: CompatibilityResult,
    checked_at: DateTime<Utc>,
    checked_by: ActrId,
}

// 全局缓存查询
struct CompatibilityQuery {
    from_fingerprint: String,
    to_fingerprint: String,
    service_type: String,
}
```

**注意**：`compat.lock.toml` 文件**不应该**被提交到版本控制中，因为它反映的是特定环境在特定时间点的运行时状态。

---

## 5. 总结：智能化的服务版本管理

`actr` 框架的服务版本兼容性系统提供了一套完整的解决方案，完美平衡了以下几个关键要素：

### **5.1. 核心设计原则**

1. **契约精神优先**：通过基于语义指纹的组合哈希确保服务契约的精确性和不可篡改性
2. **渐进式容错**：支持多版本共存，允许灰度升级和向后兼容
3. **集体智慧**：通过全局兼容性缓存，让整个网络受益于集体的兼容性验证
4. **健康状态透明**：通过清晰的状态机和警告系统，让运维人员了解系统健康状况

### **5.2. 技术创新点**

- **服务级别依赖管理**：从单文件proto依赖升级到完整的服务依赖
- **智能负载均衡**：版本优先 + 负载均衡的混合策略
- **proto-sign集成**：利用成熟的proto兼容性检查库确保检查准确性
- **运行时协商**：失败时触发，避免不必要的性能开销
- **双层缓存机制**：本地缓存 + 全局共享，最大化效率

### **5.3. 实际价值**

这套机制让 `actr` 生态系统在面对真实世界的复杂性时，能够：

- **保证服务稳定性**：精确匹配确保最佳性能和兼容性
- **支持业务敏捷性**：兼容匹配允许快速迭代和灰度发布  
- **降低运维复杂性**：自动化的协商和缓存减少人工干预
- **提供可观测性**：清晰的健康状态和日志帮助问题诊断
- **促进生态健康**：主动提醒更新，防止技术债累积

通过 `compat.lock.toml` 的存在与否，开发者可以一目了然地判断系统是否处于最佳状态，从而采取相应的维护措施。这种设计不仅解决了微服务架构中版本管理的痛点，更为整个分布式系统的健康运行提供了强有力的保障。
