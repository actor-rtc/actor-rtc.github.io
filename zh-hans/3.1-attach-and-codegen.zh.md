# **ä¸“é¢˜è§£æï¼šä» .proto åˆ°è¿è¡Œæ—¶ â€” ä»£ç ç”Ÿæˆä¸ attach æœºåˆ¶è¯¦è§£**

å¼€å‘è€…ä½¿ç”¨ actr æ¡†æ¶çš„æ ¸å¿ƒä½“éªŒæµ“ç¼©äºä¸€è¡Œä»£ç ï¼š

```rust
// main.rs
let my_service = MyEchoService::default();

ActrSystem::new(config)?
    .attach(my_service)  // ğŸ¯ å¹³è¡Œç»„åˆ
    .start()
    .await?;
```

è¿™è¡Œç®€å•çš„ `.attach(workload)` è°ƒç”¨èƒŒåï¼Œéšè—ç€æ•´ä¸ªæ¡†æ¶æœ€ç²¾å¦™çš„è®¾è®¡ï¼š**åŸºäº Protobuf å¥‘çº¦çš„è§’è‰²é©±åŠ¨ä»£ç ç”Ÿæˆï¼Œä»¥åŠå¹³è¡Œç»„åˆçš„è¿è¡Œæ—¶æ¶æ„**ã€‚

---

## 1. æ ¸å¿ƒç†å¿µï¼šå¹³è¡Œç»„åˆè€ŒéåŒ…å«

### 1.1 æ¶æ„ç­‰å¼

```
ActrNode = ActrSystem + Workload
```

è¿™ä¸æ˜¯"å®¹å™¨åŒ…å«å†…å®¹"çš„å…³ç³»ï¼Œè€Œæ˜¯**ä¸¤ä¸ªå¹³è¡Œç»„ä»¶çš„ç»„åˆ**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ActrSystem     â”‚          â”‚    Workload      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚          â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  è¿è¡Œæ—¶åŸºç¡€è®¾æ–½   â”‚          â”‚  ä¸šåŠ¡é€»è¾‘å•å…ƒ     â”‚
â”‚                  â”‚          â”‚                  â”‚
â”‚  â€¢ Scheduler     â”‚          â”‚  â€¢ Handler æ–¹æ³•  â”‚
â”‚  â€¢ Mailbox       â”‚          â”‚  â€¢ ä¸šåŠ¡çŠ¶æ€      â”‚
â”‚  â€¢ Registry      â”‚          â”‚  â€¢ å¤„ç†é€»è¾‘      â”‚
â”‚  â€¢ Network       â”‚          â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                            â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ attach â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚      ActrNode           â”‚
         â”‚  å®Œæ•´çš„è¿è¡Œæ—¶èŠ‚ç‚¹        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ç‰¹æ€§**ï¼š
- **ActrSystem** ä¸ç›´æ¥å­˜å‚¨ Workloadï¼›attach ä¹‹åç”± **ActrNode<W>** ä»¥ `Arc<W>` æŒæœ‰
- **HandlerRegistry** å­˜å‚¨æŒ‡å‘ Workload çš„ Arc å¼•ç”¨
- **attach** æ“ä½œå»ºç«‹è¿æ¥ï¼Œå®Œæˆç»„è£…

---

## 2. è§’è‰²é©±åŠ¨çš„ä»£ç ç”Ÿæˆ

`actr gen` å‘½ä»¤æ ¹æ® `exports` ä¸­çš„ `.proto` å®šä¹‰ç”Ÿæˆä»£ç ã€‚æ„å»ºæ—¶é¦–å…ˆä½¿ç”¨ `proto-regulate` æŒ‰ package åˆå¹¶ä¸è§„èŒƒåŒ–ï¼Œç„¶åä»¥ package ä¸ºå•ä½ç”Ÿæˆè¯­ä¹‰æŒ‡çº¹ä¸ä»£ç äº§ç‰©ï¼Œæ–‡ä»¶æ‹†åˆ†æ–¹å¼ä¸å½±å“ç»“æœã€‚

### 2.1 ä¸º `exports` ç”ŸæˆæœåŠ¡ç«¯ä»£ç 

**é…ç½®ç¤ºä¾‹ï¼š**
```toml
# Actr.toml
[package]
name = "echo-service"

[package.actr_type]
manufacturer = "acme"
name = "EchoService"

exports = ["proto/echo.v1.proto"]
```

**proto å®šä¹‰ï¼š**
```protobuf
// proto/echo.v1.proto
syntax = "proto3";
package echo.v1;

message EchoRequest {
  string text = 1;
}

message EchoResponse {
  string text = 1;
  int64 timestamp = 2;
}

service EchoService {
  rpc SendEcho(EchoRequest) returns (EchoResponse);
  rpc BatchEcho(BatchRequest) returns (BatchResponse);
}
```

**ç”Ÿæˆçš„ä»£ç ï¼ˆ5 ä¸ªæ ¸å¿ƒç»„ä»¶ï¼‰ï¼š**

```rust
// src/generated/echo.v1.rs

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1ï¸âƒ£ RpcRequest trait å®ç°ï¼ˆç±»å‹å…³è”ï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
impl RpcRequest for EchoRequest {
    type Response = EchoResponse;
    fn route_key() -> &'static str {
        "echo.v1.EchoService.SendEcho"
    }
}

impl RpcRequest for BatchRequest {
    type Response = BatchResponse;
    fn route_key() -> &'static str {
        "echo.v1.EchoService.BatchEcho"
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2ï¸âƒ£ æœåŠ¡ç«¯ Handler traitï¼ˆç”¨æˆ·å®ç°ï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub trait EchoServiceHandler: Send + Sync + 'static {
    async fn send_echo(
        &self,
        request: EchoRequest,
        ctx: &Context,
    ) -> ActorResult<EchoResponse>;

    async fn batch_echo(
        &self,
        request: BatchRequest,
        ctx: &Context,
    ) -> ActorResult<BatchResponse>;
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 3ï¸âƒ£ MessageDispatcher å®ç°ï¼ˆæ¶ˆæ¯åˆ†å‘å™¨ï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub struct EchoServiceDispatcher<T: EchoServiceHandler>(PhantomData<T>);

#[async_trait]
impl<T: EchoServiceHandler> MessageDispatcher for EchoServiceDispatcher<T> {
    type Workload = EchoServiceWorkload<T>;

    async fn dispatch<C: Context>(
        workload: &Self::Workload,
        envelope: RpcEnvelope,
        ctx: &C,
    ) -> ActorResult<Bytes> {
        match envelope.route_key.as_str() {
            "echo.v1.EchoService.SendEcho" => {
                let req = EchoRequest::decode(&*envelope.payload)?;
                let resp = workload.0.send_echo(req, ctx).await?;
                Ok(resp.encode_to_vec().into())
            }
            "echo.v1.EchoService.BatchEcho" => {
                let req = BatchRequest::decode(&*envelope.payload)?;
                let resp = workload.0.batch_echo(req, ctx).await?;
                Ok(resp.encode_to_vec().into())
            }
            _ => Err(ActrError::UnknownRoute {
                route_key: envelope.route_key.to_string()
            }.into())
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 4ï¸âƒ£ Workload åŒ…è£…ç±»å‹
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub struct EchoServiceWorkload<T: EchoServiceHandler>(pub T);

impl<T: EchoServiceHandler> EchoServiceWorkload<T> {
    pub fn new(handler: T) -> Self {
        Self(handler)
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 5ï¸âƒ£ Workload trait å®ç°
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
impl<T: EchoServiceHandler> Workload for EchoServiceWorkload<T> {
    type Dispatcher = EchoServiceDispatcher<T>;
}
```

### 2.2 ä¸º `dependencies` ç”Ÿæˆå®¢æˆ·ç«¯ä»£ç 

**é…ç½®ç¤ºä¾‹ï¼š**
```toml
[dependencies]
user_api = { actr_type = "acme+user-service" }
payment_api = { actr_type = "acme+payment-service" }
```

**ç”Ÿæˆçš„ Context æ‰©å±•ï¼š**
```rust
// src/generated/user_api_client.rs

pub struct UserApiClient {
    context: Context,
}

impl UserApiClient {
    pub async fn get_profile(
        &self,
        request: GetProfileRequest,
    ) -> ActorResult<GetProfileResponse> {
        self.context.call_service::<GetProfileRequest>(
            "acme+user-service",
            request,
        ).await
    }
}

// Context æ‰©å±•æ–¹æ³•
impl Context {
    pub fn user_api(&self) -> UserApiClient {
        UserApiClient {
            context: self.clone(),
        }
    }
}
```

---

## 3. attach æœºåˆ¶ï¼šå¹³è¡Œç»„åˆçš„å®ç°

### 3.1 attach çš„è¯­ä¹‰

```rust
impl ActrSystem {
    pub fn attach<W: Workload>(mut self, workload: W) -> Self {
        // 1. åŒ…è£…ä¸º Workload
        let workload = workload;

        // 2. å­˜å‚¨ Workload å®ä¾‹å’Œå…³è”çš„ Dispatcher ç±»å‹
        // ActrSystem å†…éƒ¨ç»´æŠ¤ Workload å®ä¾‹
        // Dispatcher é€šè¿‡å…³è”ç±»å‹ W::Dispatcher ç¡®å®š

        // 3. è¿”å›å·²ç»„è£…çš„ ActrSystem
        self
    }
}
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š
- âœ… **é™æ€æ´¾å‘** - `W::Dispatcher` æ˜¯å…³è”ç±»å‹ï¼Œç¼–è¯‘æ—¶ç¡®å®š
- âœ… **é›¶å¤§å°ç±»å‹** - `MessageDispatcher` æ˜¯ ZSTï¼Œä¸å ç”¨å†…å­˜
- âœ… **å¹³è¡Œç»„åˆ** - Workload ç”± ActrSystem æŒæœ‰ï¼ˆArc<W>ï¼‰
- âœ… **æ³›å‹ç‰¹åŒ–** - ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰ç±»å‹ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€

### 3.2 ç»„è£…æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant User as å¼€å‘è€…
    participant AS as ActrSystem
    participant WR as WorkloadRouting
    participant HR as HandlerRegistry

    User->>AS: .attach(my_service)
    Note over AS: åˆ›å»º Arc<MyEchoService>

    AS->>WR: configure(workload, registry)
    Note over WR: é™æ€æ–¹æ³•è°ƒç”¨

    WR->>HR: register<EchoRequest>(workload)
    Note over HR: å­˜å‚¨ TypeId â†’ Handler æ˜ å°„

    WR->>HR: register<BatchRequest>(workload)
    Note over HR: å­˜å‚¨æ›´å¤šæ˜ å°„

    HR-->>AS: æ³¨å†Œå®Œæˆ
    AS-->>User: ActrSystem (å·²ç»„è£…)

    Note over AS,HR: å®Œæˆå¹³è¡Œç»„åˆ<br/>ActrSystem + Workload â†’ ActrNode
```

### 3.3 HandlerRegistry çš„å·¥ä½œåŸç†

```rust
pub struct HandlerRegistry {
    handlers: DashMap<TypeId, Box<dyn HandlerWrapper>>,
}

impl HandlerRegistry {
    pub fn register<M, T>(&mut self, workload: Arc<T>)
    where
        M: Message,
        T: MessageHandler<M>,
    {
        let type_id = TypeId::of::<M>();

        // å­˜å‚¨ç±»å‹å®‰å…¨çš„å¤„ç†å™¨
        self.handlers.insert(
            type_id,
            Box::new(TypedHandler::<M, T> {
                workload,
                _phantom: PhantomData,
            }),
        );
    }
}

// ç±»å‹å®‰å…¨çš„åŒ…è£…å™¨
struct TypedHandler<M: Message, T: MessageHandler<M>> {
    workload: Arc<T>,
    _phantom: PhantomData<M>,
}

impl<M: Message, T: MessageHandler<M>> HandlerWrapper for TypedHandler<M, T> {
    async fn handle(&self, bytes: Vec<u8>, ctx: &Context)
        -> ActorResult<Vec<u8>>
    {
        // 1. ååºåˆ—åŒ–ï¼ˆç¼–è¯‘æ—¶ç¡®å®šç±»å‹ï¼‰
        let msg = M::decode(&bytes[..])?;

        // 2. è°ƒç”¨ç»Ÿä¸€çš„ handle æ–¹æ³•ï¼ˆMessageHandler<M> traitï¼‰
        let response = self.workload.handle(msg, ctx).await?;

        // 3. åºåˆ—åŒ–ï¼ˆç¼–è¯‘æ—¶ç¡®å®šç±»å‹ï¼‰
        Ok(response.encode_to_vec())
    }
}
```

---

## 4. å››ä¸ª Trait çš„åä½œå…³ç³»

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦ 4 ä¸ª Traitï¼Ÿ

| Trait | ä½œç”¨ | ä¸å¯æ›¿ä»£çš„ç†ç”± |
|-------|------|----------------|
| **RpcRequest** | å»ºç«‹"è¯·æ±‚-å“åº”"çš„ç±»å‹å…³è” | ç¼–è¯‘æ—¶ç¡®å®šè¿”å›ç±»å‹å’Œè·¯ç”±é”®ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ |
| **MessageDispatcher** | ç»Ÿä¸€çš„æ¶ˆæ¯åˆ†å‘æ¥å£ | æ ¹æ® route_key åˆ†å‘åˆ°å¯¹åº”çš„ handler æ–¹æ³• |
| **Workload** | å·¥ä½œå•å…ƒèº«ä»½ + å…³è” Dispatcher | ç»‘å®š Dispatcherï¼Œå¹¶æä¾›ç”Ÿå‘½å‘¨æœŸé’©å­ |
| **{Service}Handler** | æœåŠ¡ç«¯ä¸šåŠ¡é€»è¾‘æ¥å£ï¼ˆç”¨æˆ·å®ç°ï¼‰ | å®šä¹‰å…·ä½“çš„ä¸šåŠ¡å¤„ç†æ–¹æ³•ï¼Œæ¸…æ™°çš„èŒè´£åˆ†ç¦» |

### 4.2 åä½œæµç¨‹

```
ç¼–è¯‘æ—¶ï¼š
  .proto æ–‡ä»¶
    â†“ (ä»£ç ç”Ÿæˆ)
  ç”Ÿæˆ RpcRequest å®ç° + Handler trait + Dispatcher + Workload
    â†“
  ç”¨æˆ·å®ç° EchoServiceHandler
    â†“ (åŒ…è£…)
  EchoServiceWorkload<T> è‡ªåŠ¨è·å¾— Workload trait

è¿è¡Œæ—¶ï¼š
  ActrSystem.attach(EchoServiceWorkload::new(handler))
    â†“
  å­˜å‚¨ Workload å®ä¾‹å’Œå…³è”çš„ Dispatcher
    â†“
  æ¶ˆæ¯åˆ°è¾¾ï¼ˆRpcEnvelopeï¼‰
    â†“
  Dispatcher::dispatch() æ ¹æ® route_key åŒ¹é…
    â†“
  ååºåˆ—åŒ– â†’ è°ƒç”¨ handler æ–¹æ³• â†’ åºåˆ—åŒ–è¿”å›
```

---

## 5. å¼€å‘è€…å®ç°ç¤ºä¾‹

### 5.1 å®ç°ä¸šåŠ¡é€»è¾‘

```rust
// src/main.rs
use crate::generated::*;

pub struct MyEchoService {
    counter: AtomicU64,
}

// ç”¨æˆ·åªéœ€å®ç°è¿™ä¸ª trait
impl EchoServiceHandler for MyEchoService {
    async fn send_echo(
        &self,
        request: EchoRequest,
        ctx: &Context,
    ) -> ActorResult<EchoResponse> {
        // ä¸šåŠ¡é€»è¾‘
        let count = self.counter.fetch_add(1, Ordering::SeqCst);

        // å¯ä»¥è°ƒç”¨å…¶ä»–æœåŠ¡
        if request.text.contains("user") {
            let profile = ctx.user_api()
                .get_profile(GetProfileRequest { ... })
                .await?;
        }

        Ok(EchoResponse {
            text: format!("Echo #{}: {}", count, request.text),
            timestamp: chrono::Utc::now().timestamp(),
        })
    }

    async fn batch_echo(
        &self,
        request: BatchRequest,
        ctx: &Context,
    ) -> ActorResult<BatchResponse> {
        // æ‰¹é‡å¤„ç†é€»è¾‘
        let responses = request.items
            .into_iter()
            .map(|text| format!("Echo: {}", text))
            .collect();

        Ok(BatchResponse { items: responses })
    }
}
```

**è‡ªåŠ¨è·å¾—çš„èƒ½åŠ›**ï¼š

å®ç° `EchoServiceHandler` åï¼Œ`MyEchoService` é€šè¿‡ `EchoServiceWorkload` åŒ…è£…è‡ªåŠ¨è·å¾—ï¼š
- âœ… `Workload` trait å®ç°ï¼ˆé€šè¿‡ `EchoServiceWorkload<T>`ï¼‰
- âœ… å…³è”çš„ `EchoServiceDispatcher` åˆ†å‘å™¨
- âœ… å®Œæ•´çš„æ¶ˆæ¯è·¯ç”±å’Œåˆ†å‘èƒ½åŠ›
- âœ… ç±»å‹å®‰å…¨çš„ RPC è°ƒç”¨æ”¯æŒ

### 5.2 å¯åŠ¨ç³»ç»Ÿ

```rust
#[tokio::main]
async fn main() -> ActorResult<()> {
    // 1. åˆ›å»ºåŸºç¡€è®¾æ–½
    let actor_system = ActrSystem::new(config)?;

    // 2. åˆ›å»ºä¸šåŠ¡é€»è¾‘
    let my_service = MyEchoService {
        counter: AtomicU64::new(0),
    };

    // 3. å¹³è¡Œç»„åˆï¼šActrSystem + Workload = ActrNode
    let running_system = actor_system
        .attach(EchoServiceWorkload::new(my_service))  // ğŸ¯ ç»„è£…
        .start()
        .await?;

    running_system.wait_for_shutdown().await
}
```

---

## 6. æœåŠ¡è°ƒç”¨æ¨¡å¼ï¼šä»£ç ä¸­æ˜¾å¼é€‰æ‹©

### 6.1 æ–°æ¨¡å¼çš„ä¼˜åŠ¿

å¼€å‘è€…åœ¨ä»£ç ä¸­å®Œå…¨æ§åˆ¶æœåŠ¡è°ƒç”¨çš„å†³ç­–ã€‚

**é…ç½®ç¤ºä¾‹ï¼š**
```toml
[dependencies]
user_v2 = { actr_type = "acme+user-service" }
user_v1_legacy = { actr_type = "acme+user-service", fingerprint = "service_semantic:abc123..." }
```

**ä»£ç ä¸­é€‰æ‹©ï¼š**
```rust
async fn some_logic(&self, ctx: &Context) -> ActorResult<()> {
    if feature_flags::is_v2_enabled() {
        // è°ƒç”¨ v2 ç‰ˆæœ¬
        let profile = ctx.user_v2()
            .get_profile(req)
            .await?;
    } else {
        // å›é€€åˆ° v1
        let profile = ctx.user_v1_legacy()
            .get_profile(req)
            .await?;
    }

    Ok(())
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… **è·¯ç”±é€»è¾‘æ˜¾å¼åŒ–** - è°ƒç”¨ç›®æ ‡åœ¨ä»£ç ä¸­ä¸€ç›®äº†ç„¶
- âœ… **çµæ´»æ€§é«˜** - å¯ç»“åˆåŠŸèƒ½å¼€å…³ã€A/B æµ‹è¯•ç­‰
- âœ… **æ˜“äºæµ‹è¯•** - å¯ä»¥é’ˆå¯¹ä¸åŒè·¯ç”±åˆ†æ”¯ç¼–å†™å•å…ƒæµ‹è¯•
- âœ… **ç±»å‹å®‰å…¨** - ç¼–è¯‘æ—¶éªŒè¯æ‰€æœ‰è°ƒç”¨

---

## 7. è®¾è®¡åŸåˆ™æ€»ç»“

### 7.1 å¹³è¡Œç»„åˆåŸåˆ™

```
ä¸æ˜¯åŒ…å«å…³ç³»ï¼š                  è€Œæ˜¯ç»„åˆå…³ç³»ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ActrSystem    â”‚             â”‚ ActrSystem  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚             â”‚ (åŸºç¡€è®¾æ–½)   â”‚
â”‚ â”‚  Workload  â”‚ â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                    +
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     âŒ é”™è¯¯                    â”‚  Workload    â”‚
                               â”‚ (ä¸šåŠ¡é€»è¾‘)   â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â•‘
                                      â–¼
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚  ActrNode    â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  âœ… æ­£ç¡®
```

### 7.2 é›¶æˆæœ¬æŠ½è±¡åŸåˆ™

| å¯¹æ¯”é¡¹ | ä¼ ç»Ÿ RPC | actr |
|--------|---------|------|
| æ¶ˆæ¯ç±»å‹æŸ¥æ‰¾ | HashMap (~50ns) | ç¼–è¯‘æ—¶ç¡®å®š (0ns) |
| ç±»å‹æ£€æŸ¥ | `Any::downcast` | ç¼–è¯‘æ—¶æ³›å‹ |
| å†…å­˜åˆ†é… | `Box<dyn Any>` | æ ˆä¸Šåˆ†é… |
| å‡½æ•°è°ƒç”¨ | è™šå‡½æ•°è¡¨ | ç›´æ¥è°ƒç”¨ |

### 7.3 èŒè´£æ¸…æ™°åŸåˆ™

- **exports** â†’ ç”ŸæˆæœåŠ¡ç«¯ traitï¼ˆç­‰å¾…å¼€å‘è€…å®ç°ï¼‰
- **dependencies** â†’ ç”Ÿæˆå®¢æˆ·ç«¯ä»£ç ï¼ˆç›´æ¥ä½¿ç”¨ï¼‰
- **ActrSystem** â†’ æä¾›åŸºç¡€è®¾æ–½ï¼ˆè¿è¡Œæ—¶ï¼‰
- **Workload** â†’ å®ç°ä¸šåŠ¡é€»è¾‘ï¼ˆå¼€å‘è€…ä»£ç ï¼‰
- **attach** â†’ å®Œæˆå¹³è¡Œç»„åˆï¼ˆç»„è£…æ“ä½œï¼‰

---

## 8. å®Œæ•´è°ƒç”¨é“¾è·¯

```
1. å®¢æˆ·ç«¯å‘èµ·è°ƒç”¨
   ctx.user_api().get_profile(req).await

2. Context å¤„ç†
   - æœåŠ¡å‘ç°ï¼ˆæ ¹æ® actr_typeï¼‰
   - è¿æ¥ç®¡ç†ï¼ˆWebRTCï¼‰
   - åºåˆ—åŒ–ï¼ˆProtobufï¼‰

3. ç½‘ç»œä¼ è¾“
   - WebRTC Data Channel
   - å¯é æœ‰åºä¼ è¾“

4. æœåŠ¡ç«¯æ¥æ”¶
   ActrSystem.handle_incoming_message(bytes)

5. æŸ¥æ‰¾å¤„ç†å™¨
   registry.get(TypeId::of::<GetProfileRequest>())
   â†’ TypedHandler<GetProfileRequest, UserService>

6. ååºåˆ—åŒ– + è°ƒç”¨
   handler.handle(bytes, ctx)
   â†’ GetProfileRequest::decode(bytes)
   â†’ workload.get_profile(msg, ctx)

7. ä¸šåŠ¡å¤„ç†
   UserService.get_profile(msg, ctx)

8. åºåˆ—åŒ– + è¿”å›
   response.encode_to_vec()
   â†’ ç½‘ç»œè¿”å›ç»™å®¢æˆ·ç«¯
```

---

## 9. æ€»ç»“

actr çš„ attach æœºåˆ¶ä½“ç°äº†ç°ä»£ Rust æ¡†æ¶è®¾è®¡çš„æœ€é«˜æ°´å‡†ï¼š

1. **å¹³è¡Œç»„åˆ** - ActrNode = ActrSystem + Workloadï¼Œæ¸…æ™°çš„æ¶æ„ç­‰å¼
2. **é›¶æˆæœ¬æŠ½è±¡** - ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰ç±»å‹ï¼Œè¿è¡Œæ—¶é›¶å¼€é”€
3. **èŒè´£æ¸…æ™°** - 4 ä¸ª trait å„å¸å…¶èŒï¼Œè¯­ä¹‰æ˜ç¡®
4. **ä»£ç ç”Ÿæˆ** - è‡ªåŠ¨åŒ–ç¹çå·¥ä½œï¼Œä¿è¯ç±»å‹å®‰å…¨
5. **å¼€å‘ä½“éªŒ** - æç®€ APIï¼Œå¼ºå¤§åŠŸèƒ½

é€šè¿‡"è§’è‰²é©±åŠ¨çš„ä»£ç ç”Ÿæˆ"å’Œ"å¹³è¡Œç»„åˆçš„è¿è¡Œæ—¶æ¶æ„"ï¼Œæ¡†æ¶åœ¨ä¿æŒç®€æ´æ€§çš„åŒæ—¶ï¼Œå®ç°äº†æ€§èƒ½ã€å®‰å…¨æ€§å’Œæ˜“ç”¨æ€§çš„å®Œç¾å¹³è¡¡ã€‚
