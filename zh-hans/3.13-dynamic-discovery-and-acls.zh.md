# 专题解析：访问控制 (`can_access`) vs. 服务发现 (`can_discover`)（行动型发现 vs 目录可见性）

在 `actr` 的安全与发现模型中，我们严格区分两个核心概念：
1.  **访问控制 (Access Control)**: 决定一个 Actor **能否与**另一个 Actor 建立连接并交互。由 `can_access` 检查来强制执行。
2.  **服务发现 (Service Discovery)**: 决定一个 Actor **能否在**服务目录中被其他 Actor **看到**。由 `can_discover` 检查来控制。

---

## 1. ACL 的双重执行机制 (Dual Enforcement Mechanism)

访问控制是框架的核心安全屏障，它通过一个“纵深防御”的双重执行机制来提供保护。

### 第一道防线：信令服务器的“连接级”控制

这是在尝试建立 Outproc 传输连接（WebRTC/WebSocket）时的入口控制，也是最主要的防线。

*   **机制**: 信令服务器作为“交通警察”，负责控制 Outproc 连接建立前的握手与路由：对于 WebRTC，为 Offer/Answer/ICE；对于 WebSocket，为连接授权与目标路由。
*   **检查点**: 当 Actor A (消费者) 尝试连接 Actor B (提供者) 时，信令服务器会执行 `can_access` 检查。
*   **`can_access` 检查逻辑**:
    1.  **提供方授权**: 检查 B 的 `Actr.toml` -> `[acl]` 规则是否允许 A 的 `ActrType`。
    2.  **消费方意图**: 检查 A 的 `Actr.toml` -> `[dependencies]` 是否声明了对 B 所提供服务的依赖。
    3.  **认证/领域**: 检查 A 和 B 是否属于同一安全域（例如，拥有相同的 `Realm` ID）。
*   **结果**: 只有当三项检查全部通过时，信令服务器才会转发握手信令。否则，连接请求将在第一步就被阻止。

### 第二道防线：`ActrSystem` 的“消息级”控制

这是在 Outproc 传输连接已经建立后的本地最终防护。

每个 `ActrSystem` 的网络层都会检查每一个通过 Outproc 通道到达的入站消息。
*   **检查点**: 在将消息路由到业务逻辑之前，`ActrSystem` 会进行一次本地 ACL 检查。
*   **本地 ACL 检查逻辑**:
    1.  解析消息来源，获取对端 `Actr` 的 `ActrType`。
    2.  使用**自身的 `Actr.toml`** 中的 `[acl]` 规则进行匹配。
*   **结果**: 如果本地 ACL 检查失败，`ActrSystem` 会**丢弃**该消息。这确保了即使第一道防线被绕过，非授权的消息也无法进入业务逻辑层。

---

## 2. 服务发现可见性 (`can_discover`)

这个机制只影响 Actor 是否会出现在由 `actr discovery` 等工具生成的“服务黄页”中。它控制的是**被动发现（目录可见性）**，独立于访问控制与信令的“行动型发现”。信令服务器向客户端推送的在线实例通知（UpEvent）仅包含已通过 can_access 预检的目标，从而实现“发现即授权”的运行时语义。

*   **默认行为**: `can_discover` **默认为 `true`**。在同一个租户内，所有服务默认都是可见的。
*   **配置方式**: 服务提供方可以通过在 `Actr.toml` 中新增的 `[discovery]` 部分来关闭可见性。

```toml
# --- Actr.toml for a "hidden" service ---

[package]
name = "internal-audit-service"
type = { manufacturer = "my-org", name = "internal-audit-service" }

# ... 其他配置 ...

# 新增: 服务发现配置节
[discovery]
# 控制在 `actr discovery` 等工具中的可见性。
# true (默认): 可见。
# false: 隐藏。但仍可通过直接 URI (`actr install`) 进行安装和连接。
visible = false
```

---

## 3. 工具行为的区分

根据以上定义，`actr-cli` 的不同工具将有明确不同的行为：

*   **`actr discovery` (服务发现)**
    *   这是一个“黄页”或“服务浏览器”工具。
    *   它会请求信令服务器返回一个服务列表，信令服务器会**遵循 `[discovery].visible` 标志**，隐藏那些 `visible = false` 的服务。
    *   此工具用于探索网络中可用的、公开可见的服务。

*   **`actr install <actr_type>` (依赖安装)**
    *   这是一个"直接拨号"工具，用户已经明确目标的服务类型（以及必要的指纹限定）。
    *   它**不会**查询服务发现列表，因此**完全忽略 `visible` 标志**。
    *   只要你明确服务的 `actr_type`（必要时附加 `realm`/`fingerprint`），即使它是隐藏的，你也可以在 `Actr.toml` 中声明对它的依赖并成功 `install`。

---

## 4. 总结：`can_access` vs. `can_discover`

| 特性 | `can_access` (访问控制) | `can_discover` (服务发现可见性) |
| :--- | :--- | :--- |
| **目的** | 控制一个 Actor **能否连接并交互** | 控制一个 Actor **能否在服务目录中被看到** |
| **强制性** | **强制**，由信令服务器和本地 ActrSystem 双重执行 | **非强制**，仅影响被动发现工具 |
| **触发点** | 建立连接时 & 接收每个消息时 | 执行 `actr discovery` 等浏览命令时 |
| **配置** | `[acl]`, `[dependencies]`, 认证/租户信息 | `[discovery].visible` |
| **默认值** | **拒绝** (基于 `[acl]` 的 `default="deny"`) | **允许** (`visible = true`) |

这个分层、纵深防御的设计，清晰地分离了“访问权”和“可见性”，使得系统在默认开放、易于发现的同时，通过严格的 `can_access` 双重检查保证了核心的安全性，设计非常清晰且健壮。