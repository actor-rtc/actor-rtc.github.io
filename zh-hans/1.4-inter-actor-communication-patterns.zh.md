# Actor 间通信模式

在 `actr` 框架中，Actor 之间的通信主要有两种模式，它们分别服务于不同的场景：**基于类型的通信**和**基于实例的通信**。理解这两种模式的意图和用法，是进行清晰架构设计的关键。

---

## 1. 模式一：基于类型的通信 (Type-based Communication)

这是最常用、也是最推荐的通信模式，它服务于**编译时**就已知的、稳定的服务依赖关系。

*   **核心思想**: 我的 Actor 只关心“我需要一种 `ActrType` 为 `user-service` 的服务”，而不关心具体是“网络中的哪一个实例”来处理。
*   **实现方式**: 通过在 `Actr.toml` 的 `[dependencies]` 中声明对一个服务**类型**的依赖，并为其指定一个**本地别名**。

    ```toml
    # Actr.toml
    [dependencies]
    # "user_api" 是我们为 "user-service" 这个 ActrType 定义的本地别名
    user_api = { actr_type = "acme:user-service" }
    ```

> [!NOTE]
> 此模式在 API 层面由代码生成器为 `Context` 对象创建的、以**依赖别名**命名的客户端方法（如 `ctx.user_api()`）实现。

#### **工作流**

1.  **编译时**: `actr gen` 命令会根据上述声明，为 `user_api` 这个别名生成一个专属的客户端，并将其挂载到 `Context` 上。这个客户端包含了 `user-service` 所提供的所有方法的类型安全调用，例如 `ctx.user_api().get_profile(...)`。
2.  **运行时**: 当你的 Actor 调用这些生成的方法时，框架在后台会自动解析出需要一个 `ActrType` 为 `user-service` 的服务，并结合 `actr.lock.toml` 中的指纹信息，向信令服务器查询一个匹配的可用实例，然后与该实例建立连接并发起请求。

#### **代码示例**

```rust
// 在 OrderActr 的业务逻辑中
async fn process_order(&self, order: Order, ctx: &Context) -> Result<Receipt, ActorError> {
    // Actor 只需通过别名调用生成的客户端方法，无需知道 user-service 的具体地址
    let user_profile = ctx.user_api().get_profile(GetUserProfileRequest {
        user_id: order.user_id
    }).await?;
    // ...
}
```

*   **适用场景**: 需要稳定依赖的、类似微服务架构的后端服务间通信。

---

## 2. 模式二：基于实例的通信 (Instance-based Communication)

这种模式服务于更动态的、**运行时**才能确定通信目标的场景。

*   **核心思想**: 我的 Actor 通过某种方式（例如，从一个“房间”服务获取了参与者列表）得到了另一个 Actor 确切的、唯一的 `ActrId`，并希望与这个**特定的实例**建立一个临时的、直接的连接。
*   **实现方式**: 通过 `ActrSystem` 句柄的 `connect` 方法，或 `Context` 的 `call/tell` 方法。

> [!NOTE]
> 此模式在 API 层面由 `Context` 对象的“直接寻址”方法（如 `ctx.call(target_id, ...)`）实现，详情请参阅《[3.2 Context 的设计哲学](./3.2-the-context-philosophy.zh.md)》。

#### **工作流**

1.  **获取 ActrId**: 你的 Actor 在运行时，通过业务逻辑获得了一个 `target_actor_id`。
2.  **发起连接/调用**: 你的 Actor 调用 `ctx.call(target_actor_id, request)`。
3.  **建立连接**: `ActrSystem` 会查找是否已存在与 `target_actor_id` 的 P2P 连接。如果没有，则通过信令服务器发起连接协商。连接成功后发送请求。

#### **代码示例**

```rust
// 在一个 P2P 游戏 Actor 的逻辑中
async fn invite_player(&self, target_id: ActrId, ctx: Arc<Context>) -> Result<(), ActorError> {
    // 直接使用运行时获得的 target_id 来发起调用
    ctx.call(target_id, GameInvite { ... }).await?;
    Ok(())
}
```

*   **适用场景**: 动态发现的 P2P 通信、一个服务需要管理多个相同类型的子任务并与其中一个单独通信等场景。

---

## 3. 总结

`actr` 框架通过这两种模式，清晰地区分了两种不同性质的依赖：

| 模式 | 依赖性质 | 发生时间 | 核心机制 | 开发者体验 |
| :--- | :--- | :--- | :--- | :--- |
| **基于类型** | 对服务**类型**的依赖 | 编译时 | `Actr.toml` + `actr-cli` | 通过 `ctx` 调用代码生成的辅助方法 |
| **基于实例** | 对服务**实例**的依赖 | 运行时 | `ctx.call(ActrId, ...)` | 直接向一个具体的 `ActrId` 发送消息 |

**“类型依赖”是基础**，它让你的代码能够理解要交互的对象的“形状”（API 和数据结构）。而“实例依赖”则是在此基础上，提供了与网络中某个具体对象进行动态、点对点交互的能力。在架构设计中，应优先使用“基于类型的通信”来构建稳定的服务拓扑，仅在需要动态 P2P 交互时才使用“基于实例的通信”。
