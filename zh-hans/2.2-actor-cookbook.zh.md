# **Actor 食谱：构建强大服务的实用模式**

本文档是《开发者指南》的进阶篇，它将超越基础 API 的讲解，专注于展示如何利用“宏观 Actor”这一核心架构，构建出健壮、可扩展、可维护的分布式服务。

这里的每一个“模式”，都是在发挥框架的设计优势，将“一个进程一个 Actor”的设计，转化为一种简化复杂系统设计的策略。

---

## **模式一：“服务门面”模式 (Service Façade)**

#### **问题场景**

当应用逻辑变得复杂，需要处理用户、会话、计费等多个不同领域时，如何在一个 Actr 进程内，保持代码的组织性、可读性和高内聚？

#### **核心思想**

将宏观 Actor 视为一个清晰、稳定的**服务入口 (Façade)**。它的职责是接收外部请求，然后将其干净地委托给内部的、按领域划分的、高内聚的业务模块。Actor 本身不实现具体业务逻辑，只做顶层协调。

#### **实现步骤**

1.  **定义内部模块**: 为每个业务领域创建独立的 `struct`。
    ```rust
    // a_module.rs
    pub struct A_Module { /* ... */ }
    impl A_Module {
        pub async fn do_something(&self) { /* ... */ }
    }
    ```

2.  **创建 Façade Actor**: 主 Actor 持有所有模块的实例。
    ```rust
    // application_actor.rs
    struct ApplicationActor {
        module_a: A_Module,
        module_b: B_Module,
    }
    ```

3.  **委托实现服务 Handler Trait**: 在为 `Actor` 实现由 `.proto` 生成的服务 Handler trait 时，方法体只做委托，保持简洁。
    ```rust
    #[async_trait]
    impl AServiceHandler for ApplicationActor {
        async fn handle_a(&self, req: ARequest, _ctx: &Context) -> ActorResult<AResponse> {
            self.module_a.do_something(req).await
        }
    }
    ```

---

## **模式二：“外部资源”模式 (External Resources)**

#### **问题场景**

Actor 需要访问外部资源，如数据库连接池、Redis 客户端或配置管理器。如何安全、高效地管理这些资源的生命周期和共享访问？

#### **核心思想**

通过**依赖注入 (Dependency Injection)**，在应用的“根部”（即 `main.rs`）一次性地创建所有共享资源，然后通过 `Actor` 的构造函数，将其所有权 (`Arc`) 注入 `Actor` 内部。避免使用全局静态变量。

#### **实现步骤**

1.  **在 `main.rs` 中创建资源**:
    ```rust
    // main.rs
    #[tokio::main]
    async fn main() {
        let db_pool = Arc::new(DatabasePool::connect("...").await.unwrap());
        let actor = ApplicationActor::new(db_pool);
        ActrSystem::new(actor_id).attach(workload).start().await?;
    }
    ```

2.  **在 `Actor` 中持有并使用资源**:
    ```rust
    // application_actor.rs
    struct ApplicationActor {
        db: Arc<DatabasePool>,
    }

    impl ApplicationActor {
        pub fn new(db: Arc<DatabasePool>) -> Self {
            Self { db }
        }
    }

    #[async_trait]
    impl UserServiceHandler for ApplicationActor {
        async fn get_user(&self, req: GetUserRequest, _ctx: &Context) -> ActorResult<User> {
            let user = self.db.get_user_by_id(req.user_id).await?;
            Ok(user)
        }
    }
    ```

---

## **模式三：“并发句柄”模式 (Concurrent Handle)**

#### **问题场景**

服务需要在并发的“快车道”上处理高吞吐量的数据，同时又需要安全地与“状态路径”中的核心状态交互。如何实现？

#### **核心思想**

Actor 为每一个快车道任务，创建一个专属的、线程安全的**并发句柄 (Concurrent Handle)**。快车道回调函数捕获的是这个轻量级的句柄，而不是 Actor 自身。句柄将所有需要修改核心状态的操作，都封装成向 Actor 的“状态路径”发送消息 (`tell`) 的异步方法，从而保证了线程安全。

> 更多关于此模式的底层机制，请参阅《[3.10 快车道底层机制](./3.10-fast-path-lifecycle.zh.md)》。

---

## **模式四：“主题发布/订阅”模式 (Topic-based Pub/Sub)**

#### **问题场景**

如何实现一个通用的发布/订阅系统，让客户端可以订阅任意“主题”（如 `stock.price.goog`），并接收发布到该主题的所有消息？

#### **核心思想**

使用一个 Actor 作为消息总线。其核心状态就是一个 `Topic -> Subscribers` 的映射表。`Subscribe` 和 `Publish` 请求都经由“状态路径”串行化处理，以保证订阅列表的线程安全。

---

## **模式五：“分布式会话”模式 (Distributed Session)**

#### **问题场景**

如何管理一个有明确生命周期、有成员列表的、多用户参与的“会话”（如游戏对局、聊天会话）？

#### **核心思想**

这是“服务门面”和“发布/订阅”模式的组合应用。使用一个 Actor 作为“会话”状态的“真相来源”，管理其生命周期和成员列表。其内部的消息广播，则是 Pub/Sub 模式的一个具体应用。

---

## **模式六：“网络状态感知”模式 (Network Awareness)**

#### **问题场景**

应用需要对网络连接状态的变化做出响应。例如，在与信令服务器断开连接时，在界面上显示“正在重连...”，或在连接恢复后，立即同步一次状态。

#### **核心思想**

实现 `Lifecycle` trait 中与网络状态相关的钩子方法。这些方法由 `ActrSystem` 在检测到网络状态变更时自动调用，为 Actor 提供了一个响应网络事件、更新内部状态或与外部交互的入口。

#### **实现步骤**

1.  **实现 `ILifecycle` 钩子**: 在你的 Actor `impl` 块中，实现 `on_signaling_connected` 和 `on_signaling_disconnected` 方法。

    ```rust
    use std::sync::atomic::{AtomicBool, Ordering};

    // Actor 结构体中可以包含一个用于表示连接状态的原子标志
    pub struct MyStatusAwareActor {
        is_ready: AtomicBool,
    }

    #[async_trait]
    impl Lifecycle for MyStatusAwareActor {
        // ... on_start, on_stop ...

        async fn on_signaling_connected(&self, ctx: Arc<Context>) {
            ctx.log_info("成功连接到信令服务器，Actor 已就绪。");
            self.is_ready.store(true, Ordering::Relaxed);

            // 可以在这里执行一些连接成功后才应进行的操作，
            // 例如，向某个协调服务报告自己“在线”。
            // ctx.tell(COORDINATOR_ID, IAmReady { ... }).await;
        }

        async fn on_signaling_disconnected(&self, ctx: Arc<Context>) {
            ctx.log_warn("与信令服务器断开连接，服务暂时不可用。");
            self.is_ready.store(false, Ordering::Relaxed);

            // 通知其他模块或服务，本 Actor 已离线
            // 这对于实现 UI 上的“正在重连”提示至关重要
        }
    }
    ```

2.  **在业务逻辑中使用状态**: 在处理其他业务请求时，可以检查 `is_ready` 标志，以决定是正常处理还是返回“服务暂时不可用”的错误。

    ```rust
    #[async_trait]
    impl MyServiceHandler for MyStatusAwareActor {
        async fn handle_request(&self, req: MyRequest, ctx: &Context) -> ActorResult<MyResponse> {
            if !self.is_ready.load(Ordering::Relaxed) {
                return Err(ActorError::unavailable("服务暂时不可用，正在尝试重连..."));
            }
            // ... 正常处理业务 ...
        }
    }
    ```

**优势**: 此模式将网络状态的变化，无缝地集成到了 Actr 的生命周期中，使得开发者可以用统一、内聚的方式来处理业务逻辑和网络容错，而无需在应用的其他地方监听和传递网络事件。
---

## **模式七："快速路径"性能优化模式 (Fast Path Performance Pattern)**

> **⚠️ 重要安全警告**
>
> Fast Path 是**高级性能优化工具**，不当使用会导致严重问题。使用前必须确认：
>
> - ✅ **数据可丢失**：Fast Path 不提供持久化，崩溃后数据丢失
> - ✅ **无状态保证**：绕过 Mailbox，无法保证顺序性和原子性
> - ✅ **并发安全**：回调在独立任务中执行，必须处理并发冲突
> - ⚠️ **禁止直接修改状态**：永远不要在 Fast Path 回调中直接修改 `self.state`
> - ⚠️ **禁用 sleep 同步**：永远不要使用 `sleep()` 来协调 Fast Path 与 State Path 的同步
>
> **安全实践**：
> - 如需修改状态，使用"并发句柄"模式通过 `ctx.tell()` 发送到 State Path
> - 如需状态访问，使用 `Arc<RwLock<T>>` 或 `Arc<Mutex<T>>` 保护共享数据
> - 优先使用 `register_data_stream()` 或 `register_media_track()` API
>
> 详见 [3.8 Fast Path 内部机制](./3.8-fast-path-internals.zh.md) 和 [3.10 Fast Path 生命周期](./3.10-fast-path-lifecycle.zh.md)

#### **问题场景**

当服务需要处理极高吞吐量的、可丢失的数据流（例如，实时的音视频裸流、遥测数据）时，常规的Actor消息处理机制（涉及消息邮箱、状态持久化）可能会成为性能瓶颈。

#### **核心思想**

对于这类场景，框架提供了“快速路径（Fast Path）”作为性能优化的“逃生舱口”。它允许数据直接从网络层推送到一个专门的回调函数，完全绕过Actor的邮箱和状态管理。这以牺牲持久化和状态一致性为代价，换取了极致的低延迟和高吞吐量。

> 强警告：快速路径是性能优化的特种工具。除非你完全理解并设计了充分的防护（线程安全、死锁规避、幂等与一致性、恢复与重放、监控告警），否则不要在 Fast Path 中修改核心状态。若必须，可以通过“并发句柄”模式，通过 tell 回到 State Path 执行变更。

#### **实现步骤**

1.  **在 `.proto` 文件中定义快速路径服务**: 使用特定的gRPC服务选项来标记一个服务为“快速路径”。
    ```protobuf
    service MyFastPathService {
      // 具体定义方式请参考框架的 .proto 规范
      rpc HandleStream (stream MyDataPacket) returns (google.protobuf.Empty) {
        option (actr.v1.stream_mode) = FAST_PATH;
      }
    }
    ```

2.  **在Actor中实现快速路径回调**: 框架会生成相应的 `trait`，您只需在Actor中实现它。
    ```rust
    #[async_trait]
    impl IMyFastPathService for ApplicationActor {
        async fn handle_stream(&self, stream: InboundStream<MyDataPacket>, ctx: Arc<Context>) {
            // 警告：此处的代码在独立的任务中并发执行
            // 绝对不能直接修改 self.state
            stream.for_each(|packet| async move {
                // 处理数据包，例如转发到另一个网络端点
                // 或者通过“并发句柄”模式安全地与主状态交互
            }).await;
        }
    }
    ```

3.  **结合“并发句柄”模式**: 如果快速路径中的逻辑确实需要与主Actor状态交互（例如，更新统计数据），**必须**使用“并发句柄”模式来保证线程安全。

**优势**:
*   **极致性能**: 接近网络硬件极限的数据处理能力。
*   **低延迟**: 数据流不经过任何中间队列。

**权衡**:
*   **无持久化**: 数据是易失的，崩溃后即丢失。
*   **无自动状态管理**: 开发者需要手动保证线程安全和状态一致性。

> 更多关于快速路径的底层机制，请参阅《[3.8-Fast-Path-Internals.zh.md](./3.8-fast-path-internals.zh.md)》和《[3.10-Fast-Path-Lifecycle.zh.md](./3.10-fast-path-lifecycle.zh.md)》。

---

## **模式六："错误处理"模式 (Error Handling)**

#### **问题场景**

在分布式系统中，错误无处不在：网络中断、远程服务超时、数据反序列化失败、业务逻辑校验失败等。如何优雅地处理这些错误，既保证系统稳定性，又提供清晰的错误信息？

#### **核心思想**

actr 框架使用 `ActorResult<T>` 作为统一的错误类型，所有 Handler 方法都返回此类型。框架提供分层的错误处理机制：传输层错误自动重试、协议错误记录日志、业务错误返回给调用方。

#### **错误类型层次**

```rust
use actr_protocol::{ProtocolError, ActorResult};

// ProtocolError 是框架的顶层错误类型
pub enum ProtocolError {
    // 网络传输错误（自动重试）
    TransportError(String),

    // 序列化/反序列化错误（记录日志，丢弃消息）
    DecodeError(String),
    SerializationError(String),

    // 业务逻辑错误（返回给调用方）
    InvalidArgument(String),
    NotFound(String),
    PermissionDenied(String),
    Internal(String),
}

// ActorResult 是所有 Handler 方法的返回类型
pub type ActorResult<T> = Result<T, ProtocolError>;
```

#### **实现模式**

```rust
use actr_framework::prelude::*;
use actr_protocol::{ActorResult, ProtocolError};

#[async_trait]
impl MyServiceHandler for MyWorkload {
    async fn process_order(
        &self,
        req: ProcessOrderRequest,
        ctx: &Context
    ) -> ActorResult<ProcessOrderResponse> {
        // 1. 输入验证（业务错误）
        if req.items.is_empty() {
            return Err(ProtocolError::InvalidArgument(
                "Order must contain at least one item".to_string()
            ));
        }

        // 2. 远程调用（网络错误 - 框架自动重试）
        let inventory_status = ctx
            .call(
                Dest::Remote(self.inventory_service_id.clone()),
                CheckInventoryRequest {
                    items: req.items.clone(),
                }
            )
            .await
            .map_err(|e| {
                tracing::error!("Inventory service call failed: {:?}", e);
                // 转换为业务错误
                ProtocolError::Internal(format!("Failed to check inventory: {}", e))
            })?;

        // 3. 业务逻辑校验
        if !inventory_status.all_available {
            return Err(ProtocolError::InvalidArgument(
                format!("Items not available: {:?}", inventory_status.unavailable_items)
            ));
        }

        // 4. 数据库操作（资源错误）
        let order_id = self.db
            .create_order(&req)
            .await
            .map_err(|e| {
                tracing::error!("Database error: {:?}", e);
                ProtocolError::Internal("Failed to create order".to_string())
            })?;

        // 5. 成功响应
        Ok(ProcessOrderResponse {
            order_id,
            status: "confirmed".to_string(),
        })
    }
}
```

#### **错误处理最佳实践**

**1. 网络错误：让框架自动重试**
```rust
// ✅ 好的实践：直接传播网络错误，框架会自动重试
let result = ctx.call(target, request).await?;

// ❌ 不好的实践：捕获后转换为业务错误，失去自动重试
let result = ctx.call(target, request).await
    .map_err(|e| ProtocolError::InvalidArgument(e.to_string()))?;
```

**2. 业务错误：返回明确的错误码**
```rust
// ✅ 好的实践：使用语义明确的错误类型
if user.balance < order.total {
    return Err(ProtocolError::InvalidArgument(
        "Insufficient balance".to_string()
    ));
}

// ❌ 不好的实践：使用通用的 Internal 错误
if user.balance < order.total {
    return Err(ProtocolError::Internal("Error".to_string()));
}
```

**3. 资源错误：及时释放资源**
```rust
// ✅ 好的实践：使用 RAII 模式或显式释放
async fn process_with_lock(&self) -> ActorResult<()> {
    let _guard = self.mutex.lock().await;
    // ... 处理逻辑
    // guard 在函数结束时自动释放
    Ok(())
}

// 或者显式释放
async fn process_with_resource(&self) -> ActorResult<Response> {
    let resource = self.acquire_resource().await?;
    let result = self.do_work(&resource).await;
    resource.release().await?;
    result
}
```

**4. 日志记录：不同错误级别使用不同日志**
```rust
match ctx.call(target, request).await {
    Ok(response) => Ok(response),
    Err(ProtocolError::TransportError(e)) => {
        // 网络错误：warn 级别（框架会重试）
        tracing::warn!("Remote call failed (will retry): {}", e);
        Err(ProtocolError::TransportError(e))
    }
    Err(ProtocolError::InvalidArgument(e)) => {
        // 业务错误：info 级别（正常业务逻辑）
        tracing::info!("Invalid request: {}", e);
        Err(ProtocolError::InvalidArgument(e))
    }
    Err(ProtocolError::Internal(e)) => {
        // 内部错误：error 级别（需要人工介入）
        tracing::error!("Internal error occurred: {}", e);
        Err(ProtocolError::Internal(e))
    }
}
```

**5. 超时处理：为长时间操作设置超时**
```rust
use tokio::time::{timeout, Duration};

async fn call_with_timeout(&self, ctx: &Context) -> ActorResult<Response> {
    match timeout(Duration::from_secs(30), ctx.call(target, request)).await {
        Ok(Ok(response)) => Ok(response),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(ProtocolError::TransportError(
            "Request timeout after 30s".to_string()
        )),
    }
}
```

#### **错误传播链**

框架中的错误传播遵循以下规则：

```
用户 Handler
    ↓ (返回 ProtocolError)
Context API (ctx.call)
    ↓ (传播或转换)
OutGate (OutprocOutGate)
    ↓ (TransportError → 自动重试)
TransportManager
    ↓ (底层错误 → TransportError)
WebRTC / WebSocket
```

**优势**：
- **分层清晰**：每层只处理自己职责范围内的错误
- **自动重试**：网络错误在传输层自动重试，业务层无感知
- **类型安全**：使用 Result<T, E> 强制错误处理，避免遗漏

**权衡**：
- **错误信息可能丢失**：多层转换可能导致原始错误堆栈丢失
- **需要明确分类**：开发者需要正确区分错误类型（TransportError vs InvalidArgument）

---

## **总结**

本章介绍的六种模式，构成了构建健壮 Actor 服务的基础工具箱：

1. **服务门面**：组织复杂业务逻辑
2. **依赖注入**：解耦服务依赖，支持测试
3. **基于角色的访问控制**：实现安全策略
4. **并发句柄**：状态路径与快车道协作
5. **快车道**：极致性能的流式数据处理
6. **错误处理**：优雅地处理分布式错误

掌握这些模式，你就能充分发挥"宏观 Actor"架构的优势，构建出可扩展、可维护、高性能的分布式服务。