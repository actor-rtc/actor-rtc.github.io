# Actrix å‡­è¯æ›´æ–°æµç¨‹

## æµç¨‹æ¦‚è¿°

å‡­è¯æ›´æ–°æ˜¯ Actrix è®¤è¯ç³»ç»Ÿçš„å…³é”®åŠŸèƒ½ï¼Œå…è®¸å·²è®¤è¯çš„ actr å®¢æˆ·ç«¯åœ¨å‡­è¯å³å°†è¿‡æœŸæ—¶æ— ç¼è·å–æ–°å‡­è¯ã€‚è¿™ä¸ªè¿‡ç¨‹ç¡®ä¿äº† **actr_id** å’Œ **PSK** çš„è¿ç»­æ€§ï¼Œåªæ›´æ–°äº† **credential** å’Œ **expires_at**ï¼Œä»è€Œä¿æŒèº«ä»½å’ŒåŠ å¯†å¯†é’¥ä¸å˜ã€‚

## æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant actr as actr
    participant signaling as signaling
    participant ais as ais
    participant ks as ks (å¯é€‰)

    Note over actr: credential å³å°†è¿‡æœŸ<br/>éœ€è¦ç»­æœŸ

    actr->>signaling: 17. ActrToSignaling.CredentialUpdateRequest
    Note right of actr: credential: String (æ—§å‡­è¯)<br/>encrypted_credential: String (æ—§çš„åŠ å¯†å‡­è¯)

    signaling->>signaling: 18. éªŒè¯æ—§å‡­è¯
    Note right of signaling: 1. è§£å¯† encrypted_credential<br/>2. éªŒè¯ç­¾åå’Œè¿‡æœŸæ—¶é—´

    alt ç¼“å­˜ä¸­æœ‰æ—§å‡­è¯çš„ SecretKeyCache
        signaling->>signaling: 18a. ä½¿ç”¨ç¼“å­˜éªŒè¯ âœ…
        Note right of signaling: ä¸éœ€è¦è°ƒç”¨ KS
        
    else ç¼“å­˜æœªå‘½ä¸­ï¼ˆå¯†é’¥è½®æ¢åï¼‰
        signaling->>ks: GetSecretKeyRequest
        Note right of signaling: key_id: æ—§å‡­è¯çš„ key_id
        
        ks-->>signaling: GetSecretKeyResponse
        Note left of ks: secret_key: String
        
        signaling->>signaling: 18b. è§£å¯†å¹¶ç¼“å­˜
        Note right of signaling: å­˜å…¥ SecretKeyCache<br/>ä¾›åç»­éªŒè¯ä½¿ç”¨
    end

    alt æ—§å‡­è¯æœ‰æ•ˆ
        signaling->>ais: 19. RequestNewCredential (gRPC)
        Note right of signaling: actr_id: i64<br/>actr_type: String<br/>realm: String
        
        ais->>ais: 20. æŸ¥è¯¢ç°æœ‰ actr_id çš„ä¿¡æ¯
        Note right of ais: ä»æ•°æ®åº“è·å–:<br/>- psk (ä¿æŒä¸å˜)<br/>- actr_type, realm (éªŒè¯ä¸€è‡´æ€§)

        ais->>ais: 21. è·å–å½“å‰å…¬é’¥
        Note right of ais: CurrentKeyCache æŸ¥è¯¢<br/>ï¼ˆä¸æ³¨å†Œæµç¨‹æ­¥éª¤ 3 ç›¸åŒï¼‰

        alt CurrentKeyCache å‘½ä¸­
            ais->>ais: 21a. ä½¿ç”¨ç¼“å­˜å…¬é’¥ âœ…
            Note right of ais: ç¼“å­˜ TTL: 10 åˆ†é’Ÿ
            
        else CurrentKeyCache æœªå‘½ä¸­
            ais->>ks: GetCurrentKeyRequest
            Note right of ais: ç©ºè¯·æ±‚
            
            ks-->>ais: GetCurrentKeyResponse
            Note left of ks: key_id: u32<br/>public_key: String<br/>valid_until: u64
            
            ais->>ais: 21b. æ›´æ–°ç¼“å­˜
            Note right of ais: å­˜å…¥ CurrentKeyCache<br/>è¿‡æœŸæ—¶é—´: 10 åˆ†é’Ÿå
        end

        ais->>ais: 22. ç­¾å‘æ–°å‡­è¯
        Note right of ais: 1. ç”Ÿæˆæ–° IdentityClaims<br/>   - actr_id: ä¸å˜ âœ…<br/>   - psk: ä¸å˜ âœ…<br/>   - expires_at: å½“å‰æ—¶é—´ + 1 å°æ—¶<br/>2. ç­¾åå‡­è¯<br/>3. ECIES åŠ å¯†

        ais-->>signaling: 23. NewCredential (gRPC Response)
        Note left of ais: credential: String<br/>encrypted_credential: String<br/>credential_expires_at: u64

        signaling-->>actr: 24. CredentialUpdateResponse
        Note left of signaling: credential: String<br/>encrypted_credential: String<br/>credential_expires_at: u64

        Note over actr: âœ… å‡­è¯å·²æ›´æ–°<br/>actr_id å’Œ PSK ä¿æŒä¸å˜

    else æ—§å‡­è¯æ— æ•ˆ
        signaling-->>actr: 24b. é”™è¯¯å“åº”
        Note left of signaling: error_code: INVALID_CREDENTIAL<br/>message: "Credential expired or invalid"
        
        Note over actr: âŒ éœ€è¦é‡æ–°æ³¨å†Œ
    end
```

---

## åè®®è¯¦è§£

### æ­¥éª¤ 17: å®¢æˆ·ç«¯å‘èµ·æ›´æ–°è¯·æ±‚

**CredentialUpdateRequest å®šä¹‰** (`actr/crates/protocol/proto/actr.proto`):

```protobuf
// ä» actr åˆ° Signaling çš„æ¶ˆæ¯
message ActrToSignaling {
  oneof message {
    // ... å…¶ä»–æ¶ˆæ¯ç±»å‹
    
    CredentialUpdateRequest credential_update_request = 4;
  }
}

message CredentialUpdateRequest {
  // å½“å‰ï¼ˆå³å°†è¿‡æœŸçš„ï¼‰å‡­è¯ï¼ˆæ˜æ–‡ï¼‰
  required string credential = 1;
  
  // å½“å‰å‡­è¯çš„åŠ å¯†ç‰ˆæœ¬ï¼ˆECIES åŠ å¯†ï¼‰
  required string encrypted_credential = 2;
}
```

**å®¢æˆ·ç«¯å‘é€æ—¶æœº**:

```rust
// actr/crates/actr/src/credential_manager.rs
use tokio::time::{interval, Duration};

pub struct CredentialManager {
    credential: Option<AIdCredential>,
    credential_expires_at: Option<u64>,
    
    // æ›´æ–°è§¦å‘é˜ˆå€¼ï¼ˆé»˜è®¤ 5 åˆ†é’Ÿï¼‰
    renewal_threshold: Duration,
}

impl CredentialManager {
    /// åå°ä»»åŠ¡ï¼šç›‘æ§å‡­è¯è¿‡æœŸ
    pub async fn start_renewal_task(&mut self) {
        let mut check_interval = interval(Duration::from_secs(60));
        
        loop {
            check_interval.tick().await;
            
            if self.should_renew_credential() {
                match self.renew_credential().await {
                    Ok(new_credential) => {
                        info!("Credential renewed: expires_at={}", new_credential.expires_at);
                        self.credential = Some(new_credential);
                    }
                    Err(e) => {
                        error!("Failed to renew credential: {}", e);
                        // è§¦å‘é‡æ–°æ³¨å†Œ
                        self.trigger_reregistration().await;
                    }
                }
            }
        }
    }
    
    /// åˆ¤æ–­æ˜¯å¦éœ€è¦ç»­æœŸ
    fn should_renew_credential(&self) -> bool {
        if let Some(expires_at) = self.credential_expires_at {
            let now = SystemTime::now().as_secs();
            let time_until_expiry = expires_at.saturating_sub(now);
            
            // å¦‚æœå‰©ä½™æ—¶é—´ < 5 åˆ†é’Ÿï¼Œè§¦å‘ç»­æœŸ
            time_until_expiry < self.renewal_threshold.as_secs()
        } else {
            false
        }
    }
    
    /// å‘é€æ›´æ–°è¯·æ±‚
    async fn renew_credential(&self) -> Result<AIdCredential> {
        let request = CredentialUpdateRequest {
            credential: self.credential.as_ref().unwrap().to_string(),
            encrypted_credential: self.encrypted_credential.clone(),
        };
        
        let message = ActrToSignaling {
            message: Some(actr_to_signaling::Message::CredentialUpdateRequest(request)),
        };
        
        self.signaling_client.send(message).await?;
        
        // ç­‰å¾…å“åº”ï¼ˆè¶…æ—¶ 10 ç§’ï¼‰
        let response = timeout(Duration::from_secs(10), self.wait_for_response()).await??;
        
        Ok(response.credential)
    }
}
```

---

### æ­¥éª¤ 18-19: Signaling éªŒè¯æ—§å‡­è¯

**éªŒè¯é€»è¾‘** (`actrix/crates/signaling/src/credential_verifier.rs`):

```rust
use actr_protocol::AIdCredential;
use actrix_ks_client::KsClient;

pub struct CredentialVerifier {
    ks_client: KsClient,
    
    // å¯†é’¥ç¼“å­˜ï¼ˆæ”¯æŒå¤šç‰ˆæœ¬ï¼‰
    secret_key_cache: Arc<RwLock<HashMap<u32, SecretKeyEntry>>>,
}

#[derive(Clone)]
struct SecretKeyEntry {
    secret_key: Vec<u8>,
    cached_at: SystemTime,
    // å¯†é’¥æ°¸ä¹…æœ‰æ•ˆï¼Œä¸éœ€è¦ TTL
}

impl CredentialVerifier {
    /// éªŒè¯å‡­è¯
    pub async fn verify_credential(
        &self,
        credential: &str,
        encrypted_credential: &str,
    ) -> Result<IdentityClaims> {
        // 1. Base64 è§£ç 
        let encrypted_bytes = base64::decode(encrypted_credential)?;
        
        // 2. æå– key_idï¼ˆåŠ å¯†æ•°æ®çš„å‰ 4 å­—èŠ‚ï¼‰
        let key_id = u32::from_be_bytes(encrypted_bytes[0..4].try_into()?);
        
        // 3. è·å–è§£å¯†å¯†é’¥ï¼ˆç¼“å­˜ä¼˜å…ˆï¼‰
        let secret_key = self.get_secret_key(key_id).await?;
        
        // 4. ECIES è§£å¯†
        let decrypted = ecies::decrypt(&secret_key, &encrypted_bytes)?;
        
        // 5. JSON ååºåˆ—åŒ–
        let claims: IdentityClaims = serde_json::from_slice(&decrypted)?;
        
        // 6. éªŒè¯ç­¾åï¼ˆä¸æ˜æ–‡ credential æ¯”å¯¹ï¼‰
        let expected_credential = claims.to_credential_string();
        if credential != expected_credential {
            return Err(Error::SignatureMismatch);
        }
        
        // 7. æ£€æŸ¥è¿‡æœŸæ—¶é—´
        let now = SystemTime::now().as_secs();
        if now > claims.credential_expires_at {
            return Err(Error::CredentialExpired {
                expired_at: claims.credential_expires_at,
                now,
            });
        }
        
        Ok(claims)
    }
    
    /// è·å–è§£å¯†å¯†é’¥ï¼ˆç¼“å­˜ä¼˜å…ˆï¼‰
    async fn get_secret_key(&self, key_id: u32) -> Result<Vec<u8>> {
        // 1ï¸âƒ£ æ£€æŸ¥ç¼“å­˜
        if let Some(entry) = self.secret_key_cache.read().await.get(&key_id) {
            debug!("SecretKeyCache hit: key_id={}", key_id);
            return Ok(entry.secret_key.clone());
        }
        
        // 2ï¸âƒ£ ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨ KS
        debug!("SecretKeyCache miss: key_id={}, calling KS", key_id);
        
        let request = GetSecretKeyRequest { key_id };
        let response = self.ks_client.get_secret_key(request).await?;
        
        let secret_key = base64::decode(&response.secret_key)?;
        
        // 3ï¸âƒ£ å­˜å…¥ç¼“å­˜ï¼ˆå¯†é’¥æ°¸ä¹…æœ‰æ•ˆï¼Œç›´åˆ°æœåŠ¡å™¨é‡å¯ï¼‰
        self.secret_key_cache.write().await.insert(key_id, SecretKeyEntry {
            secret_key: secret_key.clone(),
            cached_at: SystemTime::now(),
        });
        
        info!("SecretKeyCache updated: key_id={}, cache_size={}",
              key_id, self.secret_key_cache.read().await.len());
        
        Ok(secret_key)
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ SecretKeyCacheï¼Ÿ**

```
åœºæ™¯ï¼šå¯†é’¥è½®æ¢åï¼Œæ—§å‡­è¯çš„éªŒè¯

æ—¶é—´çº¿ï¼š
â”œâ”€ T0: KS ç”Ÿæˆ key_id=5ï¼ŒAIS ç¼“å­˜ public_key_5
â”œâ”€ T0+1h: å®¢æˆ·ç«¯ A æ³¨å†Œï¼Œè·å¾—å‡­è¯ï¼ˆkey_id=5, expires_at=T0+2hï¼‰
â”œâ”€ T0+24h: KS è½®æ¢åˆ° key_id=6ï¼ŒCurrentKeyCache æ›´æ–°
â”œâ”€ T0+25h: å®¢æˆ·ç«¯ A çš„å‡­è¯å³å°†è¿‡æœŸï¼ˆkey_id=5ï¼‰ï¼Œå‘èµ·ç»­æœŸ
â”‚
â””â”€ æ­¤æ—¶ Signaling éœ€è¦éªŒè¯ key_id=5 çš„æ—§å‡­è¯
   â””â”€ å¦‚æœæ²¡æœ‰ SecretKeyCacheï¼š
      â”œâ”€ éœ€è¦è°ƒç”¨ KS GetSecretKey(key_id=5)
      â”œâ”€ å¦‚æœå¤§é‡å®¢æˆ·ç«¯åŒæ—¶ç»­æœŸï¼ŒKS å‹åŠ›å·¨å¤§
      â””â”€ æ€§èƒ½ç“¶é¢ˆ âŒ

   â””â”€ æœ‰ SecretKeyCacheï¼š
      â”œâ”€ Signaling å·²ç»ç¼“å­˜äº† secret_key_5
      â”œâ”€ ç›´æ¥è§£å¯†éªŒè¯ï¼Œæ— éœ€è°ƒç”¨ KS
      â””â”€ æ€§èƒ½ä¼˜åŒ– âœ…

ç¼“å­˜æ•ˆæœï¼š
â”œâ”€ 1000 ä¸ªå‡­è¯ç»­æœŸè¯·æ±‚ï¼ˆkey_id=5ï¼‰
â”œâ”€ æ— ç¼“å­˜ï¼š1000 æ¬¡ KS è°ƒç”¨
â”œâ”€ æœ‰ç¼“å­˜ï¼š1 æ¬¡ KS è°ƒç”¨ï¼ˆé¦–æ¬¡ï¼‰
â””â”€ å‡å°‘ 99.9% çš„ KS è´Ÿè½½
```

---

### æ­¥éª¤ 20-23: AIS ç­¾å‘æ–°å‡­è¯

**æ–°å‡­è¯ç”Ÿæˆ** (`actrix/crates/ais/src/issuer.rs`):

```rust
impl Issuer {
    /// ä¸ºå·²å­˜åœ¨çš„ actr_id ç­¾å‘æ–°å‡­è¯
    pub async fn renew_credential(
        &self,
        actr_id: i64,
        actr_type: &str,
        realm: &str,
    ) -> Result<CredentialResponse> {
        // 1ï¸âƒ£ æŸ¥è¯¢ç°æœ‰ä¿¡æ¯ï¼ˆéªŒè¯ä¸€è‡´æ€§ï¼‰
        let existing = self.db.get_actor_info(actr_id).await?;
        
        if existing.actr_type != actr_type || existing.realm != realm {
            return Err(Error::ActorInfoMismatch {
                expected_type: existing.actr_type,
                provided_type: actr_type.to_string(),
                expected_realm: existing.realm,
                provided_realm: realm.to_string(),
            });
        }
        
        // 2ï¸âƒ£ è·å–å½“å‰å…¬é’¥ï¼ˆä¸æ³¨å†Œæµç¨‹ç›¸åŒï¼‰
        let (key_id, public_key, valid_until) = self.get_current_public_key().await?;
        
        // 3ï¸âƒ£ ç­¾å‘æ–°å‡­è¯
        let now = SystemTime::now().as_secs();
        let credential_expires_at = now + self.config.credential_ttl;  // é»˜è®¤ 3600s
        
        let claims = IdentityClaims {
            actr_id,  // âœ… ä¿æŒä¸å˜
            tenant_id: existing.tenant_id,
            actr_type: actr_type.to_string(),
            psk: existing.psk,  // âœ… ä¿æŒä¸å˜
            key_id,
            issued_at: now,
            credential_expires_at,
            key_valid_until: valid_until,
        };
        
        let credential = claims.to_credential_string();
        let encrypted_credential = self.encrypt_claims(&claims, &public_key)?;
        
        // 4ï¸âƒ£ æ›´æ–°æ•°æ®åº“ï¼ˆè®°å½•æœ€æ–°å‡­è¯è¿‡æœŸæ—¶é—´ï¼‰
        self.db.update_credential_expiry(actr_id, credential_expires_at).await?;
        
        info!("Credential renewed: actr_id={}, expires_at={}", actr_id, credential_expires_at);
        
        Ok(CredentialResponse {
            credential,
            encrypted_credential,
            credential_expires_at,
        })
    }
    
    /// è·å–å½“å‰å…¬é’¥ï¼ˆä¸æ³¨å†Œæµç¨‹å…±äº«ï¼‰
    async fn get_current_public_key(&self) -> Result<(u32, String, u64)> {
        // ä¸æ³¨å†Œæµç¨‹æ­¥éª¤ 3-4 å®Œå…¨ç›¸åŒ
        // ... (è§ 1-registration-flow.md)
    }
}
```

**æ•°æ®åº“æ›´æ–°**:

```sql
-- æ›´æ–°å‡­è¯è¿‡æœŸæ—¶é—´ï¼ˆä¸æ›´æ–° pskï¼‰
UPDATE actors
SET 
  credential_expires_at = $1,
  updated_at = NOW()
WHERE actr_id = $2;

-- æ³¨æ„ï¼špsk å­—æ®µä¿æŒä¸å˜ âœ…
```

---

## å‡­è¯è¿ç»­æ€§ä¿è¯

### ä¸å˜çš„å­—æ®µ

| å­—æ®µ | æ³¨å†Œæ—¶ | ç»­æœŸå | è¯´æ˜ |
|------|--------|--------|------|
| **actr_id** | Snowflake ç”Ÿæˆ | **ä¸å˜** âœ… | ä¿è¯èº«ä»½è¿ç»­æ€§ |
| **psk** | éšæœºç”Ÿæˆ | **ä¸å˜** âœ… | ä¿è¯åŠ å¯†å¯†é’¥ä¸€è‡´ |
| **tenant_id** | æ¥è‡ª realm | **ä¸å˜** âœ… | ç§Ÿæˆ·å½’å±ä¸å˜ |
| **actr_type** | å®¢æˆ·ç«¯æä¾› | **ä¸å˜** âœ… | è®¾å¤‡ç±»å‹ä¸å˜ |
| **key_id** | CurrentKeyCache | **å¯èƒ½å˜** âš ï¸ | å¦‚æœå¯†é’¥å·²è½®æ¢ |
| **credential_expires_at** | ç­¾å‘æ—¶é—´ + 1h | **æ›´æ–°** ğŸ”„ | å»¶é•¿æœ‰æ•ˆæœŸ |
| **key_valid_until** | å¯†é’¥æœ‰æ•ˆæœŸ | **å¯èƒ½å˜** âš ï¸ | å¦‚æœå¯†é’¥å·²è½®æ¢ |

### ä¸ºä»€ä¹ˆ key_id å¯èƒ½å˜åŒ–ï¼Ÿ

```
åœºæ™¯ï¼šå‡­è¯ç»­æœŸæ—¶å¯†é’¥å·²è½®æ¢

æ—¶é—´çº¿ï¼š
â”œâ”€ T0: å®¢æˆ·ç«¯æ³¨å†Œ
â”‚  â””â”€ è·å¾—å‡­è¯: key_id=5, credential_expires_at=T0+1h
â”‚
â”œâ”€ T0+45min: å®¢æˆ·ç«¯å‘èµ·å‡­è¯ç»­æœŸ
â”‚  â”œâ”€ æ­¤æ—¶ KS ä»åœ¨ä½¿ç”¨ key_id=5ï¼ˆæœªè½®æ¢ï¼‰
â”‚  â””â”€ æ–°å‡­è¯: key_id=5, credential_expires_at=T0+1h45min âœ…
â”‚
â”œâ”€ T0+24h: KS è‡ªåŠ¨è½®æ¢åˆ° key_id=6
â”‚  â””â”€ CurrentKeyCache æ›´æ–°ä¸º key_id=6
â”‚
â”œâ”€ T0+24h+30min: å®¢æˆ·ç«¯å†æ¬¡ç»­æœŸ
â”‚  â”œâ”€ AIS ä» CurrentKeyCache è·å– key_id=6
â”‚  â””â”€ æ–°å‡­è¯: key_id=6, credential_expires_at=T0+25h30min âœ…
â”‚
â””â”€ ç»“æœï¼škey_id ä» 5 å˜ä¸º 6ï¼Œä½† actr_id å’Œ psk å§‹ç»ˆä¸å˜
```

**å®¢æˆ·ç«¯é€‚é…**:

å®¢æˆ·ç«¯éœ€è¦èƒ½å¤Ÿå¤„ç† `key_id` å˜åŒ–ï¼Œä½†åº”è¯¥ç¡®ä¿ `actr_id` å’Œ `psk` å§‹ç»ˆåŒ¹é…ã€‚

```rust
impl CredentialManager {
    /// éªŒè¯æ–°å‡­è¯çš„è¿ç»­æ€§
    fn validate_renewed_credential(
        &self,
        old_claims: &IdentityClaims,
        new_claims: &IdentityClaims,
    ) -> Result<()> {
        // 1. actr_id å¿…é¡»ç›¸åŒ
        if old_claims.actr_id != new_claims.actr_id {
            return Err(Error::ActorIdMismatch);
        }
        
        // 2. PSK å¿…é¡»ç›¸åŒ
        if old_claims.psk != new_claims.psk {
            return Err(Error::PskMismatch);
        }
        
        // 3. key_id å…è®¸å˜åŒ–ï¼ˆå¯†é’¥è½®æ¢ï¼‰
        if old_claims.key_id != new_claims.key_id {
            warn!("Key rotated: old_key_id={}, new_key_id={}",
                  old_claims.key_id, new_claims.key_id);
        }
        
        // 4. credential_expires_at å¿…é¡»å»¶é•¿
        if new_claims.credential_expires_at <= old_claims.credential_expires_at {
            return Err(Error::CredentialNotExtended);
        }
        
        Ok(())
    }
}
```

---

## é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯åœºæ™¯

#### 1. æ—§å‡­è¯å·²è¿‡æœŸ

```rust
Error::CredentialExpired {
    expired_at: 1735689600,
    now: 1735693200,
}
```

**åŸå› **:
- å®¢æˆ·ç«¯æœªåŠæ—¶ç»­æœŸ
- ç½‘ç»œä¸­æ–­å¯¼è‡´ç»­æœŸè¯·æ±‚å¤±è´¥

**å¤„ç†**:
- å®¢æˆ·ç«¯éœ€è¦é‡æ–°æ³¨å†Œï¼ˆæ­¥éª¤ 1-7ï¼‰
- ä¼šè·å¾—æ–°çš„ `actr_id` å’Œ `psk`ï¼ˆèº«ä»½é‡ç½®ï¼‰

---

#### 2. ç­¾åä¸åŒ¹é…

```rust
Error::SignatureMismatch
```

**åŸå› **:
- `credential` å’Œ `encrypted_credential` å†…å®¹ä¸ä¸€è‡´
- å¯èƒ½æ˜¯ä¸­é—´äººæ”»å‡»æˆ–ä¼ è¾“é”™è¯¯

**å¤„ç†**:
- æ‹’ç»ç»­æœŸè¯·æ±‚
- è®°å½•å®‰å…¨äº‹ä»¶æ—¥å¿—

---

#### 3. ActorInfo ä¸ä¸€è‡´

```rust
Error::ActorInfoMismatch {
    expected_type: "apple:iphone",
    provided_type: "google:android",
    expected_realm: "realm1",
    provided_realm: "realm2",
}
```

**åŸå› **:
- å®¢æˆ·ç«¯ä¼ªé€ äº† `actr_type` æˆ– `realm`
- å¯èƒ½æ˜¯æ¶æ„è¯·æ±‚

**å¤„ç†**:
- æ‹’ç»ç»­æœŸè¯·æ±‚
- å¯èƒ½å°ç¦è¯¥ `actr_id`

---

#### 4. KS ä¸å¯ç”¨

```rust
Error::KsUnavailable
```

**åŸå› **:
- KS æœåŠ¡å®•æœºæˆ–ç½‘ç»œæ•…éšœ
- CurrentKeyCache å’Œ SecretKeyCache å‡æœªå‘½ä¸­

**å¤„ç†**:
- Signaling/AIS è¿”å›ä¸´æ—¶é”™è¯¯
- å®¢æˆ·ç«¯å»¶è¿Ÿé‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰

```rust
async fn renew_with_exponential_backoff(&mut self) -> Result<AIdCredential> {
    let mut delay = Duration::from_secs(1);
    let max_delay = Duration::from_secs(60);
    let mut attempts = 0;
    
    loop {
        match self.renew_credential().await {
            Ok(credential) => return Ok(credential),
            
            Err(Error::KsUnavailable) if attempts < 5 => {
                warn!("KS unavailable, retrying in {:?}", delay);
                tokio::time::sleep(delay).await;
                
                delay = std::cmp::min(delay * 2, max_delay);
                attempts += 1;
            }
            
            Err(e) => return Err(e),
        }
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ç­–ç•¥å¯¹æ¯”

| ç»„ä»¶ | ç¼“å­˜ç±»å‹ | ç¼“å­˜å†…å®¹ | TTL | å‘½ä¸­ç‡ |
|------|---------|---------|-----|--------|
| **AIS** | CurrentKeyCache | å½“å‰å…¬é’¥ | 10 åˆ†é’Ÿ | >99% |
| **Signaling** | SecretKeyCache | å†å²ç§é’¥ | æ°¸ä¹…ï¼ˆç›´åˆ°é‡å¯ï¼‰ | >95% |
| **TURN** | LRU Cache | è®¤è¯å¯†é’¥ | LRU æ·˜æ±° | >90% |

**ç¼“å­˜æ”¶ç›Š**:

```
åœºæ™¯ï¼š1 åˆ†é’Ÿå†… 1000 ä¸ªå‡­è¯ç»­æœŸè¯·æ±‚

æ— ç¼“å­˜ï¼ˆSignaling æ¯æ¬¡è°ƒç”¨ KS GetSecretKeyï¼‰ï¼š
â”œâ”€ KS GetSecretKey è°ƒç”¨: 1000 æ¬¡
â”œâ”€ æ¯æ¬¡è°ƒç”¨è€—æ—¶: ~5msï¼ˆç½‘ç»œ + æŸ¥è¯¢ï¼‰
â”œâ”€ æ€»è€—æ—¶: 5000ms
â””â”€ KS æˆä¸ºç“¶é¢ˆ âŒ

æœ‰ SecretKeyCacheï¼ˆ>95% å‘½ä¸­ç‡ï¼‰ï¼š
â”œâ”€ KS GetSecretKey è°ƒç”¨: ~50 æ¬¡ï¼ˆ5% missï¼‰
â”œâ”€ ç¼“å­˜å‘½ä¸­è€—æ—¶: ~0.1msï¼ˆå†…å­˜æŸ¥è¯¢ï¼‰
â”œâ”€ æ€»è€—æ—¶: 950ms + 250ms â‰ˆ 1200ms
â””â”€ æ€§èƒ½æå‡ 4.2 å€ âœ…
```

---

### 2. é¢„ç»­æœŸç­–ç•¥

**æå‰ç»­æœŸæ—¶é—´è®¡ç®—**:

```rust
impl CredentialManager {
    /// è®¡ç®—ç»­æœŸæ—¶æœºï¼ˆé»˜è®¤æå‰ 5 åˆ†é’Ÿï¼‰
    fn calculate_renewal_time(&self) -> SystemTime {
        let expires_at = self.credential_expires_at.unwrap();
        let renewal_threshold = self.config.renewal_threshold;  // 5 åˆ†é’Ÿ
        
        SystemTime::from_secs(expires_at - renewal_threshold.as_secs())
    }
    
    /// åŠ¨æ€è°ƒæ•´ç»­æœŸé˜ˆå€¼ï¼ˆåŸºäºç½‘ç»œå»¶è¿Ÿï¼‰
    fn adjust_renewal_threshold(&mut self, network_latency: Duration) {
        // å¦‚æœç½‘ç»œå»¶è¿Ÿé«˜ï¼Œæå‰æ›´å¤šæ—¶é—´ç»­æœŸ
        let min_threshold = Duration::from_secs(60);  // æœ€å°‘æå‰ 1 åˆ†é’Ÿ
        let max_threshold = Duration::from_secs(600);  // æœ€å¤šæå‰ 10 åˆ†é’Ÿ
        
        let adjusted = network_latency * 10;  // 10 å€ç½‘ç»œå»¶è¿Ÿ
        self.config.renewal_threshold = adjusted.clamp(min_threshold, max_threshold);
    }
}
```

**æ”¶ç›Š**:
- é¿å…åœ¨è¿‡æœŸä¸´ç•Œç‚¹å¤§é‡å¹¶å‘ç»­æœŸ
- æä¾›ç¼“å†²æ—¶é—´å¤„ç†ç½‘ç»œæ•…éšœ
- å¹³æ»‘åˆ†æ•£ç»­æœŸè¯·æ±‚

---

### 3. æ‰¹é‡ç»­æœŸï¼ˆæœªæ¥ä¼˜åŒ–ï¼‰

å¯¹äºåŒä¸€ç§Ÿæˆ·çš„å¤šä¸ªå®¢æˆ·ç«¯ï¼Œå¯ä»¥è€ƒè™‘æ‰¹é‡ç»­æœŸæ¥å£ï¼š

```protobuf
message BatchCredentialUpdateRequest {
  repeated CredentialUpdateItem items = 1;
}

message CredentialUpdateItem {
  required string credential = 1;
  required string encrypted_credential = 2;
}

message BatchCredentialUpdateResponse {
  repeated CredentialUpdateResult results = 1;
}

message CredentialUpdateResult {
  optional string credential = 1;
  optional string encrypted_credential = 2;
  optional uint64 credential_expires_at = 3;
  optional string error = 4;  // å¦‚æœå¤±è´¥
}
```

**æ”¶ç›Š**:
- å‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°
- å…±äº« CurrentKeyCache æŸ¥è¯¢
- é€‚ç”¨äºæœåŠ¡å™¨ç«¯ç®¡ç†å¤šä¸ª actr çš„åœºæ™¯

---

## ç›‘æ§æŒ‡æ ‡

### ç»­æœŸæˆåŠŸç‡

```rust
use prometheus::{IntCounter, Histogram};

struct CredentialRenewalMetrics {
    // ç»­æœŸè¯·æ±‚æ€»æ•°
    renewal_requests_total: IntCounter,
    
    // ç»­æœŸæˆåŠŸ/å¤±è´¥
    renewal_success_total: IntCounter,
    renewal_failure_total: IntCounter,
    
    // å¤±è´¥åŸå› åˆ†ç±»
    renewal_failure_expired_total: IntCounter,
    renewal_failure_ks_unavailable_total: IntCounter,
    renewal_failure_signature_mismatch_total: IntCounter,
    
    // ç»­æœŸå»¶è¿Ÿ
    renewal_duration: Histogram,
    
    // ç¼“å­˜å‘½ä¸­ç‡
    secret_key_cache_hits_total: IntCounter,
    secret_key_cache_misses_total: IntCounter,
}
```

### å‘Šè­¦è§„åˆ™

```yaml
alerts:
  - name: high_credential_renewal_failure_rate
    expr: rate(renewal_failure_total[5m]) / rate(renewal_requests_total[5m]) > 0.05
    severity: warning
    message: "å‡­è¯ç»­æœŸå¤±è´¥ç‡è¶…è¿‡ 5%"
    
  - name: credential_expiry_without_renewal
    expr: |
      (time() - actor_credential_expires_at) > 300
      and actor_last_renewal_attempt_time < (time() - 600)
    severity: critical
    message: "å­˜åœ¨å‡­è¯å·²è¿‡æœŸ 5 åˆ†é’Ÿä½†æœªå°è¯•ç»­æœŸçš„ actr"
    
  - name: low_secret_key_cache_hit_rate
    expr: |
      rate(secret_key_cache_hits_total[5m]) 
      / (rate(secret_key_cache_hits_total[5m]) + rate(secret_key_cache_misses_total[5m])) < 0.9
    severity: info
    message: "SecretKeyCache å‘½ä¸­ç‡ä½äº 90%"
```

---

## å®‰å…¨è€ƒè™‘

### 1. æ—§å‡­è¯éªŒè¯çš„å¿…è¦æ€§

**ä¸ºä»€ä¹ˆä¸èƒ½è·³è¿‡éªŒè¯ï¼Ÿ**

```
æ¶æ„åœºæ™¯ï¼šæ”»å‡»è€…ä¼ªé€ ç»­æœŸè¯·æ±‚

å¦‚æœä¸éªŒè¯æ—§å‡­è¯ï¼š
â”œâ”€ æ”»å‡»è€…å‘é€ä»»æ„ actr_id
â”œâ”€ AIS ç›´æ¥ç­¾å‘æ–°å‡­è¯
â”œâ”€ æ”»å‡»è€…è·å¾—åˆæ³•èº«ä»½
â””â”€ èº«ä»½ç›—ç”¨ âŒ

æœ‰æ—§å‡­è¯éªŒè¯ï¼š
â”œâ”€ æ”»å‡»è€…æ— æ³•æä¾›æœ‰æ•ˆçš„ encrypted_credential
â”œâ”€ è§£å¯†å¤±è´¥æˆ–ç­¾åä¸åŒ¹é…
â”œâ”€ ç»­æœŸè¯·æ±‚è¢«æ‹’ç»
â””â”€ å®‰å…¨ âœ…
```

---

### 2. å‡­è¯è¿‡æœŸå®¹å¿åº¦

**ä¸å»ºè®®å®ç°è¿‡æœŸå®¹å¿**:

è™½ç„¶å¯†é’¥è½®æ¢æœ‰ 1 å°æ—¶å®½é™æœŸï¼Œä½†å‡­è¯è¿‡æœŸåä¸åº”ç»§ç»­æ¥å—ç»­æœŸè¯·æ±‚ã€‚åŸå› ï¼š

1. **ä¸€è‡´æ€§**: å‡­è¯è¿‡æœŸå³è¡¨ç¤ºå¤±æ•ˆï¼Œä¸åº”æœ‰"ç°è‰²åœ°å¸¦"
2. **å®‰å…¨æ€§**: å®¹å¿è¿‡æœŸå‡­è¯å¢åŠ äº†çª—å£æœŸæ”»å‡»é£é™©
3. **ç®€åŒ–é€»è¾‘**: æ˜ç¡®çš„è¿‡æœŸè¾¹ç•Œä¾¿äºç›‘æ§å’Œæ’æŸ¥

**æ›¿ä»£æ–¹æ¡ˆ**:
- å®¢æˆ·ç«¯æå‰ç»­æœŸï¼ˆé»˜è®¤æå‰ 5 åˆ†é’Ÿï¼‰
- å¦‚æœçœŸçš„è¿‡æœŸï¼Œé‡æ–°æ³¨å†Œå³å¯

---

### 3. é˜²æ­¢é‡æ”¾æ”»å‡»

**å½“å‰æœºåˆ¶**:
- å‡­è¯åŒ…å« `issued_at` å’Œ `credential_expires_at`
- ç»­æœŸåæ—§å‡­è¯è‡ªåŠ¨å¤±æ•ˆï¼ˆä¸éœ€è¦æ˜¾å¼æ’¤é”€ï¼‰

**å¯é€‰å¢å¼º**:
- åœ¨æ•°æ®åº“ä¸­è®°å½•æ¯ä¸ª `actr_id` çš„æœ€æ–°å‡­è¯ç‰ˆæœ¬å·
- ç»­æœŸæ—¶éªŒè¯ç‰ˆæœ¬å·å•è°ƒé€’å¢

```rust
// æ•°æ®åº“è¡¨å¢åŠ å­—æ®µ
ALTER TABLE actors ADD COLUMN credential_version INT DEFAULT 1;

// ç»­æœŸæ—¶æ£€æŸ¥
pub async fn renew_credential(&self, actr_id: i64, old_version: i32) -> Result<CredentialResponse> {
    let current_version = self.db.get_credential_version(actr_id).await?;
    
    if old_version != current_version {
        return Err(Error::CredentialVersionMismatch);
    }
    
    let new_version = current_version + 1;
    // ... ç­¾å‘æ–°å‡­è¯
    
    self.db.update_credential_version(actr_id, new_version).await?;
    
    Ok(response)
}
```

---

## ç›¸å…³æ–‡æ¡£

- [æ³¨å†Œæµç¨‹](./1-registration-flow.md)
- [ä¸šåŠ¡è¯·æ±‚è®¤è¯æµç¨‹](./2-authentication-flow.md)
- [TURN è®¤è¯æµç¨‹](./3-turn-authentication.md)
- [å¯†é’¥è½®æ¢ç­–ç•¥](./5-key-rotation.md)
