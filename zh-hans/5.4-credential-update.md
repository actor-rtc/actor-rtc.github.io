# Actrix å‡­è¯æ›´æ–°æµç¨‹

## æµç¨‹æ¦‚è¿°

1) ç»­æœŸè¯·æ±‚å¤ç”¨ `ActrToSignaling` çš„é‰´æƒï¼Œpayload åªåŒ…å« `CredentialUpdateRequest.actr_id`ï¼Œenvelope æºå¸¦å½“å‰çš„ `AIdCredential`ï¼ˆ`encrypted_token` + `token_key_id`ï¼‰ç”¨äºé‰´æƒã€‚  
2) Signaling åœ¨é‰´æƒé€šè¿‡åå°†è¯·æ±‚è½¬ç»™ AISï¼ŒAIS é‡æ–°ç­¾å‘ `AIdCredential` å¹¶é€šè¿‡ `RegisterResponse` è¿”å›ï¼ˆå“åº”ä¸­å¯èƒ½åŒ…å«æ–°çš„ ActrId/PSKï¼‰ï¼›actr ç«¯åªå†™å› credentialï¼Œä¸æ›¿æ¢æœ¬åœ° ActrId/PSKã€‚  
3) å¿ƒè·³é©±åŠ¨ç»­æœŸï¼šSignaling åœ¨ Pong ä¸­æºå¸¦ `CredentialWarning`ï¼ˆå½“å‰ä»… `KEY_IN_TOLERANCE_PERIOD`ï¼‰æ—¶ï¼Œruntime ç«‹å³å‘èµ·ä¸€æ¬¡ `CredentialUpdateRequest` å¹¶å†™å›æ–°çš„ credentialã€‚
4) æ–°å‡­è¯å¯èƒ½å› ä¸ºå¯†é’¥è½®æ¢è€Œæºå¸¦æ–°çš„ `token_key_id`ï¼Œå®¢æˆ·ç«¯è‡ªåŠ¨æ¥å—å¹¶ç”¨äºåç»­å¿ƒè·³ã€è·¯ç”±å’Œé‡è¿ï¼›PSK ä¸ä¼šè¢«è¦†ç›–ã€‚

## æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant actr as actr
    participant signaling as signaling
    participant ais as ais
    participant ks as ks

    Note over actr: credential_refresh_task åœ¨ Pong<br/>æºå¸¦ credential_warning æ—¶è§¦å‘ï¼ˆå•æ¬¡åˆ·æ–°ï¼‰

    actr->>signaling: 1. ActrToSignaling {source, credential, payload=CredentialUpdateRequest{actr_id}}
    Note right of actr: 1.1 credential = AIdCredential { encrypted_token (bytes), token_key_id (u32) }

    signaling->>signaling: 2. éªŒè¯èº«ä»½ä¸å‡­è¯
    Note right of signaling: 2.1 æ ¡éªŒ Realm æœ‰æ•ˆæ€§<br/>2.2 ä½¿ç”¨ AIdCredentialValidator æ ¡éªŒ credentialï¼ˆå‘½ä¸­æœ¬åœ° KeyCacheï¼‰<br/>2.2.1 è§£å¯† token è·å– claims<br/>2.2.2 æ£€æŸ¥è¿‡æœŸæ—¶é—´ä¸ realm_id<br/>2.3 å¤±è´¥åˆ™è¿”å› 401/é”™è¯¯å“åº”
    signaling->>ks: 2a. miss: GetSecretKeyRequest { key_id, credential: NonceCredential }
    ks->>ks: 2a.1 éªŒè¯ NonceCredentialï¼ˆshared_key ç­¾åï¼‰å¹¶æ£€æŸ¥ key æ˜¯å¦å­˜åœ¨/æœªè¿‡æœŸ
    ks-->>signaling: 2b. GetSecretKeyResponse { secret_key (Base64), expires_at }ï¼ˆå†™å…¥ KeyCacheï¼‰

    alt é‰´æƒé€šè¿‡
        signaling->>ais: 3.1 HTTP POST /ais/register<br/>Body: RegisterRequest { realm_id, actr_type }
        ais->>ais: 3.2 ç­¾å‘å‡­è¯ï¼ˆissuer.issue_credentialï¼‰
        ais->>ais: 3.2.1 ç¡®ä¿å…¬é’¥å¯ç”¨ï¼ˆensure_key_loadedï¼Œå¿…è¦æ—¶ KS GenerateKeyï¼‰
        ais->>ks: 3.2.1.1 GenerateKeyRequest { credential: NonceCredential }
        ks->>ks: 3.2.1.1.1 éªŒè¯ NonceCredentialï¼ˆnonce-auth ç­¾å + æ—¶é—´çª—å£ï¼‰
        ks-->>ais: 3.2.1.2 GenerateKeyResponse { key_id, public_key(Base64), expires_at }
        ais->>ais: 3.2.2 ç”Ÿæˆèº«ä»½ä¸å‡­è¯
        Note right of ais: 3.2.2.1 Snowflake ç”Ÿæˆ ActrId<br/>3.2.2.2 credential_expires_at = now + token_ttl_secs<br/>3.2.2.3 ç”Ÿæˆéšæœº PSK å¹¶å†™å…¥ IdentityClaims<br/>3.2.2.4 å½“å‰å…¬é’¥ ECIES åŠ å¯† claims â†’ AIdCredential{encrypted_token, token_key_id}<br/>3.2.2.5 å“åº”ä¸­å¯èƒ½æºå¸¦æ–°çš„ ActrId/PSKï¼Œå®¢æˆ·ç«¯ä¼šå¿½ç•¥ï¼Œåªæ›´æ–° credential
        ais-->>signaling: 4. RegisterResponse.success {credential, credential_expires_at, heartbeat}
        signaling-->>actr: 5. RegisterResponse.success
        actr->>actr: 6. æ›´æ–° CredentialState
    else é‰´æƒå¤±è´¥
        signaling-->>actr: 3.3 RegisterResponse.error / Error
        Note over actr: 3.4 ä»…è®°å½•é”™è¯¯ï¼Œç­‰å¾…åç»­å¿ƒè·³ warning å†æ¬¡è§¦å‘<br/>3.5 å®Œå…¨è¿‡æœŸéœ€é‡æ–°æ³¨å†Œ
    end
```

---

## åè®®ä¸æ¶ˆæ¯

### Proto å…³é”®å­—æ®µ

```protobuf
// actr/proto/actr.proto
message AIdCredential {
  required bytes encrypted_token = 1;
  required uint32 token_key_id = 2;
}

// actr/proto/actr.proto
message CredentialUpdateRequest {
  required ActrId actr_id = 1;
}

// actr/proto/actr.proto
message RegisterResponse {
  message RegisterOk {
    required ActrId actr_id = 1;
    required AIdCredential credential = 2;
    optional bytes psk = 3;
    optional google.protobuf.Timestamp credential_expires_at = 4;
    required uint32 signaling_heartbeat_interval_secs = 5;
  }
  oneof result {
    RegisterOk success = 1;
    ErrorResponse error = 2;
  }
}

// actr/proto/signaling.proto
message ActrToSignaling {
  required actr.ActrId source = 1;
  required actr.AIdCredential credential = 2; // ç»­æœŸä¹Ÿå¿…é¡»æºå¸¦
  oneof payload {
    actr.CredentialUpdateRequest credential_update_request = 5;
    // ...
  }
}

// actr/proto/actr.proto
message Ping {
  required ServiceAvailabilityState availability = 1;
  required float power_reserve = 2;
  required float mailbox_backlog = 3;
}

// actr/proto/actr.proto
message Pong {
  required uint64 seq = 1;
  optional uint32 suggest_interval_secs = 2;
  optional CredentialWarning credential_warning = 3; // Signaling ç”¨äºæç¤ºç»­æœŸ
}

// actr/proto/actr.proto
message CredentialWarning {
  enum WarningType {
    KEY_IN_TOLERANCE_PERIOD = 0;
  }
  required WarningType type = 1;
  required string message = 2;
}

// actrix-proto/proto/keyserver.proto
message GetSecretKeyRequest {
  required uint32 key_id = 1;
  required supervisor.v1.NonceCredential credential = 2;
}

message GetSecretKeyResponse {
  required uint32 key_id = 1;
  required string secret_key = 2;    // Base64
  required uint64 expires_at = 3;    // Unix seconds
}

// éªŒè¯ NonceCredential çš„ç­¾åä¸æ—¶é—´çª—å£ä¾èµ– nonce-auth crateï¼ˆå…±äº«å¯†é’¥ç­¾å + é‡æ”¾ä¿æŠ¤ï¼‰
// actrix-proto/proto/supervisor.proto
message NonceCredential {
  required uint64 timestamp = 1;
  required bytes nonce = 2;
  required bytes signature = 3;
}

```

### Struct å…³é”®å­—æ®µï¼ˆruntimeï¼‰

```rust
// crates/runtime/src/lifecycle/actr_node.rs
// åœ¨å®¢æˆ·ç«¯ä¾§ç»´æŠ¤çš„å‡­è¯çŠ¶æ€ï¼ˆå†…éƒ¨é€šè¿‡ Arc<RwLock<...>> å…±äº«ï¼‰
#[derive(Clone)]
pub struct CredentialState {
  inner: Arc<RwLock<CredentialStateInner>>,
}

#[derive(Clone)]
struct CredentialStateInner {
  credential: AIdCredential,
  expires_at: Option<prost_types::Timestamp>,
  /// This is updated together with credential when credential is refreshed
  psk: Option<Bytes>,
}

impl CredentialState {
  /// Update credential along with PSK
  /// This should be called when credential is refreshed and a new PSK is provided
  pub(crate) async fn update(
    &self,
    credential: AIdCredential,
    expires_at: Option<prost_types::Timestamp>,
    psk: Option<Bytes>,
  ) {
    let mut guard = self.inner.write().await;
    guard.credential = credential;
    guard.expires_at = expires_at;
    if psk.is_some() {
      guard.psk = psk;
    }
  }
}
```

- ç»­æœŸå“åº”ç›´æ¥å¤ç”¨ `RegisterResponse`ï¼Œactr æ”¶åˆ°åç”¨å…¶ä¸­çš„ credential/å¯é€‰è¿‡æœŸæ—¶é—´/å¯é€‰ PSK æ›´æ–° `CredentialState`ï¼›å›  `CredentialState` é€šè¿‡ `Arc<RwLock<...>>` å…±äº«ï¼Œæ–°çš„å‡­è¯ä¼šæ‰©æ•£åˆ°æ‰€æœ‰ä½¿ç”¨æ–¹ã€‚
- å“åº”ä¸­è‹¥å«æœ‰æ–°çš„ PSKï¼Œä¼šå†™å› `CredentialState`ï¼ˆç”¨äº TURN è®¤è¯ï¼‰ï¼›ActrId ä¸ä¼šè¢«è¦†ç›–ã€‚

### AIS HTTP æ¥å£

- Signaling è°ƒç”¨ AIS `/ais/register`ï¼ˆHTTP POSTï¼Œ`Content-Type: application/octet-stream`ï¼‰å‘é€ `RegisterRequest`ï¼š

```protobuf
// actr/proto/actr.proto
message RegisterRequest {
  required ActrType actr_type = 1;
  required Realm realm = 2;
  optional ServiceSpec service_spec = 3;
  optional Acl acl = 4;
}

// actrix-proto/proto/keyserver.proto
message GetSecretKeyRequest {
  required uint32 key_id = 1;
  required supervisor.v1.NonceCredential credential = 2;
}

message GetSecretKeyResponse {
  required uint32 key_id = 1;
  required string secret_key = 2;    // Base64
  required uint64 expires_at = 3;    // Unix seconds
}

// actrix-proto/proto/keyserver.proto
message GenerateKeyRequest {
  required supervisor.v1.NonceCredential credential = 1;
}

message GenerateKeyResponse {
  required uint32 key_id = 1;
  required string public_key = 2; // Base64 compressed
  required uint64 expires_at = 3;
}

// actrix-proto/proto/supervisor.proto
message NonceCredential {
  required uint64 timestamp = 1;
  required bytes nonce = 2;
  required bytes signature = 3;
}

// éªŒè¯ NonceCredential çš„ç­¾åä¸æ—¶é—´çª—å£ä¾èµ– nonce-auth crateï¼ˆå…±äº«å¯†é’¥ç­¾å + é‡æ”¾ä¿æŠ¤ï¼‰
```

### AIS /register å¤„ç†æµç¨‹ï¼ˆregister_actrï¼‰

1) è§£ç  `RegisterRequest`ï¼ˆprotobufï¼‰ï¼Œå¤±è´¥è¿”å› `RegisterResponse::Error{code=400}`ã€‚  
2) è°ƒç”¨ `issuer.issue_credential`ï¼ˆæ—¶åºå›¾å·²æè¿° ensure_key_loaded / GenerateKey / ç”Ÿæˆ ActrId+PSK+credential_expires_at+ECIES åŠ å¯†ï¼‰ã€‚  
3) è¿‡ç¨‹é”™è¯¯æ˜ å°„ä¸º `RegisterResponse::Error{code=500, message=...}`ï¼›æˆåŠŸ/å¤±è´¥ä¸€å¾‹ç¼–ç ä¸º protobuf bytes è¿”å›ã€‚

### Signaling / AIS å¤„ç†è¦ç‚¹

- Signaling å¯¹ç»­æœŸè¯·æ±‚æ²¿ç”¨ä¸šåŠ¡è¯·æ±‚çš„é‰´æƒæµç¨‹ï¼šæ ¹æ® `token_key_id` å‘½ä¸­ SecretKeyCacheï¼Œæœªå‘½ä¸­åˆ™å‘ KS æ‹‰å–å¯†é’¥ï¼Œè§£å¯† token åæ ¡éªŒ `ActrId` ä¸æœ‰æ•ˆæœŸã€‚
- AIS ä¾èµ– `realm_id` ä¸ `actr_type`ï¼Œç”¨å½“å‰å…¬é’¥é‡æ–°ç”Ÿæˆ `AIdCredential`ï¼ˆç”Ÿæˆçš„ PSK åœ¨ Signaling å›åŒ…æ—¶è¢«ç½®ä¸º Noneï¼‰ï¼›å¦‚æœ KS å·²è½®æ¢ï¼Œè¿”å›çš„ `token_key_id` ä¼šæ›´æ–°ã€‚
- Signaling ä»¥ HTTP POST `/ais/register` æ–¹å¼è°ƒç”¨ AISï¼ˆBody: `RegisterRequest`ï¼‰ï¼Œé 200ã€è§£ç å¤±è´¥æˆ– `RegisterResponse::Error` æ—¶å‘ Actor è¿”å›é”™è¯¯ï¼›æˆåŠŸåˆ™ç”¨è¿”å›çš„ `RegisterResponse` æ›´æ–°å†…å­˜ä¸­çš„å®¢æˆ·ç«¯ credential å¹¶å›ä¼ ã€‚

---

## actr-runtime å®¢æˆ·ç«¯å®ç°

### å¿ƒè·³é©±åŠ¨çš„è§¦å‘ä¸å¤„ç†

å¿ƒè·³é€»è¾‘å·²ç‹¬ç«‹ä¸º `crates/runtime/src/lifecycle/heartbeat.rs` æ¨¡å—ã€‚

- æ³¨å†Œåç”±å¿ƒè·³ä»»åŠ¡ `heartbeat_task` è´Ÿè´£å‘¨æœŸæ€§å‘é€ Ping å¹¶ç›‘å¬ç»­æœŸä¿¡å·ã€‚
- å¿ƒè·³é—´éš”å–è‡ª `RegisterResponse.signaling_heartbeat_interval_secs`ï¼ˆé»˜è®¤ 30sï¼‰ï¼Œç­‰å¾… Pong çš„è¶…æ—¶æ—¶é—´ä¸ºé—´éš”çš„ 40%ï¼›è¶…æ—¶æˆ–å‘é€å¤±è´¥åªè®°å½• warn å¹¶è¿›å…¥ä¸‹ä¸€è½®ã€‚
- `send_heartbeat` è¿”å› `Pong`ï¼Œå…¶ä¸­å¯é€‰æºå¸¦ `CredentialWarning` æ¥æç¤ºå‡­è¯è¿›å…¥å®¹å¿æœŸã€‚
- å½“ Pong å« `credential_warning` æ—¶ï¼Œå¿ƒè·³ä»»åŠ¡ä¼šå¼‚æ­¥è§¦å‘ä¸€æ¬¡ `credential_refresh_task(client, actor_id, credential_state)`ï¼Œåˆ·æ–°ç»“æœå†™å›å…±äº«çŠ¶æ€ã€‚
- åˆ·æ–°å¤±è´¥ä¸ä¼šç«‹å³é‡è¯•ï¼›åç»­å¿ƒè·³è‹¥ç»§ç»­æ”¶åˆ° warningï¼Œä¼šå†æ¬¡è§¦å‘åˆ·æ–°ã€‚

`crates/runtime/src/lifecycle/heartbeat.rs` ä¸­ `send_heartbeat_and_handle_response` å‡½æ•°ç‰‡æ®µï¼š

```rust
async fn send_heartbeat_and_handle_response(
    client: &Arc<dyn SignalingClient>,
    actor_id: &ActrId,
    credential_state: &CredentialState,
    mailbox: &Arc<dyn Mailbox>,
    heartbeat_interval: Duration,
) {
    // Get current credential from shared state
    let current_credential = credential_state.credential().await;

    // Get power reserve, mailbox backlog and calculate availability
    let (power_reserve, mailbox_backlog, availability) =
        get_power_reserve_and_availability(mailbox).await;

    let ping_timeout_secs = (heartbeat_interval.as_secs() as f64 * 0.4) as u64;
    let pong_response = tokio::time::timeout(
        Duration::from_secs(ping_timeout_secs),
        client.send_heartbeat(
            actor_id.clone(),
            current_credential.clone(),
            availability,
            power_reserve,
            mailbox_backlog,
        ),
    )
    .await;

    let pong = match pong_response {
        Ok(Ok(pong)) => pong,
        Ok(Err(e)) => {
            tracing::warn!("âš ï¸ Failed to send heartbeat or receive Pong: {}", e);
            return;
        }
        Err(_) => {
            tracing::warn!("âš ï¸ Heartbeat timeout after {}s", ping_timeout_secs);
            return;
        }
    };

    // Handle credential_warning
    if let Some(warning) = pong.credential_warning {
        tracing::warn!(
            "âš ï¸ Credential warning received: type={:?}, message={}",
            warning.r#type(),
            warning.message
        );

        // Trigger immediate credential refresh in a spawned task
        tokio::spawn(credential_refresh_task(
            client.clone(),
            actor_id.clone(),
            credential_state.clone(),
        ));
    }
}
```

`credential_refresh_task`ï¼ˆ`crates/runtime/src/lifecycle/heartbeat.rs`ï¼‰å®ç°ä¸ºå•æ¬¡åˆ·æ–°ï¼š

```rust
async fn credential_refresh_task(
    client: Arc<dyn SignalingClient>,
    actor_id: ActrId,
    credential_state: CredentialState,
) {
    tracing::info!(
        "ğŸ”‘ Refreshing credential for Actor {}",
        actor_id.to_string_repr()
    );

    match client
        .send_credential_update_request(actor_id.clone(), credential_state.credential().await)
        .await
    {
        Ok(register_response) => {
            match register_response.result {
                Some(actr_protocol::register_response::Result::Success(register_ok)) => {
                    let new_credential = register_ok.credential;
                    let new_expires_at = register_ok.credential_expires_at;
                    let new_psk = register_ok.psk;

                    // Update shared state including PSK
                    credential_state
                        .update(new_credential.clone(), new_expires_at, new_psk.clone())
                        .await;

                    tracing::info!(
                        "âœ… Credential refreshed successfully for Actor {} (new key_id: {})",
                        actor_id.serial_number,
                        new_credential.token_key_id
                    );

                    if new_psk.is_some() {
                        tracing::debug!("ğŸ”‘ PSK updated for TURN authentication");
                    }

                    if let Some(expires_at) = &new_expires_at {
                        tracing::debug!("â° New credential expires at: {}s", expires_at.seconds);
                    }
                }
                Some(actr_protocol::register_response::Result::Error(err)) => {
                    tracing::error!(
                        "âŒ Credential refresh failed: code={}, message={}",
                        err.code,
                        err.message
                    );
                }
                None => {
                    tracing::error!("âŒ Credential refresh response missing result");
                }
            }
        }
        Err(e) => {
            tracing::warn!("âš ï¸ Failed to send credential update request: {}", e);
        }
    }
}
```

---

## å‡­è¯è¿ç»­æ€§ä¸è½®æ¢å½±å“

- **èº«ä»½ç¨³å®š**ï¼šActrId ç»­æœŸå‰åä¿æŒä¸å˜ï¼Œå“åº”ä¸­å³ä¾¿æºå¸¦æ–°çš„ ActrId ä¹Ÿä¸ä¼šè¦†ç›–æœ¬åœ°å­˜å‚¨ã€‚
- **å¯†é’¥è½®æ¢å‹å¥½**ï¼š`token_key_id` ä¼šéš KS è½®æ¢è€Œå˜åŒ–ï¼Œæ–°çš„ credential ç«‹å³ç”¨äºå¿ƒè·³ã€è·¯ç”±ã€é‡è¿ URLã€‚
- **è¿‡æœŸæ—¶é—´ç•™å­˜**ï¼šæœåŠ¡å™¨è¿”å›çš„ `credential_expires_at` ä¼šå†™å…¥ `CredentialState` ä¾›æ—¥å¿—/ç›‘æ§ä½¿ç”¨ï¼Œåˆ·æ–°åˆ™ç”± Pong æºå¸¦çš„ `credential_warning` è§¦å‘ã€‚
- **PSK å¯æ›´æ–°**ï¼šè‹¥å“åº”ä¸­æºå¸¦æ–°çš„ PSKï¼Œä¼šå†™å› `CredentialState` ç”¨äº TURN è®¤è¯ï¼›è‹¥å“åº”ä¸­æœªæºå¸¦ PSKï¼Œåˆ™ä¿ç•™åŸæœ‰å€¼ã€‚

---

## é”™è¯¯å¤„ç†ä¸æ¢å¤

- Pong æºå¸¦ `credential_warning` æ—¶è§¦å‘çš„åˆ·æ–°è‹¥è¿”å› `Error`/ç¼ºå¤± resultï¼Œåªè®°å½•æ—¥å¿—ï¼Œä¸è‡ªåŠ¨é‡è¯•ï¼›åç»­å¿ƒè·³è‹¥ä»è¿”å› warning ä¼šå†æ¬¡è§¦å‘åˆ·æ–°ã€‚
- å¿ƒè·³å‘é€å¤±è´¥æˆ–ç­‰å¾… Pong è¶…æ—¶åªä¼š warn å¹¶è¿›å…¥ä¸‹ä¸€è½®ï¼›å¦‚æœé•¿æœŸæ—  Pongï¼Œéœ€æ£€æŸ¥ä¿¡ä»¤è¿æ¥æˆ–è€ƒè™‘é‡æ–°æ³¨å†Œã€‚
- è‹¥ Signaling/AIS åœ¨å¤„ç† `CredentialUpdateRequest` æ—¶é‰´æƒå¤±è´¥ï¼Œå‡­è¯ä¿æŒæ—§å€¼ï¼Œåç»­ä¸šåŠ¡è¯·æ±‚å¯èƒ½å› è¿‡æœŸè¢«æ‹’ç»ï¼Œæ­¤æ—¶éœ€è¦é‡æ–°æ³¨å†Œæˆ–ç­‰å¾…æ–°ä¸€æ¬¡è­¦å‘Šååˆ·æ–°æˆåŠŸã€‚

---

## ç›¸å…³æ–‡æ¡£

- [æ³¨å†Œæµç¨‹](./5.1-registration-flow.md)
- [ä¸šåŠ¡è¯·æ±‚è®¤è¯æµç¨‹](./5.2-authentication-flow.md)
- [å¯†é’¥è½®æ¢ç­–ç•¥](./5.5-key-rotation.md)
