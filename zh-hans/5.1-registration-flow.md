# Actrix æ³¨å†Œæµç¨‹ (PeerToSignaling.RegisterRequest)

> **å…³äº `?` ç¬¦å·**ï¼šåœ¨å‚æ•°æè¿°ä¸­ï¼Œ`?` è¡¨ç¤ºè¯¥å­—æ®µæ˜¯ **optional**ï¼ˆå¯é€‰çš„ï¼‰ï¼Œå³è¯¥å­—æ®µå¯ä»¥ä¸ºç©ºã€‚  
> ä¾‹å¦‚ï¼š`service_spec?: ServiceSpec` è¡¨ç¤º `service_spec` å­—æ®µå¯ä»¥ä¸æä¾›ã€‚  
> åœ¨ Protocol Buffers ä¸­ï¼Œå¯¹åº” `optional` ä¿®é¥°ç¬¦ã€‚

## æµç¨‹æ¦‚è¿°

é¦–æ¬¡æ³¨å†Œæµç¨‹æ˜¯ actr å‘ç³»ç»Ÿç”³è¯·èº«ä»½å‡­è¯çš„è¿‡ç¨‹ã€‚actr é€šè¿‡ signaling æœåŠ¡å™¨å‘ AISï¼ˆè®¤è¯æœåŠ¡ï¼‰å‘èµ·æ³¨å†Œè¯·æ±‚ï¼ŒAIS ä¼šç”Ÿæˆå”¯ä¸€çš„ ActrIdã€åŠ å¯†çš„å‡­è¯ï¼ˆCredentialï¼‰ä»¥åŠé¢„å…±äº«å¯†é’¥ï¼ˆPSKï¼‰ã€‚

## æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant actr as actr
    participant signaling as signaling
    participant ais as ais
    participant ks as ks

    %% ========== é¦–æ¬¡æ³¨å†Œæµç¨‹ ==========
    actr->>signaling: 1. PeerToSignaling.RegisterRequest
    Note right of actr: actr_type: ActrType (required)<br/>realm: Realm (required)<br/>service_spec?: ServiceSpec (optional)<br/>acl?: Acl (optional)

    signaling->>ais: 2. RegisterRequest (è½¬å‘)
    Note right of signaling: actr_type: ActrType<br/>realm: Realm<br/>service_spec?: ServiceSpec<br/>acl?: Acl

    ais->>ais: 3. æ£€æŸ¥æœ¬åœ° key ç¼“å­˜
    Note right of ais: CurrentKeyCache:<br/>  key_id: u32<br/>  public_key: String<br/>  last_updated: u64<br/>  TTL: 600s (10åˆ†é’Ÿ)

    alt ç¼“å­˜æœ‰æ•ˆï¼ˆæœªè¿‡æœŸï¼‰
        ais->>ais: 4a. ä½¿ç”¨ç¼“å­˜çš„ key
        Note right of ais: ç›´æ¥ä½¿ç”¨ç¼“å­˜ âœ…<br/>ä¸è°ƒç”¨ KS
        
    else ç¼“å­˜è¿‡æœŸæˆ–ä¸å­˜åœ¨
        ais->>ks: 4b. GetCurrentKeyRequest
        Note right of ais: credential: NonceCredential<br/>è¯·æ±‚æœ€æ–°å¯ç”¨ key
        
        ks-->>ais: 4c. GetCurrentKeyResponse
        Note left of ks: key_id: u32<br/>public_key: String (Base64)<br/>expires_at: u64 (Unix timestamp)
        
        ais->>ais: 4d. æ›´æ–°æœ¬åœ°ç¼“å­˜
        Note right of ais: ç¼“å­˜ 10 åˆ†é’Ÿ
    end

    ais->>ais: 5. ç”Ÿæˆå‡­è¯å’Œ PSK
    Note right of ais: 1. ç”Ÿæˆ ActrId (Snowflakeç®—æ³•)<br/>2. åˆ›å»º IdentityClaims:<br/>   - realm_id: u32<br/>   - actor_id: String<br/>   - expr_time: u64<br/>3. ECIES åŠ å¯†ä¸º AIdCredential:<br/>   - encrypted_token: bytes<br/>   - token_key_id: u32<br/>4. ç”Ÿæˆéšæœº PSK (32 bytes)
    
    ais-->>signaling: 6. RegisterResponse.success
    Note left of ais: actr_id: ActrId<br/>credential: AIdCredential<br/>psk?: bytes (optional)<br/>credential_expires_at?: Timestamp<br/>signaling_heartbeat_interval_secs: u32
    
    signaling-->>actr: 7. RegisterResponse.success
    Note left of signaling: actr_id: ActrId<br/>credential: AIdCredential<br/>psk?: bytes (optional)<br/>credential_expires_at?: Timestamp<br/>signaling_heartbeat_interval_secs: u32

    Note over actr: ğŸ”‘ æ³¨å†ŒæˆåŠŸï¼Œè·å¾—èº«ä»½<br/>(actr_id + credential + psk)
```

---

## åè®®è¯¦è§£

### æ­¥éª¤ 1-2: RegisterRequest

**Proto å®šä¹‰** (`actr/crates/protocol/proto/actr.proto:130-137`):
```protobuf
message RegisterRequest {
  required ActrType actr_type = 1;      // Actor ç±»å‹ï¼ˆå‚å•† + åç§°ï¼‰
  required Realm realm = 2;             // å®‰å…¨åŸŸ/ç§Ÿæˆ·
  optional ServiceSpec service_spec = 3; // API è§„èŒƒï¼ˆå¯é€‰ï¼‰
  optional Acl acl = 4;                 // è®¿é—®æ§åˆ¶åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
}

message ActrType {
  required string manufacturer = 1;  // å‚å•†åç§°ï¼Œå¦‚ "apple"
  required string name = 2;          // è®¾å¤‡åç§°ï¼Œå¦‚ "iphone"
}

message Realm {
  required uint32 realm_id = 1;      // ç§Ÿæˆ· ID
}
```

**æµç¨‹**:
1. actr æ„é€  `RegisterRequest` æ¶ˆæ¯
2. åŒ…è£…åˆ° `PeerToSignaling` (ç”¨äºæœªè®¤è¯çš„ peer)
3. é€šè¿‡ WebSocket å‘é€åˆ° signaling æœåŠ¡å™¨
4. signaling è½¬å‘åˆ° AIS è¿›è¡Œå¤„ç†

---

### æ­¥éª¤ 3-4: è·å–åŠ å¯†å¯†é’¥

**ç¼“å­˜ä¼˜åŒ–** (`actrix/crates/ais/src/issuer.rs`):

```rust
async fn get_current_public_key(&self) -> Result<(u32, String)> {
    // 1. ä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜
    {
        let cache = self.current_key_cache.read().await;
        if !self.is_cache_expired(&cache) {
            return Ok((cache.key_id, cache.public_key.clone()));  // âœ… ç¼“å­˜å‘½ä¸­
        }
    }
    
    // 2. ç¼“å­˜è¿‡æœŸï¼Œè°ƒç”¨ KS
    let response = self.ks_client.get_current_key().await?;
    
    // 3. æ›´æ–°ç¼“å­˜ï¼ˆ10 åˆ†é’Ÿ TTLï¼‰
    let mut cache = self.current_key_cache.write().await;
    cache.key_id = response.key_id;
    cache.public_key = response.public_key;
    cache.last_updated = SystemTime::now().as_secs();
    
    Ok((cache.key_id, cache.public_key.clone()))
}
```

**æ€§èƒ½ä¼˜åŠ¿**:
- **ç¼“å­˜å‘½ä¸­ç‡**: > 99%
- **KS è°ƒç”¨é¢‘ç‡**: æ¯ 10 åˆ†é’Ÿæœ€å¤š 1 æ¬¡ï¼ˆè€Œéæ¯æ¬¡æ³¨å†Œï¼‰
- **å¹¶å‘æ€§èƒ½**: æ”¯æŒæ•°åƒå¹¶å‘æ³¨å†Œè¯·æ±‚

**KS å“åº”** (`actrix/crates/actrix-proto/proto/keyserver.proto`):
```protobuf
message GetCurrentKeyResponse {
  required uint32 key_id = 1;        // å½“å‰æ´»è·ƒçš„ key ID
  required string public_key = 2;    // Base64 ç¼–ç çš„ ECIES å…¬é’¥
  required uint64 expires_at = 3;    // å¯†é’¥è¿‡æœŸæ—¶é—´ï¼ˆUnix æ—¶é—´æˆ³ï¼‰
}
```

---

### æ­¥éª¤ 5: ç”Ÿæˆå‡­è¯å’Œ PSK

**å®ç°ç»†èŠ‚** (`actrix/crates/ais/src/issuer.rs:420-470`):

```rust
async fn issue_credential_inner(&self, request: &RegisterRequest) 
    -> Result<register_response::RegisterOk, AidError> 
{
    // 1. ç”Ÿæˆå”¯ä¸€çš„ ActrIdï¼ˆSnowflake ç®—æ³•ï¼Œä¿è¯å…¨å±€å”¯ä¸€ï¼‰
    let actr_id = ActrId {
        realm: request.realm.clone(),
        serial_number: Snowflake::next_id(realm.realm_id),  // 64-bit å”¯ä¸€ ID
        type: request.actr_type.clone(),
    };
    
    // 2. åˆ›å»ºèº«ä»½å£°æ˜
    let expr_time = SystemTime::now().as_secs() + self.config.token_ttl_secs; // é»˜è®¤ 3600s
    let claims = IdentityClaims {
        realm_id: request.realm.realm_id,
        actor_id: actr_id.to_string(),  // æ ¼å¼: "manufacturer:name@serial_hex:realm_id"
        expr_time,
    };
    
    // 3. ä½¿ç”¨ ECIES åŠ å¯† Claims
    let (key_id, public_key) = self.get_current_public_key().await?;
    let claims_json = serde_json::to_vec(&claims)?;
    let encrypted_token = ecies::encrypt(&public_key, &claims_json)?;
    
    // 4. æ„é€  AIdCredential
    let credential = AIdCredential {
        encrypted_token: Bytes::from(encrypted_token),
        token_key_id: key_id,
    };
    
    // 5. ç”Ÿæˆéšæœº PSKï¼ˆç”¨äº TURN è®¤è¯ï¼‰
    let mut psk = vec![0u8; 32];
    rand::thread_rng().fill_bytes(&mut psk);
    
    // 6. è¿”å›æ³¨å†ŒæˆåŠŸå“åº”
    Ok(register_response::RegisterOk {
        actr_id,
        credential,
        psk: Some(Bytes::from(psk)),
        credential_expires_at: Some(Timestamp {
            seconds: expr_time as i64,
            nanos: 0,
        }),
        signaling_heartbeat_interval_secs: self.config.signaling_heartbeat_interval_secs,
    })
}
```

**å…³é”®ç»„ä»¶**:

1. **ActrId ç»“æ„**:
   ```
   ç¤ºä¾‹: apple:iphone@1a2b3c4d5e6f:12345
   â”œâ”€ manufacturer: "apple"
   â”œâ”€ name: "iphone"
   â”œâ”€ serial_number: 0x1a2b3c4d5e6f (Snowflake ID)
   â””â”€ realm_id: 12345
   ```

2. **IdentityClaims**:
   ```json
   {
     "realm_id": 12345,
     "actor_id": "apple:iphone@1a2b3c4d5e6f:12345",
     "expr_time": 1733700000
   }
   ```

3. **AIdCredential**:
   ```
   {
     "encrypted_token": [ECIES åŠ å¯†çš„ IdentityClaims],
     "token_key_id": 5
   }
   ```

---

### æ­¥éª¤ 6-7: RegisterResponse

**Proto å®šä¹‰** (`actr/crates/protocol/proto/actr.proto:139-156`):
```protobuf
message RegisterResponse {
  message RegisterOk {
    required ActrId actr_id = 1;                             // åˆ†é…çš„èº«ä»½ ID
    required AIdCredential credential = 2;                    // åŠ å¯†å‡­è¯
    optional bytes psk = 3;                                  // é¢„å…±äº«å¯†é’¥ï¼ˆ32 bytesï¼‰
    optional google.protobuf.Timestamp credential_expires_at = 4;  // å‡­è¯è¿‡æœŸæ—¶é—´
    required uint32 signaling_heartbeat_interval_secs = 5;   // å¿ƒè·³é—´éš”ï¼ˆé€šå¸¸ 30 ç§’ï¼‰
  }
  
  oneof result {
    RegisterOk success = 1;
    ErrorResponse error = 2;
  }
}
```

**å®¢æˆ·ç«¯å¤„ç†**:
```rust
// actr æ”¶åˆ°å“åº”å
match response.result {
    Some(register_response::Result::Success(ok)) => {
        // ä¿å­˜èº«ä»½ä¿¡æ¯
        self.actr_id = ok.actr_id;
        self.credential = ok.credential;
        self.psk = ok.psk.unwrap_or_default();
        self.credential_expires_at = ok.credential_expires_at;
        
        // å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨
        self.start_heartbeat(ok.signaling_heartbeat_interval_secs);
        
        info!("Registration successful: actr_id={}", self.actr_id);
    }
    Some(register_response::Result::Error(err)) => {
        error!("Registration failed: code={}, message={}", err.code, err.message);
    }
    None => {
        error!("Invalid RegisterResponse");
    }
}
```

---

## å®‰å…¨æ€§è¯´æ˜

### 1. èº«ä»½å”¯ä¸€æ€§

- **Snowflake ç®—æ³•**: ç¡®ä¿ serial_number å…¨å±€å”¯ä¸€
  - æ—¶é—´æˆ³ï¼ˆ41 bitsï¼‰
  - æœºå™¨ IDï¼ˆ10 bitsï¼‰
  - åºåˆ—å·ï¼ˆ12 bitsï¼‰
  - æ¯æ¯«ç§’å¯ç”Ÿæˆ 4096 ä¸ª ID

### 2. å‡­è¯åŠ å¯†

- **ECIES (Elliptic Curve Integrated Encryption Scheme)**
  - åŸºäº secp256k1 æ¤­åœ†æ›²çº¿
  - æ··åˆåŠ å¯†ï¼ˆECDH + AES-GCMï¼‰
  - å‰å‘å®‰å…¨æ€§

### 3. PSK éšæœºæ€§

- **åŠ å¯†å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨**
  - 256-bit ç†µï¼ˆ32 bytesï¼‰
  - ç”¨äº TURN è®¤è¯
  - æ¯æ¬¡æ³¨å†Œç‹¬ç«‹ç”Ÿæˆ

---

## é…ç½®å‚æ•°

**AIS é…ç½®** (`actrix/crates/ais/src/issuer.rs`):
```rust
pub struct IssuerConfig {
    pub token_ttl_secs: u64,                        // Credential æœ‰æ•ˆæœŸï¼ˆé»˜è®¤ 3600s = 1å°æ—¶ï¼‰
    pub signaling_heartbeat_interval_secs: u32,     // å¿ƒè·³é—´éš”ï¼ˆé»˜è®¤ 30sï¼‰
    pub key_refresh_interval_secs: u64,             // Key ç¼“å­˜åˆ·æ–°ï¼ˆé»˜è®¤ 600s = 10åˆ†é’Ÿï¼‰
}
```

**æ¨èé…ç½®**:
- **ç”Ÿäº§ç¯å¢ƒ**: token_ttl = 3600s (1å°æ—¶)
- **å¼€å‘ç¯å¢ƒ**: token_ttl = 7200s (2å°æ—¶)
- **é«˜å®‰å…¨åœºæ™¯**: token_ttl = 1800s (30åˆ†é’Ÿ)

---

## é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯

| é”™è¯¯ç  | é”™è¯¯ä¿¡æ¯ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|--------|---------|------|---------|
| 400 | Invalid realm | ç§Ÿæˆ·ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨ | æ£€æŸ¥ realm_id |
| 403 | ACL validation failed | ACL è§„åˆ™å†²çª | ä¿®æ­£ ACL é…ç½® |
| 500 | Key generation failed | KS ä¸å¯ç”¨ | æ£€æŸ¥ KS æœåŠ¡çŠ¶æ€ |
| 503 | Service unavailable | AIS è¿‡è½½ | é‡è¯•æˆ–é™æµ |

### å®¢æˆ·ç«¯é‡è¯•ç­–ç•¥

```rust
async fn register_with_retry(&mut self) -> Result<()> {
    let mut retry_count = 0;
    let max_retries = 3;
    
    loop {
        match self.register().await {
            Ok(response) => return Ok(response),
            Err(e) if retry_count < max_retries => {
                warn!("Registration failed (attempt {}): {}", retry_count + 1, e);
                retry_count += 1;
                tokio::time::sleep(Duration::from_secs(2u64.pow(retry_count))).await;
            }
            Err(e) => return Err(e),
        }
    }
}
```

---

## æ€§èƒ½æŒ‡æ ‡

### æ³¨å†Œæ€§èƒ½

- **å•æ¬¡æ³¨å†Œå»¶è¿Ÿ**: < 50ms (99th percentile)
- **ååé‡**: > 1000 req/s (å• AIS å®ä¾‹)
- **KS è°ƒç”¨é¢‘ç‡**: 1 æ¬¡ / 10åˆ†é’Ÿï¼ˆç¼“å­˜ä¼˜åŒ–ï¼‰

### ç¼“å­˜æ•ˆç‡

```
åœºæ™¯ï¼š1 åˆ†é’Ÿå†… 1000 ä¸ªæ³¨å†Œè¯·æ±‚

æ— ç¼“å­˜ï¼š
â”œâ”€ KS è°ƒç”¨æ¬¡æ•°: 1000 æ¬¡
â”œâ”€ æ€»å»¶è¿Ÿ: ~5000ms (5ms Ã— 1000)
â””â”€ KS æˆä¸ºç“¶é¢ˆ

æœ‰ç¼“å­˜ï¼š
â”œâ”€ KS è°ƒç”¨æ¬¡æ•°: 1 æ¬¡ï¼ˆé¦–æ¬¡ï¼‰
â”œâ”€ åç»­ 999 æ¬¡ç¼“å­˜å‘½ä¸­
â”œâ”€ æ€»å»¶è¿Ÿ: ~50ms (5ms + 999 Ã— 0.05ms)
â””â”€ æ€§èƒ½æå‡ 100 å€ âœ…
```

---

## ç›¸å…³æ–‡æ¡£

- [ä¸šåŠ¡è¯·æ±‚è®¤è¯æµç¨‹](./2-authentication-flow.md)
- [TURN è®¤è¯æµç¨‹](./3-turn-authentication.md)
- [å‡­è¯æ›´æ–°æµç¨‹](./4-credential-update.md)
- [å¯†é’¥è½®æ¢ç­–ç•¥](./5-key-rotation.md)
