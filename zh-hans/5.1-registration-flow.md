# Actrix æ³¨å†Œæµç¨‹ (PeerToSignaling.RegisterRequest)

> **å…³äº `?` ç¬¦å·**ï¼šåœ¨å‚æ•°æè¿°ä¸­ï¼Œ`?` è¡¨ç¤ºè¯¥å­—æ®µæ˜¯ **optional**ï¼ˆå¯é€‰çš„ï¼‰ï¼Œå³è¯¥å­—æ®µå¯ä»¥ä¸ºç©ºã€‚  
> ä¾‹å¦‚ï¼š`service_spec?: ServiceSpec` è¡¨ç¤º `service_spec` å­—æ®µå¯ä»¥ä¸æä¾›ã€‚  
> åœ¨ Protocol Buffers ä¸­ï¼Œå¯¹åº” `optional` ä¿®é¥°ç¬¦ã€‚

## æµç¨‹æ¦‚è¿°

é¦–æ¬¡æ³¨å†Œæµç¨‹æ˜¯ actr å‘ç³»ç»Ÿç”³è¯·èº«ä»½å‡­è¯çš„è¿‡ç¨‹ã€‚actr é€šè¿‡ signaling æœåŠ¡å™¨å‘ AISï¼ˆè®¤è¯æœåŠ¡ï¼‰å‘èµ·æ³¨å†Œè¯·æ±‚ï¼ŒAIS ä¼šç”Ÿæˆå”¯ä¸€çš„ ActrIdã€åŠ å¯†çš„å‡­è¯ï¼ˆCredentialï¼‰ä»¥åŠé¢„å…±äº«å¯†é’¥ï¼ˆPSKï¼‰ã€‚

## æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant actr as actr
    participant signaling as signaling
    participant ais as ais
    participant ks as ks

    %% ========== é¦–æ¬¡æ³¨å†Œæµç¨‹ ==========
    actr->>signaling: 1. PeerToSignaling.RegisterRequest
    Note right of actr: actr_type: ActrType (required)<br/>realm: Realm (required)<br/>service_spec?: ServiceSpec (optional)<br/>acl?: Acl (optional)

    signaling->>signaling: 2. RealmEntity::validate_realm
    Note right of signaling: éªŒè¯ Realm æ˜¯å¦å­˜åœ¨ã€æœªè¿‡æœŸã€çŠ¶æ€æ­£å¸¸

    signaling->>ais: 3. RegisterRequest (è½¬å‘)
    Note right of signaling: actr_type: ActrType<br/>realm: Realm<br/>service_spec?: ServiceSpec<br/>acl?: Acl

    ais->>ais: 4. æ£€æŸ¥æœ¬åœ° key ç¼“å­˜
    Note right of ais: KeyCache:<br/>  key_id: u32<br/>  public_key: PublicKey<br/>  expires_at: u64<br/>  tolerance_seconds: u64

    alt ç¼“å­˜æœ‰æ•ˆï¼ˆæœªè¿‡æœŸï¼‰
        ais->>ais: 5a. ä½¿ç”¨ç¼“å­˜çš„ key
        Note right of ais: ç›´æ¥ä½¿ç”¨ç¼“å­˜ âœ…<br/>ä¸è°ƒç”¨ KS
        
    else ç¼“å­˜è¿‡æœŸæˆ–ä¸å­˜åœ¨
        ais->>ks: 5b. GenerateKeyRequest
        Note right of ais: credential: NonceCredential<br/>è¯·æ±‚æœ€æ–°å¯ç”¨ key
        
        ks-->>ais: 5c. GenerateKeyResponse
        Note left of ks: key_id: u32<br/>public_key: String (Base64)<br/>expires_at: u64 (Unix timestamp)<br/>tolerance_seconds: u64
        
        ais->>ais: 5d. æ›´æ–°æœ¬åœ°ç¼“å­˜
    end

    ais->>ais: 6. ç”Ÿæˆå‡­è¯å’Œ PSK
    Note right of ais: 1. ç”Ÿæˆ ActrId (Snowflakeç®—æ³•)<br/>2. åˆ›å»º IdentityClaims:<br/>   - realm_id: u32<br/>   - actor_id: String<br/>   - expr_time: u64<br/>3. ECIES åŠ å¯†ä¸º AIdCredential:<br/>   - encrypted_token: bytes<br/>   - token_key_id: u32<br/>4. ç”Ÿæˆéšæœº PSK (32 bytes)
    
    ais-->>signaling: 7. RegisterResponse.success
    Note left of ais: actr_id: ActrId<br/>credential: AIdCredential<br/>psk?: bytes (optional)<br/>credential_expires_at?: Timestamp<br/>signaling_heartbeat_interval_secs: u32
    
    signaling-->>actr: 8. RegisterResponse.success
    Note left of signaling: actr_id: ActrId<br/>credential: AIdCredential<br/>psk?: bytes (optional)<br/>credential_expires_at?: Timestamp<br/>signaling_heartbeat_interval_secs: u32

    Note over actr: ğŸ”‘ æ³¨å†ŒæˆåŠŸï¼Œè·å¾—èº«ä»½<br/>(actr_id + credential + psk)
```

---

## åè®®è¯¦è§£

### æ­¥éª¤ 1-2: RegisterRequest

**Proto å®šä¹‰** (`actr/crates/protocol/proto/actr.proto:130-137`):
```protobuf
message RegisterRequest {
  required ActrType actr_type = 1;      // Actor ç±»å‹ï¼ˆå‚å•† + åç§°ï¼‰
  required Realm realm = 2;             // å®‰å…¨åŸŸ/ç§Ÿæˆ·
  optional ServiceSpec service_spec = 3; // API è§„èŒƒï¼ˆå¯é€‰ï¼‰
  optional Acl acl = 4;                 // è®¿é—®æ§åˆ¶åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
}

message ActrType {
  required string manufacturer = 1;  // å‚å•†åç§°ï¼Œå¦‚ "apple"
  required string name = 2;          // è®¾å¤‡åç§°ï¼Œå¦‚ "iphone"
}

message Realm {
  required uint32 realm_id = 1;      // ç§Ÿæˆ· ID
}
```

**æµç¨‹**:
1. actr æ„é€  `RegisterRequest` æ¶ˆæ¯
2. åŒ…è£…åˆ° `PeerToSignaling` (ç”¨äºæœªè®¤è¯çš„ peer)
3. é€šè¿‡ WebSocket å‘é€åˆ° signaling æœåŠ¡å™¨
4. signaling æœåŠ¡å™¨éªŒè¯ Realmï¼šè°ƒç”¨ `RealmEntity::validate_realm(realm_id)` æ£€æŸ¥ Realm æ˜¯å¦å­˜åœ¨ã€æœªè¿‡æœŸä¸”çŠ¶æ€æ­£å¸¸
5. signaling è½¬å‘åˆ° AIS è¿›è¡Œå¤„ç†

---

### æ­¥éª¤ 2: Realm éªŒè¯

**å®ç°ä½ç½®** (`actrix/crates/signaling/src/server.rs:380-395`):

```rust
// éªŒè¯ RegisterRequest ä¸­çš„ realm æ˜¯å¦å­˜åœ¨ã€æœªè¿‡æœŸã€çŠ¶æ€æ­£å¸¸
let realm_id = register_request.realm.realm_id;
if let Err(e) = RealmEntity::validate_realm(realm_id).await {
    warn!("âš ï¸  RegisterRequest realm éªŒè¯å¤±è´¥: {}", e);
    // ä½¿ç”¨ register-specific é”™è¯¯å“åº”
    send_register_error(
        client_id,
        403,
        &format!("Realm validation failed: {}", e),
        server,
        request_envelope_id,
    )
    .await?;
    return Ok(());
}
```

**éªŒè¯é€»è¾‘** (`actrix/crates/common/src/realm/validation.rs:21-40`):

```rust
pub async fn validate_realm(realm_id: u32) -> Result<Realm, String> {
    let realm = Self::get_by_realm_id(realm_id)
        .await
        .map_err(|e| format!("Failed to query realm: {}", e))?
        .ok_or_else(|| format!("Realm {} not found", realm_id))?;

    if realm.is_expired() {
        return Err(format!("Realm {} has expired", realm_id));
    }

    if realm.status() != RealmStatus::Normal {
        return Err(format!(
            "Realm {} is not in Normal status (current: {})",
            realm_id,
            realm.status()
        ));
    }

    Ok(realm)
}
```

**éªŒè¯è§„åˆ™**:
1. **å­˜åœ¨æ€§æ£€æŸ¥**: Realm ID å¿…é¡»åœ¨æ•°æ®åº“ä¸­å­˜åœ¨
2. **è¿‡æœŸæ£€æŸ¥**: `expires_at` æ—¶é—´æˆ³ä¸èƒ½æ—©äºå½“å‰æ—¶é—´
3. **çŠ¶æ€æ£€æŸ¥**: Realm çŠ¶æ€å¿…é¡»ä¸º `Normal`ï¼ˆä¸èƒ½æ˜¯ `Suspended` æˆ– `Terminated`ï¼‰

**é”™è¯¯å“åº”**:
- **403 Forbidden**: å½“ Realm éªŒè¯å¤±è´¥æ—¶è¿”å›
- é”™è¯¯ä¿¡æ¯åŒ…å«å…·ä½“çš„å¤±è´¥åŸå› ï¼ˆä¸å­˜åœ¨/è¿‡æœŸ/çŠ¶æ€å¼‚å¸¸ï¼‰
- é˜»æ­¢è¯·æ±‚ç»§ç»­è½¬å‘åˆ° AISï¼Œé¿å…æ— æ•ˆæ³¨å†Œ

---

### æ­¥éª¤ 4-5: è·å–åŠ å¯†å¯†é’¥

**ç¼“å­˜ä¼˜åŒ–** (`actrix/crates/ais/src/issuer.rs`):

```rust
/// ç¡®ä¿å¯†é’¥å·²åŠ è½½
async fn ensure_key_loaded(&self) -> Result<(), AidError> {
    // å…ˆå°è¯•ä»ç¼“å­˜åŠ è½½
    if self.key_cache.read().await.is_some() {
        debug!("Key already in cache");
        return Ok(());
    }

    // å°è¯•ä»å­˜å‚¨åŠ è½½
    if let Some(record) = self.key_storage.get_current_key().await.map_err(|e| {
        AidError::GenerationFailed(format!("Failed to get key from storage: {e}"))
    })? {
        // æ£€æŸ¥æ˜¯å¦è¿‡æœŸè¶…å‡ºå®¹å¿æ—¶é—´
        if self
            .key_storage
            .is_expired_beyond_tolerance()
            .await
            .map_err(|e| AidError::GenerationFailed(e.to_string()))?
        {
            warn!("Stored key expired beyond tolerance, fetching new key from KS");
            self.refresh_key_from_ks().await?;
        } else {
            debug!("Loaded key from storage: key_id={}", record.key_id);
            self.load_key_from_record(&record)?;
        }
    } else {
        // æ²¡æœ‰å­˜å‚¨çš„å¯†é’¥ï¼Œä» KS è·å–
        info!("No stored key found, fetching from KS");
        self.refresh_key_from_ks().await?;
    }

    Ok(())
}
```

**æ€§èƒ½ä¼˜åŠ¿**:
- **ç¼“å­˜å‘½ä¸­ç‡**: > 99%
- **KS è°ƒç”¨é¢‘ç‡**: æ¯ 10 åˆ†é’Ÿæœ€å¤š 1 æ¬¡ï¼ˆè€Œéæ¯æ¬¡æ³¨å†Œï¼‰
- **å¹¶å‘æ€§èƒ½**: æ”¯æŒæ•°åƒå¹¶å‘æ³¨å†Œè¯·æ±‚

**KS å“åº”** (`actrix/crates/actrix-proto/proto/keyserver.proto`):
```protobuf
message GenerateKeyResponse {
  required uint32 key_id = 1;        // ç”Ÿæˆçš„å¯†é’¥ ID
  required string public_key = 2;    // Base64 ç¼–ç çš„ ECIES å…¬é’¥
  required uint64 expires_at = 3;    // å¯†é’¥è¿‡æœŸæ—¶é—´ï¼ˆUnix æ—¶é—´æˆ³ï¼‰
  required uint64 tolerance_seconds = 4; // å®¹å¿æœŸï¼ˆç§’ï¼‰
}
```

---

### æ­¥éª¤ 6-7: ç”Ÿæˆå‡­è¯å’Œ PSK

**å®ç°ç»†èŠ‚** (`actrix/crates/ais/src/issuer.rs:419-494`):

```rust
/// å†…éƒ¨å¤„ç†é€»è¾‘
async fn issue_credential_inner(
    &self,
    request: &RegisterRequest,
) -> Result<register_response::RegisterOk, AidError> {
    // ç¡®ä¿æœ‰å¯ç”¨çš„å¯†é’¥
    self.ensure_key_loaded().await?;

    // ç”Ÿæˆ ActrId
    let actr_id = self.generate_actr_id(&request.actr_type, &request.realm)?;

    // ç”Ÿæˆè¿‡æœŸæ—¶é—´
    let expr_time = self.calculate_expiry_time();

    // ç”Ÿæˆ PSK (pre-shared key)
    let psk = self.generate_psk()?;

    // åˆ›å»º Claimsï¼ˆåŒ…å« PSKï¼‰
    let claims = IdentityClaims::from_actr_id(&actr_id, expr_time, psk.clone());

    // ä»ç¼“å­˜è·å–å¯†é’¥
    let (key_id, public_key) = {
        let cache = self.key_cache.read().await;
        let cache = cache
            .as_ref()
            .ok_or_else(|| AidError::GenerationFailed("No key available".to_string()))?;
        (cache.key_id, cache.public_key)
    };

    // ç”ŸæˆåŠ å¯†çš„ credential
    let encrypted_token = self.encrypt_claims(&claims, &public_key)?;

    // åˆ›å»º AIdCredential
    let credential = AIdCredential {
        encrypted_token: Bytes::from(encrypted_token),
        token_key_id: key_id,
    };

    // åˆ›å»ºè¿‡æœŸæ—¶é—´çš„ Timestamp
    let credential_expires_at = Some(Timestamp {
        seconds: expr_time as i64,
        nanos: 0,
    });

    Ok(register_response::RegisterOk {
        actr_id,
        credential,
        psk: Some(Bytes::from(psk)),
        credential_expires_at,
        signaling_heartbeat_interval_secs: self.config.signaling_heartbeat_interval_secs,
    })
}
```

**å…³é”®ç»„ä»¶**:

1. **ActrId ç»“æ„**:
   ```
   ç¤ºä¾‹: apple:iphone@1a2b3c4d5e6f:12345
   â”œâ”€ manufacturer: "apple"
   â”œâ”€ name: "iphone"
   â”œâ”€ serial_number: 0x1a2b3c4d5e6f (Snowflake ID)
   â””â”€ realm_id: 12345
   ```

2. **IdentityClaims**:
   ```json
   {
     "realm_id": 12345,
     "actor_id": "apple:iphone@1a2b3c4d5e6f:12345",
     "expr_time": 1733700000,
     "psk": [32 bytes PSK]
   }
   ```

3. **AIdCredential**:
   ```
   {
     "encrypted_token": [ECIES åŠ å¯†çš„ IdentityClaims],
     "token_key_id": 5
   }
   ```

---

### æ­¥éª¤ 8: RegisterResponse

**Proto å®šä¹‰** (`actr/crates/protocol/proto/actr.proto:139-156`):
```protobuf
message RegisterResponse {
  message RegisterOk {
    required ActrId actr_id = 1;                             // åˆ†é…çš„èº«ä»½ ID
    required AIdCredential credential = 2;                    // åŠ å¯†å‡­è¯
    optional bytes psk = 3;                                  // é¢„å…±äº«å¯†é’¥ï¼ˆ32 bytesï¼‰
    optional google.protobuf.Timestamp credential_expires_at = 4;  // å‡­è¯è¿‡æœŸæ—¶é—´
    required uint32 signaling_heartbeat_interval_secs = 5;   // å¿ƒè·³é—´éš”ï¼ˆé€šå¸¸ 30 ç§’ï¼‰
  }
  
  oneof result {
    RegisterOk success = 1;
    ErrorResponse error = 2;
  }
}
```

**å®¢æˆ·ç«¯å¤„ç†**:
```rust
// actr æ”¶åˆ°å“åº”å
match response.result {
    Some(register_response::Result::Success(ok)) => {
        // ä¿å­˜èº«ä»½ä¿¡æ¯
        self.actr_id = ok.actr_id;
        self.credential = ok.credential;
        self.psk = ok.psk.unwrap_or_default();
        self.credential_expires_at = ok.credential_expires_at;
        
        // å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨
        self.start_heartbeat(ok.signaling_heartbeat_interval_secs);
        
        info!("Registration successful: actr_id={}", self.actr_id);
    }
    Some(register_response::Result::Error(err)) => {
        error!("Registration failed: code={}, message={}", err.code, err.message);
    }
    None => {
        error!("Invalid RegisterResponse");
    }
}
```

---

## å®‰å…¨æ€§è¯´æ˜

### 1. èº«ä»½å”¯ä¸€æ€§

- **Snowflake ç®—æ³•**: ç¡®ä¿ serial_number å…¨å±€å”¯ä¸€ï¼ˆ54-bitï¼‰
  - æ—¶é—´æˆ³ï¼ˆ41 bitsï¼‰ï¼šç›¸å¯¹äº 2023-01-01 çš„æ¯«ç§’æ•°
  - Worker IDï¼ˆ5 bitsï¼‰ï¼šèŠ‚ç‚¹æ ‡è¯† (0-31)
  - åºåˆ—å·ï¼ˆ8 bitsï¼‰ï¼šåŒæ¯«ç§’å†…çš„åºåˆ—å· (0-255)
  - å•èŠ‚ç‚¹æ”¯æŒ 256K IDs/ç§’

### 2. å‡­è¯åŠ å¯†

- **ECIES (Elliptic Curve Integrated Encryption Scheme)**
  - åŸºäº secp256k1 æ¤­åœ†æ›²çº¿
  - æ··åˆåŠ å¯†ï¼ˆECDH + AES-GCMï¼‰
  - å‰å‘å®‰å…¨æ€§

### 3. PSK éšæœºæ€§

- **åŠ å¯†å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨**
  - 256-bit ç†µï¼ˆ32 bytesï¼‰
  - ç”¨äº TURN è®¤è¯
  - æ¯æ¬¡æ³¨å†Œç‹¬ç«‹ç”Ÿæˆ

---

## é…ç½®å‚æ•°

**AIS é…ç½®** (`actrix/crates/ais/src/issuer.rs`):
```rust
pub struct IssuerConfig {
    pub token_ttl_secs: u64,                        // Credential æœ‰æ•ˆæœŸï¼ˆé»˜è®¤ 3600s = 1å°æ—¶ï¼‰
    pub signaling_heartbeat_interval_secs: u32,     // å¿ƒè·³é—´éš”ï¼ˆé»˜è®¤ 30sï¼‰
    pub key_refresh_interval_secs: u64,             // Key ç¼“å­˜åˆ·æ–°ï¼ˆé»˜è®¤ 3600s = 1å°æ—¶ï¼‰
    pub key_storage_file: std::path::PathBuf,       // å¯†é’¥å­˜å‚¨æ•°æ®åº“æ–‡ä»¶è·¯å¾„
    pub enable_periodic_rotation: bool,             // æ˜¯å¦å¯ç”¨å®šæœŸå¯†é’¥è½®æ›¿ï¼ˆé»˜è®¤ falseï¼‰
    pub key_rotation_interval_secs: u64,            // å¯†é’¥è½®æ›¿é—´éš”ï¼ˆé»˜è®¤ 86400s = 24å°æ—¶ï¼‰
}
```

**æ¨èé…ç½®**:
- **ç”Ÿäº§ç¯å¢ƒ**: token_ttl = 3600s (1å°æ—¶)
- **å¼€å‘ç¯å¢ƒ**: token_ttl = 7200s (2å°æ—¶)
- **é«˜å®‰å…¨åœºæ™¯**: token_ttl = 1800s (30åˆ†é’Ÿ)

---

## é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯

| é”™è¯¯ç  | é”™è¯¯ä¿¡æ¯ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|--------|---------|------|---------|
| 403 | Realm validation failed | Realm ä¸å­˜åœ¨ã€å·²è¿‡æœŸæˆ–çŠ¶æ€å¼‚å¸¸ | æ£€æŸ¥ realm_id å’Œ Realm çŠ¶æ€ |
| 403 | ACL validation failed | ACL è§„åˆ™å†²çª | ä¿®æ­£ ACL é…ç½® |
| 500 | Key generation failed | KS ä¸å¯ç”¨ | æ£€æŸ¥ KS æœåŠ¡çŠ¶æ€ |
| 503 | Service unavailable | AIS è¿‡è½½ | é‡è¯•æˆ–é™æµ |

### å®¢æˆ·ç«¯é‡è¯•ç­–ç•¥

```rust
async fn register_with_retry(&mut self) -> Result<()> {
    let mut retry_count = 0;
    let max_retries = 3;
    
    loop {
        match self.register().await {
            Ok(response) => return Ok(response),
            Err(e) if retry_count < max_retries => {
                warn!("Registration failed (attempt {}): {}", retry_count + 1, e);
                retry_count += 1;
                tokio::time::sleep(Duration::from_secs(2u64.pow(retry_count))).await;
            }
            Err(e) => return Err(e),
        }
    }
}
```

---

## æ€§èƒ½æŒ‡æ ‡

### æ³¨å†Œæ€§èƒ½

- **å•æ¬¡æ³¨å†Œå»¶è¿Ÿ**: < 50ms (99th percentile)
- **ååé‡**: > 1000 req/s (å• AIS å®ä¾‹)
- **KS è°ƒç”¨é¢‘ç‡**: 1 æ¬¡ / 10åˆ†é’Ÿï¼ˆç¼“å­˜ä¼˜åŒ–ï¼‰

### ç¼“å­˜æ•ˆç‡

```
åœºæ™¯ï¼š1 åˆ†é’Ÿå†… 1000 ä¸ªæ³¨å†Œè¯·æ±‚

æ— ç¼“å­˜ï¼š
â”œâ”€ KS è°ƒç”¨æ¬¡æ•°: 1000 æ¬¡
â”œâ”€ æ€»å»¶è¿Ÿ: ~5000ms (5ms Ã— 1000)
â””â”€ KS æˆä¸ºç“¶é¢ˆ

æœ‰ç¼“å­˜ï¼š
â”œâ”€ KS è°ƒç”¨æ¬¡æ•°: 1 æ¬¡ï¼ˆé¦–æ¬¡ï¼‰
â”œâ”€ åç»­ 999 æ¬¡ç¼“å­˜å‘½ä¸­
â”œâ”€ æ€»å»¶è¿Ÿ: ~50ms (5ms + 999 Ã— 0.05ms)
â””â”€ æ€§èƒ½æå‡ 100 å€ âœ…
```

---

## ç›¸å…³æ–‡æ¡£

- [ä¸šåŠ¡è¯·æ±‚è®¤è¯æµç¨‹](./2-authentication-flow.md)
- [TURN è®¤è¯æµç¨‹](./3-turn-authentication.md)
- [å‡­è¯æ›´æ–°æµç¨‹](./4-credential-update.md)
- [å¯†é’¥è½®æ¢ç­–ç•¥](./5-key-rotation.md)
