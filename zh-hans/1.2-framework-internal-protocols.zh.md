# 1.2 框架内部协议 (Framework Internal Protocols)

> [!NOTE]
> 本文档定义了 **框架自身** 使用的、标准化的底层 Protobuf 协议。这些是构成框架通信能力的基石。
>
> 如果您想了解如何为 **您的应用业务** 定义 `service` 契约，请参阅《[3.3 应用 Protobuf 契约](./3.3-application-proto-contract.zh.md)》。

本篇文档是框架所有**内置 Protobuf 契约**的唯一、权威的参考源。

---

## 1. WebRTC 基础契约 (`webrtc.proto`)

此文件定义了对 WebRTC 标准协商消息的通用封装，作为一个独立的、可重用的基础协议层。它不包含任何与上层 Actr 或信令逻辑相关的字段。

### 1.1 `webrtc.proto` 完整定义

```protobuf
syntax = "proto2";

package webrtc;

// IceCandidate 对应 WebRTC 标准中的 RTCIceCandidateInit 接口。
message IceCandidate {
  required string candidate = 1;
  optional string sdp_mid = 2;
  optional uint32 sdp_mline_index = 3;
  optional string username_fragment = 4;
}

// SessionDescription 是对 SDP 的统一封装。所有轨道信息都包含在 sdp 字符串中。
message SessionDescription {
  enum Type {
    OFFER = 0;
    ANSWER = 1;
    RENEGOTIATION_OFFER = 2;
  }
  required Type type = 1;
  required string sdp = 2;
}
```

---

## 2. Actor 核心契约 (`actor.proto`)

此文件定义了框架中关于“Actr”自身的核心概念，包括其身份（Identity）和访问控制规则（ACL）。它是所有上层业务逻辑的基础。

### 2.1 `actor.proto` 完整定义

```protobuf
syntax = "proto2";

package actr;

import "google/protobuf/timestamp.proto";

// ===========================================================================
// Basic Components
//   Realm (Security Realm)
//   ActrType (manufacturer + name)
//   ActrId (Realm + serial number + type)
//   ServiceSpec (fingerprint + proto bundle + tags)
//   ActrNode (ActrId + ServiceSpec)
// ===========================================================================
message Realm {
  required uint32 realm_id = 1;
}

message ActrType {
  required string manufacturer = 1;
  required string name = 2;
}

message ActrId {
  required Realm realm = 1;
  required uint64 serial_number = 2;
  required ActrType type = 3;
}

message ServiceSpec {
  optional string description = 1;
  required string fingerprint = 2; // 基于语义指纹的组合哈希（service_semantic:hash）
  repeated Protobuf protobufs = 3;
  optional int64 published_at = 4;  // 发布时间戳
  repeated string tags = 5;         // 标签（如 "latest", "stable"）

  message Protobuf {
    required string uri = 1;
    required string content = 2;
    required string fingerprint = 3; // SHA-256
  }
}

message ActrNode {
  required ActrId actr_id = 1;
  optional ServiceSpec service_spec = 2;
}

// ============================================================================
// AId Credential
// ============================================================================

// Credential structure for ActrId authentication
message AIdCredential {
  required bytes encrypted_token = 1;
  required uint32 token_key_id = 2;
}

// ============================================================================
// Access Control (type-to-type permissions)
// =========================================================================

// A single ACL rule: from -> me : permission
message AclRule {
  message Principal {
    optional Realm realm = 1;
    optional ActrType actr_type = 2;
  }

  repeated Principal principals = 1;

  enum Permission { DENY = 0; ALLOW = 1; }
  required Permission permission = 2;
}

// Access Control List (ordered; first match wins)
message Acl {
  repeated AclRule rules = 1;
}

// =========================================================================
// Actr States
//   LifecycleState: ActrNode Lifecycle State
//   ServiceAvailabilityState: ActrNode Availability State
//   ServiceDependencyState: ActrNode Service Dependency State
// =========================================================================

enum LifecycleState {
  HALTED = 0;
  INITIALIZING = 1;
  CONSTRUCTING = 2;
  RUNNING = 3;
  DESTRUCTING = 4;
  CRASHING = 5;
}

enum ServiceAvailabilityState {
  FULL = 0;
  DEGRADED = 1;
  OVERLOADED = 2;
  UNAVAILABLE = 3;
}

enum ServiceDependencyState {
  HEALTHY = 0;
  WARNING = 1;
  BROKEN = 2;
}

// ============================================================================
// Common Error (copied from actr/common.proto)
// ============================================================================

message ErrorResponse {
  required uint32 code = 1;
  required string message = 2;
}

// =========================================================================
// Register
// =========================================================================
// Allocate a new ActrId and register node metadata and API info.
message RegisterRequest {
  required ActrType actr_type = 1;
  required Realm realm = 2;

  // API / contract metadata
  optional ServiceSpec service_spec = 3;
  optional Acl acl = 4;
}

message RegisterResponse {
  message RegisterOk {
    // Allocated identity and credentials
    required ActrId actr_id = 1;
    required AIdCredential credential = 2;
    optional bytes psk = 3; // bootstrap keying material
    optional google.protobuf.Timestamp credential_expires_at = 4;
    // Operational advice
    required uint32 heartbeat_interval_secs = 5; // 用于连接保活；建议携带轻量运行态指标（可选）
  }
  oneof result {
    RegisterOk success = 1;
    ErrorResponse error = 2;
  }
}

// ============================================================================
// Credential Update
// ============================================================================

message CredentialUpdateRequest {
  required ActrId actr_id = 1;
}

// ============================================================================
// Unregister
// ============================================================================

message UnregisterRequest {
  required ActrId actr_id = 1;
  optional string reason = 2;
}

message UnregisterResponse {
  message UnregisterOk {}
  oneof result {
    UnregisterOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Heartbeat
// =========================================================================
// Periodic liveness and load indicators.
message Ping {
  required ServiceAvailabilityState availability = 1; // Healthy/Degraded/Unavailable
  required float power_reserve = 2; // 0.0–1.0 资源预留度（1.0=空闲充足）
  required float mailbox_backlog = 3; // 0.0–1.0 标准化堆积度（未知可缺省或 -1.0）
}

message Pong {
  required uint64 seq = 1;
  optional uint32 suggest_interval_secs = 2; // advisory
}

// =========================================================================
// Load-balancing: find best route candidates
// =========================================================================
// Request route candidates for a target actor type with optional selection policy.
message RouteCandidatesRequest {
  message NodeSelectionCriteria {
    // Ranking factors for candidate ordering
    enum NodeRankingFactor {
      MAXIMUM_POWER_RESERVE = 0;
      MINIMUM_MAILBOX_BACKLOG = 1;
      BEST_COMPATIBILITY = 2;
      LOWEST_LATENCY = 3;
      NEAREST = 4;
      CLIENT_AFFINITY = 5;
    }

    required uint32 candidate_count = 1;
    repeated NodeRankingFactor ranking_factors = 2;
    optional ServiceDependencyState minimal_dependency_requirement = 3;
    optional ServiceAvailabilityState minimal_health_requirement = 4;
  }
  required ActrType target_type = 1;
  optional NodeSelectionCriteria criteria = 2;
}

message RouteCandidatesResponse {
  message RouteCandidatesOk {
    repeated ActrId candidates = 1;
  }
  oneof result {
    RouteCandidatesOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Discovery request/response
// =========================================================================
// List (ActrType x fingerprint) combinations present on the network.
message DiscoveryRequest {
  optional string manufacturer = 1;
  optional uint32 limit = 2 [default = 64];
}

message DiscoveryResponse {
  message TypeEntry {
    required ActrType actr_type = 1;
    optional string description = 2;
    required string service_fingerprint = 3;
    optional int64 published_at = 4;
    repeated string tags = 5;
  }

  message DiscoveryOk {
    repeated TypeEntry entries = 1;
  }

  oneof result {
    DiscoveryOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Actr-up subscription (push-based presence by actor instance)
// =========================================================================

// Subscribe to "actor of target_type comes online" events.
message SubscribeActrUpRequest {
  required ActrType target_type = 1;
}

message SubscribeActrUpResponse {
  message SubscribeOk {}
  oneof result {
    SubscribeOk success = 1;
    ErrorResponse error = 2;
  }
}

// Cancel a previous subscription.
message UnsubscribeActrUpRequest {
  required ActrType target_type = 1;
}

message UnsubscribeActrUpResponse {
  message UnsubscribeOk {}
  oneof result {
    UnsubscribeOk success = 1;
    ErrorResponse error = 2;
  }
}

// Event: a matching actor instance changed presence.
message ActrUpEvent {
  required ActrId actor_id = 1;
}
```

---

## 3. 信令层契约 (`signaling.proto`)

此文件定义了“身份感知”的信令路由协议，负责在 Actor 之间可靠地转发消息。它明确了认证前和认证后的不同消息流，并为与信令服务器的交互提供统一信封格式；其中，在线实例通知（UpEvent）仅针对通过 can_access 预检的目标，从而实现“发现即授权”的行动型发现语义。

### 3.1 `signaling.proto` 完整定义

```protobuf
syntax = "proto2";

package signaling;

import "google/protobuf/timestamp.proto";
import "actr.proto";
import "webrtc.proto";

// Thin signaling envelope for WebSocket transport.
// Classifies flows: Peer->SignalingServer (pre-registration), Actr->SignalingServer, SignalingServer->Actr, and Actr relay.
message SignalingEnvelope {
  // Envelope metadata
  required uint32 envelope_version = 1;          // envelope schema version
  required string envelope_id = 2;               // unique id for this message
  optional string reply_for = 3;                 // correlation to a previous envelope
  required google.protobuf.Timestamp timestamp = 4; // enqueue time (server clock)

  oneof flow {
    PeerToSignaling peer_to_server = 10;
    ActrToSignaling actr_to_server = 11;
    SignalingToActr server_to_actr = 12;
    ActrRelay actr_relay = 13;
    actr.ErrorResponse envelope_error = 14; // envelope-level failure (no payload)
  }
}

// Flow: peer (no ActrId yet) -> SignalingServer (registration only)
message PeerToSignaling {
  oneof payload {
    actr.RegisterRequest register_request = 1;
  }
}

// Flow: ActrNode (with ActrId) -> SignalingServer
message ActrToSignaling {
  required actr.ActrId source = 1;
  required actr.AIdCredential credential = 2;

  oneof payload {
    actr.UnregisterRequest unregister_request = 3;
    actr.Ping ping = 4;

    // Update AId credential
    actr.CredentialUpdateRequest credential_update_request = 5;

    // Discovery & selection
    actr.DiscoveryRequest discovery_request = 10;
    actr.RouteCandidatesRequest route_candidates_request = 11;

    // Presence subscription
    actr.SubscribeActrUpRequest subscribe_actr_up_request = 20;
    actr.UnsubscribeActrUpRequest unsubscribe_actr_up_request = 21;

    // Error reporting from client
    actr.ErrorResponse error = 30;
  }
}

// Flow: SignalingServer -> Actr
message SignalingToActr {
  required actr.ActrId target = 1;

  oneof payload {
    actr.RegisterResponse register_response = 2;
    actr.UnregisterResponse unregister_response = 3;
    actr.Pong pong = 4;

    // Discovery & selection
    actr.DiscoveryResponse discovery_response = 10;
    actr.RouteCandidatesResponse route_candidates_response = 11;

    // Presence subscription
    actr.SubscribeActrUpResponse subscribe_actr_up_response = 20;
    actr.UnsubscribeActrUpResponse unsubscribe_actr_up_response = 21;
    actr.ActrUpEvent actr_up_event = 22;

    // Error notification specific to the request
    actr.ErrorResponse error = 30;
  }
}

// Flow: Actr -> SignalingServer -> Actr (explicit relay, e.g., WebRTC signaling)
message ActrRelay {
  required actr.ActrId source = 1;
  required actr.AIdCredential credential = 2;
  required actr.ActrId target = 3;

  oneof payload {
    webrtc.IceCandidate ice_candidate = 10;
    webrtc.SessionDescription session_description = 11;
  }
}
```

---

## 4. Actor 生命周期契约 (原生接口/Trait)

与网络通信的信令层不同，Actr 的生命周期钩子（如 `on_start`）是作为一个**原生语言接口**（例如 Rust 的 `trait`，Go 的 `interface`）来定义的，**而不是**一个 Protobuf 契约。

这样做是基于以下设计考量：
*   **性能**: 生命周期事件是 `ActorSystem` 与其管理的 Actor 之间的本地调用。使用原生接口可以避免不必要的序列化开销。
*   **开发者体验**: 开发者可以用自己最熟悉的、最符合语言习惯的方式来实现这些核心方法。

---

## 5. Actr.toml 示例：声明 Realm 与跨 Realm ACL

### 5.0 Realm 申请与配置指南

**Realm 是什么？**
Realm（领域/国度）是框架的多租户与安全隔离机制，每个 ActrNode 必须属于一个 Realm。

**如何获取 Realm ID？**
- **申请来源**：由运营整个 actr 网络的管理方提供的外部系统分配
- **申请方式**：通常通过以下方式之一：
  - Web 控制台（运营方提供的管理界面）
  - REST API（用于自动化申请）
  - 命令行工具（如 `actr-realm-cli`，由运营方提供）
- **默认值**：无默认值，必须显式配置
- **必填性**：所有场景（包括单租户）都必须配置 Realm ID

**配置示例**：
```toml
[package]
name = "payment-service"
manufacturer = "acme"
type = "payment-service"

[deployment]
# Realm ID（必填，由运营方系统预先分配，注册阶段写入 RegisterRequest.realm）
realm = 1001

[acl]
[[acl.rule]]
permission = "allow"

[[acl.rule.from]]
realms = [1001]                          # 同一应用内默认放行
actr_type = ["frontend-client", "payment-service"]

[[acl.rule.from]]
realms = [2000]                          # 允许来自共享工具集 Realm 的服务
actr_type = ["reporting-service"]

[[acl.rule.from]]
realms = ["*"]                          # `*` 表示接受任意 Realm
actr_type = ["monitoring-service"]   # 仅放行特定公共服务

[[acl.rule]]
permission = "deny"                     # 默认拒绝其它来源

```

关键点：

* `[deployment].realm` 对应 `RegisterRequest.realm`，注册后不可修改。
* `acl.rule` 中的 `from` 列表与 `AclRule.From` 一致，可同时指定多个 Realm 和 ActrType；`realms = "*"` 表示允许任意 Realm，规则按顺序匹配，命中后应用 `permission`。
* 通过组合 allow/deny，可以实现“本 Realm 默认放行，部分跨 Realm 白名单访问，其余拒绝”的策略。

### 5.1 `Lifecycle` Trait 定义 (以 Rust 为例)

```rust
#[async_trait]
pub trait Lifecycle {
    /// Called after the actor is attached and the system is started.
    async fn on_start(&self, ctx: &Context);

    /// Called before the actor is stopped.
    async fn on_stop(&self, ctx: &Context);
}
```

> 说明：Lifecycle 钩子统一使用借用引用 `&Context`，以保持最小约束和零额外开销；若实现者需要在后台任务或跨线程长期持有上下文，请在实现内部自行将 `&Context` 升级为 `Arc<Context>`（例如通过 `ctx.share()` 或等效方法），而不要在 trait 边界强制引入 `Arc`。