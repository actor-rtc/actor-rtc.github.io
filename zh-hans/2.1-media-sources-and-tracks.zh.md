# åª’ä½“å¤„ç†ï¼šä»è®¾å¤‡åˆ°ç½‘ç»œ

> **âš ï¸ æ–‡æ¡£è¯´æ˜**ï¼š
> - **ç¬¬ 1 èŠ‚**ï¼šMediaSource/LocalTrack æ˜¯**è®¾è®¡æ¦‚å¿µ**ï¼Œæ¡†æ¶å½“å‰**æœªæä¾›**è®¾å¤‡é‡‡é›†èƒ½åŠ›
> - **ç¬¬ 2 èŠ‚**ï¼šMediaTrack API æ˜¯**å·²å®ç°**çš„ WebRTC ä¼ è¾“å±‚ API
>
> å¦‚éœ€è®¾å¤‡é‡‡é›†åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨å¤–éƒ¨åº“ï¼ˆå¦‚ `webrtc.rs`ã€`cpal` ç­‰ï¼‰è·å–åª’ä½“æ•°æ®ï¼Œç„¶åé€šè¿‡ç¬¬ 2 èŠ‚çš„ API è¿›è¡Œä¼ è¾“ã€‚

å¯¹äºä¸€ä¸ª WebRTC åº”ç”¨æ¡†æ¶è€Œè¨€ï¼Œå®Œæ•´çš„åª’ä½“å¤„ç†åŒ…å«ä¸¤ä¸ªå±‚é¢ï¼š

1. **è®¾å¤‡å±‚**ï¼šå¦‚ä½•è·å–ç‰©ç†è®¾å¤‡ï¼ˆæ‘„åƒå¤´ã€éº¦å…‹é£ï¼‰çš„åª’ä½“æµ
2. **ç½‘ç»œå±‚**ï¼šå¦‚ä½•é€šè¿‡ WebRTC é«˜æ•ˆä¼ è¾“åª’ä½“æ•°æ®

æœ¬æ–‡å†…å®¹ï¼š
- **ç¬¬ 1 èŠ‚**ï¼šMediaSource ä¸ LocalTrackï¼ˆ**è®¾è®¡æ¦‚å¿µ**ï¼Œå°šæœªå®ç°ï¼‰
- **ç¬¬ 2 èŠ‚**ï¼šMediaTrack APIï¼ˆ**å·²å®ç°**ï¼Œå¯ç›´æ¥ä½¿ç”¨ï¼‰

---

## ç¬¬ 1 èŠ‚ï¼šå®¢æˆ·ç«¯ç‰©ç†è®¾å¤‡å¤„ç†ï¼ˆè®¾è®¡æ¦‚å¿µï¼‰

> **âš ï¸ æœ¬èŠ‚æè¿°çš„ API å°šæœªå®ç°**
>
> `MediaSource`ã€`LocalTrack`ã€`ctx.publish_track()` ç­‰ API å½“å‰**ä¸å­˜åœ¨äºæ¡†æ¶ä»£ç ä¸­**ã€‚è¿™æ˜¯æœªæ¥å¯èƒ½å®ç°çš„è®¾è®¡æ–¹å‘ã€‚
>
> **å½“å‰æ–¹æ¡ˆ**ï¼šä½¿ç”¨å¤–éƒ¨åº“è·å–åª’ä½“æ•°æ®ï¼Œé€šè¿‡ç¬¬ 2 èŠ‚çš„ `register_media_track()` å’Œ `send_media_sample()` API è¿›è¡Œä¼ è¾“ã€‚

### 1.1 æ ¸å¿ƒæŠ½è±¡ï¼š`MediaSource` ä¸ `LocalTrack`

ç›´æ¥æ“ä½œç¡¬ä»¶å¹¶å°†å…¶åŸå§‹æ•°æ®æµç¼–ç ã€æ‰“åŒ…æˆ RTP åŒ…æ˜¯ä¸€ä¸ªæå…¶å¤æ‚çš„è¿‡ç¨‹ã€‚æœ¬æ¡†æ¶é€šè¿‡æä¾› **`MediaSource`** å’Œ **`LocalTrack`** è¿™ä¸¤ä¸ªé«˜çº§æŠ½è±¡ï¼Œæ¥å¼¥åˆç¡¬ä»¶ä¸ç½‘ç»œä¹‹é—´çš„é¸¿æ²Ÿã€‚

```mermaid
graph TD
    subgraph Hardware ["ç‰©ç†/ç³»ç»Ÿå±‚é¢"]
        direction LR
        Cam["fa:fa-video æ‘„åƒå¤´"]
        Mic["fa:fa-microphone éº¦å…‹é£"]
    end

    subgraph Abstraction ["æ¡†æ¶åª’ä½“æŠ½è±¡å±‚"]
        direction LR
        MS["<b>MediaSource</b><br/>(åª’ä½“æº)"]
        LT["<b>LocalTrack</b><br/>(æœ¬åœ°è½¨é“)"]
    end

    subgraph ActorWorld ["Actor ä¸–ç•Œ"]
        direction LR
        Workload["fa:fa-user-cog <b>Workload</b><br/>(ä¾‹å¦‚ CameraActor)"]
        Ctx["<b>Context</b> å¯¹è±¡"]
    end

    Cam & Mic -->|"å°è£…ä¸º"| MS
    MS -- "åˆ›å»º" --> LT
    LT -- "ç”± Workload ç®¡ç†" --> Workload
    Workload -- "é€šè¿‡ ctx è¯·æ±‚å‘å¸ƒ" --> Ctx

    style MS fill:#fff3e0,stroke:#f57c00
    style LT fill:#e8f5e9,stroke:#388e3c
```
*   **`MediaSource`**: ä»£è¡¨ä¸€ä¸ªå¯ä»¥äº§ç”Ÿåª’ä½“æµçš„ç‰©ç†æˆ–è™šæ‹Ÿè®¾å¤‡ï¼ˆæ‘„åƒå¤´ã€éº¦å…‹é£ã€å±å¹•ï¼‰ã€‚å®ƒçš„èŒè´£æ˜¯å‘ç°å’Œé€‰æ‹©è®¾å¤‡ã€‚
*   **`LocalTrack`**: ä»£è¡¨ä¸€ä¸ªå…·ä½“çš„ã€å¯è¢«å‘å¸ƒåˆ°ç½‘ç»œä¸Šçš„æœ¬åœ°åª’ä½“è½¨é“ã€‚å®ƒæ˜¯è¿›è¡Œå‘å¸ƒå‰æ‰€æœ‰æ“ä½œçš„æ ¸å¿ƒå¯¹è±¡ã€‚

### 1.2 é›†æˆåˆ° Actor æ¨¡å‹ä¸­

æ ¹æ®æˆ‘ä»¬ç»Ÿä¸€çš„æ¶æ„ï¼Œä¸€ä¸ªå¤„ç†åª’ä½“çš„å®¢æˆ·ç«¯åº”ç”¨ï¼Œå…¶è‡ªèº«ä¹Ÿæ˜¯ä¸€ä¸ªæ ‡å‡†çš„ `ActrNode`ã€‚å®ƒæ‹¥æœ‰ä¸€ä¸ª `Workload`ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸º `CameraActor`ï¼‰ï¼Œè´Ÿè´£ç®¡ç†åª’ä½“è®¾å¤‡å’Œä¸è¿œç«¯æœåŠ¡é€šä¿¡ã€‚

å‘å¸ƒä¸€ä¸ªåª’ä½“è½¨é“çš„æµç¨‹ï¼Œå®Œå…¨éµå¾ª Actor çš„â€œè¯·æ±‚-å“åº”â€æ¨¡å¼ã€‚

#### **å·¥ä½œæµç¨‹**

1.  **åº”ç”¨å¤–å£³åˆå§‹åŒ–**: åœ¨ `main` å‡½æ•°ä¸­ï¼Œåº”ç”¨å¤–å£³ä½¿ç”¨ `MediaSource` API æšä¸¾è®¾å¤‡ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª `LocalTrack`ã€‚
2.  **æ³¨å…¥ Workload**: `LocalTrack` ä½œä¸ºèµ„æºï¼Œåœ¨åˆ›å»º `CameraActor` æ—¶è¢«æ³¨å…¥ã€‚
3.  **UI è§¦å‘å‘å¸ƒ**: ç”¨æˆ·ç‚¹å‡»â€œå¼€å§‹ç›´æ’­â€æŒ‰é’®ï¼ŒUI å‘ `CameraActor` å‘é€ä¸€æ¡å‘½ä»¤å¼æ¶ˆæ¯ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡â€œç³»ç»Ÿå¥æŸ„â€ï¼‰ã€‚
4.  **Workload è¯·æ±‚å‘å¸ƒ**: `CameraActor` åœ¨æ”¶åˆ°æ¶ˆæ¯åï¼Œè°ƒç”¨ `ctx.publish_track(self.local_track)`ï¼Œå‘ `ActrSystem` **è¯·æ±‚**å‘å¸ƒè¿™ä¸ªè½¨é“ã€‚
5.  **æ¡†æ¶å¤„ç†**: `ActrSystem` åœ¨åå°å¤„ç†æ‰€æœ‰å¤æ‚çš„ WebRTC åå•†ï¼ˆ`addTrack`, `createOffer`, ä¿¡ä»¤äº¤æ¢ç­‰ï¼‰ï¼Œæœ€ç»ˆå°†åª’ä½“æµå‘é€åˆ°è¿œç«¯ã€‚

#### **ä»£ç ç¤ºä¾‹**

```rust
// --- åœ¨ CameraActr çš„ä¸šåŠ¡é€»è¾‘ä¸­ ---

pub struct CameraActor {
    video_track: Arc<LocalVideoTrack>,
    // ... å…¶ä»–çŠ¶æ€
}

#[async_trait]
impl ICameraService for CameraActor {
    // æ­¤æ–¹æ³•ç”±åº”ç”¨å¤–å£³é€šè¿‡â€œç³»ç»Ÿå¥æŸ„â€è°ƒç”¨
    async fn start_streaming(&self, request: StartStreamingRequest, ctx: Arc<Context>) -> Result<Empty, ActorError> {
        ctx.log_info("æ”¶åˆ°å¼€å¯ç›´æ’­è¯·æ±‚...");

        // 1. è·å–è¦è¿æ¥çš„è¿œç«¯æœåŠ¡ Actor
        //    è¿™é€šå¸¸é€šè¿‡ä¾èµ–æ³¨å…¥æˆ–æœåŠ¡å‘ç°å®Œæˆ
        let remote_sfu = self.get_sfu_actor().await?;

        // 2. é€šè¿‡ Context è¯·æ±‚å‘å¸ƒæœ¬åœ°è½¨é“
        //    è¿™æ˜¯ä¸€ä¸ªâ€œè¯·æ±‚â€ï¼Œè€Œéç›´æ¥çš„å‘½ä»¤
        match ctx.publish_track(remote_sfu, self.video_track.clone()).await {
            Ok(publication) => {
                ctx.log_info(format!("è½¨é“å‘å¸ƒæˆåŠŸï¼ŒID: {}", publication.id()));
                // å¯ä»¥åœ¨ Actor çŠ¶æ€ä¸­ä¿å­˜ publicationï¼Œç”¨äºåç»­æ§åˆ¶
                self.active_publication.set(Some(publication));
                Ok(Empty {})
            }
            Err(e) => {
                ctx.log_error(format!("è½¨é“å‘å¸ƒå¤±è´¥: {}", e));
                Err(e)
            }
        }
    }

    async fn stop_streaming(&self, request: StopStreamingRequest, ctx: Arc<Context>) -> Result<Empty, ActorError> {
        if let Some(publication) = self.active_publication.take() {
            // è¯·æ±‚åœæ­¢å‘å¸ƒ
            publication.unpublish().await?;
            ctx.log_info("å·²åœæ­¢å‘å¸ƒè½¨é“ã€‚");
        }
        Ok(Empty {})
    }
}
```

### 1.3 æ€»ç»“

é€šè¿‡å°† `LocalTrack` è§†ä¸ºä¸€ç§å¯è¢«æ³¨å…¥çš„"èµ„æº"ï¼Œå¹¶å°†è½¨é“çš„å‘å¸ƒ/åœæ­¢æ“ä½œè½¬åŒ–ä¸º Actor é€šè¿‡ `Context` å‘å‡ºçš„"è¯·æ±‚"ï¼Œæˆ‘ä»¬æˆåŠŸåœ°å°†åª’ä½“å¤„ç†æ— ç¼åœ°æ•´åˆè¿›äº†æ ‡å‡†çš„ Actor æ¨¡å‹ä¸­ã€‚

è¿™ç§æ–¹å¼ä¿æŒäº† Actor é€»è¾‘çš„çº¯ç²¹æ€§å’Œå¯æµ‹è¯•æ€§ï¼ŒåŒæ—¶å°†æ‰€æœ‰ä¸ WebRTC ç›¸å…³çš„å¤æ‚æ€§éƒ½éšè—åœ¨äº†æ¡†æ¶çš„ `Context` å®ç°èƒŒåï¼Œä¸ºå¼€å‘è€…æä¾›äº†ç®€æ´ã€ä¸€è‡´çš„ APIã€‚

---

## ç¬¬ 2 èŠ‚ï¼šMediaTrack API - WebRTC åŸç”Ÿ RTP é€šé“

### 2.1 Overview

Actor-RTC æ”¯æŒ WebRTC åŸç”Ÿ MediaTrack è¿›è¡Œä½å»¶è¿Ÿã€é«˜ååé‡çš„åª’ä½“æµä¼ è¾“ã€‚MediaTrack ä½¿ç”¨ WebRTC çš„åŸç”Ÿ RTP é€šé“è€Œé DataChannelï¼Œæä¾›ï¼š

- **é›¶ protobuf å¼€é”€**ï¼šç›´æ¥ RTP åŒ…ä¼ è¾“
- **æ— å¤§å°é™åˆ¶**ï¼šä¸åŒäº DataChannel çš„ 16KB é™åˆ¶
- **æ›´ä½å»¶è¿Ÿ**ï¼šæ¯” DataChannel ä½çº¦ 1-2ms
- **åŸç”Ÿç¼–è§£ç å™¨æ”¯æŒ**ï¼šH264ã€VP8ï¼ˆè§†é¢‘ï¼‰å’Œ OPUSï¼ˆéŸ³é¢‘ï¼‰

### 2.2 æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å‘é€ç«¯ Actor (actr-a)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ctx.send_media_sample(&target, "video-track-1", sample) â”‚
â”‚          â†“                                               â”‚
â”‚ OutGate â†’ OutprocOutGate â†’ WebRtcCoordinator            â”‚
â”‚          â†“                                               â”‚
â”‚ Track.write_rtp(RtpPacket)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“ WebRTC P2P
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ¥æ”¶ç«¯ Actor (actr-b)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PeerConnection.on_track callback                        â”‚
â”‚          â†“                                               â”‚
â”‚ Track.read_rtp() loop                                   â”‚
â”‚          â†“                                               â”‚
â”‚ MediaFrameRegistry::dispatch(track_id, sample, sender)  â”‚
â”‚          â†“                                               â”‚
â”‚ User callback: Box::pin(async move { ... })             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 API ä½¿ç”¨ç¤ºä¾‹

#### æ¥æ”¶ç«¯

```rust
use actr_framework::{Context, Workload, MediaSample, MediaType};
use actr_protocol::ActorResult;

struct MediaReceiver;

#[async_trait]
impl Workload for MediaReceiver {
    type Dispatcher = MediaReceiverDispatcher;

    fn actor_type(&self) -> &str {
        "media-receiver"
    }

    async fn on_start<C: Context>(&self, ctx: &C) -> ActorResult<()> {
        // Register callback for receiving video frames
        ctx.register_media_track("video-track-1", |sample, sender_id| {
            Box::pin(async move {
                tracing::info!(
                    "ğŸ“¹ Received video frame: size={} bytes, timestamp={}, from={}",
                    sample.data.len(),
                    sample.timestamp,
                    sender_id.serial_number
                );

                // Process video frame (decode, render, save, etc.)
                // ...

                Ok(())
            })
        }).await?;

        tracing::info!("âœ… MediaTrack receiver registered");
        Ok(())
    }

    async fn on_stop<C: Context>(&self, ctx: &C) -> ActorResult<()> {
        // Cleanup: unregister track
        ctx.unregister_media_track("video-track-1").await?;
        Ok(())
    }
}
```

#### å‘é€ç«¯

```rust
use actr_framework::{Context, Workload, MediaSample, MediaType, Dest};
use actr_protocol::ActorResult;
use bytes::Bytes;

struct MediaSender {
    target_id: ActrId,
}

impl MediaSender {
    async fn send_video_frame<C: Context>(
        &self,
        ctx: &C,
        frame_data: Vec<u8>,
        timestamp: u32,
    ) -> ActorResult<()> {
        let sample = MediaSample {
            data: Bytes::from(frame_data),
            timestamp,
            codec: "VP8".to_string(),
            media_type: MediaType::Video,
        };

        let target = Dest::Actor(self.target_id.clone());

        ctx.send_media_sample(&target, "video-track-1", sample).await?;

        tracing::debug!("ğŸ“¤ Sent video frame: timestamp={}", timestamp);
        Ok(())
    }
}
```

### 2.4 å·²å®ç°åŠŸèƒ½

#### åŠ¨æ€ Track åˆ›å»º

æ”¯æŒåœ¨è¿æ¥å»ºç«‹åçƒ­æ·»åŠ  MediaTrackï¼Œæ— éœ€æ–­å¼€é‡è¿ï¼š

```rust
// Add new track dynamically with SDP renegotiation
coordinator.add_dynamic_track(target, "audio-1", "OPUS", "audio").await?;
```

**ç‰¹æ€§**ï¼š
- å®Œæ•´ SDP é‡æ–°åå•†æ”¯æŒ
- ç°æœ‰è¿æ¥ä¿æŒæ´»è·ƒ
- è‡ªåŠ¨ Track ID åŒæ­¥ï¼ˆé€šè¿‡ SDPï¼‰
- æ— éœ€ ICE é‡å¯

#### ç”Ÿäº§çº§ RTP Header ç®¡ç†

- **Sequence Number**ï¼šæ¯ä¸ª track ç‹¬ç«‹çš„åŸå­è®¡æ•°å™¨ï¼ˆåœ¨ 65535 å¤„å›ç»•ï¼‰
- **SSRC**ï¼šæ¯ä¸ª track å”¯ä¸€çš„éšæœº u32ï¼ˆç¬¦åˆ RFC 3550ï¼‰
- **è‡ªåŠ¨ç®¡ç†**ï¼šé›¶ç”¨æˆ·å¹²é¢„

#### ç¼–è§£ç å™¨æ”¯æŒ

- **è§†é¢‘**ï¼šVP8, H264
- **éŸ³é¢‘**ï¼šOPUS
- å¯åœ¨ `WebRtcConnection::add_media_track()` ä¸­æ·»åŠ æ›´å¤šç¼–è§£ç å™¨

### 2.5 æ€§èƒ½ç‰¹æ€§

| æŒ‡æ ‡ | DataChannel (RPC) | MediaTrack (åŸç”Ÿ RTP) |
|------|-------------------|----------------------|
| æœ€å¤§å¸§å¤§å° | 16 KB | æ— é™åˆ¶ï¼ˆå·²æµ‹è¯• >1MBï¼‰ |
| åºåˆ—åŒ– | Protobuf | é›¶å¼€é”€ |
| å»¶è¿Ÿ | åŸºå‡† | -1~2ms æ”¹è¿› |
| ååé‡ | å—åˆ†å—é™åˆ¶ | åŸç”Ÿ RTP å¸¦å®½ |

### 2.6 ä» RPC è¿ç§»åˆ° MediaTrack

**æ—§æ–¹æ³•ï¼ˆé€šè¿‡ DataChannelï¼‰**ï¼š
```rust
// âŒ é™åˆ¶ 16KBï¼Œéœ€è¦ protobuf åºåˆ—åŒ–
let request = SendVideoFrameRequest {
    frame_data: truncated_frame, // Must truncate!
    timestamp,
};
ctx.call(&target, request).await?;
```

**æ–°æ–¹æ³•ï¼ˆé€šè¿‡ MediaTrackï¼‰**ï¼š
```rust
// âœ… æ— å¤§å°é™åˆ¶ï¼Œé›¶åºåˆ—åŒ–
let sample = MediaSample {
    data: full_frame,  // Can be megabytes!
    timestamp,
    codec: "VP8".to_string(),
    media_type: MediaType::Video,
};
ctx.send_media_sample(&target, "video-track-1", sample).await?;
```

### 2.7 å·²çŸ¥é™åˆ¶

1. **Payload Type**ï¼šå½“å‰æ‰€æœ‰ç¼–è§£ç å™¨å›ºå®šä¸º 96ï¼ˆå°é—®é¢˜ - VP8 å¯æ­£å¸¸å·¥ä½œï¼‰
   - å¢å¼ºï¼šç¼–è§£ç å™¨ç‰¹å®šæ˜ å°„ï¼ˆä¾‹å¦‚ H264â†’102, OPUSâ†’111ï¼‰

2. **ç¼–è§£ç å™¨æ£€æµ‹**ï¼šæ¥æ”¶çš„ track ä½¿ç”¨ "unknown" å ä½ç¬¦
   - å¢å¼ºï¼šä» RTCTrackRemote å…ƒæ•°æ®æå–ç¼–è§£ç å™¨

3. **åª’ä½“ç±»å‹æ£€æµ‹**ï¼šå½“å‰ç¡¬ç¼–ç ä¸º Video
   - å¢å¼ºï¼šä» track.kind() æ£€æµ‹ï¼ˆaudio vs videoï¼‰

### 2.8 æœªæ¥å¢å¼º

- [x] åŠ¨æ€ track åˆ›å»ºï¼ˆSDP é‡æ–°åå•†ï¼‰âœ…
- [x] æ­£ç¡®çš„ RTP sequence number ç®¡ç† âœ…
- [x] æ¯ä¸ª track å”¯ä¸€ SSRC âœ…
- [ ] ç¼–è§£ç å™¨ç‰¹å®šçš„ payload type æ˜ å°„
- [ ] ä» track å…ƒæ•°æ®è‡ªåŠ¨æ£€æµ‹ç¼–è§£ç å™¨
- [ ] å¤šæµæ”¯æŒï¼ˆå¤šä¸ªåŒæ—¶ trackï¼‰
- [ ] å¸¦å®½ä¼°è®¡å’Œæ‹¥å¡æ§åˆ¶
- [ ] Track å…ƒæ•°æ®ï¼ˆåˆ†è¾¨ç‡ã€å¸§ç‡ç­‰ï¼‰
- [ ] éŸ³è§†é¢‘åŒæ­¥è¾…åŠ©å·¥å…·

### 2.9 å‚è€ƒ

- Framework APIï¼š`actr-framework/src/context.rs`
- Runtime å®ç°ï¼š`actr-runtime/src/context.rs`
- WebRTC é›†æˆï¼š`actr-runtime/src/wire/webrtc/coordinator.rs`
- æ¶æ„è¯¦æƒ…ï¼š[4.6 actr-runtimeï¼šè¿è¡Œæ—¶æ¶æ„](4.6-actr-runtime.zh.md)

---

**æ€»ç»“**ï¼šæœ¬æ–‡æ¶µç›–äº†åª’ä½“å¤„ç†çš„ä¸¤ä¸ªå±‚é¢ - ä»å®¢æˆ·ç«¯ç‰©ç†è®¾å¤‡è·å–ï¼ˆMediaSource/LocalTrackï¼‰åˆ°é€šè¿‡ WebRTC é«˜æ•ˆä¼ è¾“ï¼ˆMediaTrack APIï¼‰ã€‚è¿™ä¸¤ä¸ªå±‚é¢å…±åŒæ„æˆäº†å®Œæ•´çš„ç«¯åˆ°ç«¯åª’ä½“å¤„ç†è§£å†³æ–¹æ¡ˆã€‚
