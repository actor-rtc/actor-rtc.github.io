# **ActrSystem ä¸ Workloadï¼šå¹³è¡Œç»„åˆçš„é›¶æˆæœ¬æŠ½è±¡**

ç†è§£ actr æ¡†æ¶çš„ç¬¬ä¸€æ­¥ï¼Œæ˜¯ç†è§£ä¸€ä¸ªç®€æ´è€Œæ·±åˆ»çš„ç­‰å¼ï¼š

> **ActrNode = ActrSystem + Workload**

è¿™ä¸æ˜¯"å®¹å™¨åŒ…å«å†…å®¹"çš„å…³ç³»ï¼Œè€Œæ˜¯**ä¸¤ä¸ªå¹³è¡Œç»„ä»¶çš„ç»„åˆ**ï¼š
- **ActrSystem** æä¾›è¿è¡Œæ—¶åŸºç¡€è®¾æ–½ï¼ˆèˆå°ã€ç¯å…‰ã€éŸ³å“ï¼‰
- **Workload** å®ç°ä¸šåŠ¡é€»è¾‘ï¼ˆèˆå°ä¸Šè¡¨æ¼”çš„æ¼”å‘˜ï¼‰
- **attach** å®Œæˆå¹³è¡Œç»„åˆï¼ˆå°†ä¸¤è€…è¿æ¥èµ·æ¥ï¼‰

ä¸ä¼ ç»Ÿå‰§é™¢ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬çš„"å‰§é™¢"é‡‡ç”¨äº†**ç¼–è¯‘æ—¶æ™ºèƒ½è°ƒåº¦**æŠ€æœ¯ï¼Œåœ¨ç¼–å‰§é˜¶æ®µå°±ç¡®å®šäº†æ‰€æœ‰æ¼”å‘˜çš„å‡ºåœºé¡ºåºå’Œå°è¯åˆ†é…ï¼Œæ¶ˆé™¤äº†æ¼”å‡ºæ—¶çš„ä¸€åˆ‡ä¸ç¡®å®šæ€§ã€‚

---

## 1. æ ¸å¿ƒè®¾è®¡å“²å­¦ï¼šç¼–è¯‘æ—¶é›¶æˆæœ¬æŠ½è±¡

actr åˆ›é€ äº†ä¸€ç§é©å‘½æ€§çš„ Actor æ¶æ„ï¼Œå®ƒä¸æ˜¯ä¼ ç»Ÿ Actor æ¨¡å‹çš„ç®€å•å®ç°ï¼Œè€Œæ˜¯ç°ä»£ Rust ç¼–ç¨‹èŒƒå¼çš„é©å‘½æ€§åº”ç”¨ã€‚

### 1.1 å››ä¸ªæ ¸å¿ƒ Trait

æ•´ä¸ªæ¡†æ¶å»ºç«‹åœ¨ 4 ä¸ªç²¾å¿ƒè®¾è®¡çš„ trait ä¹‹ä¸Šï¼Œæ¯ä¸ªéƒ½æœ‰ä¸å¯æ›¿ä»£çš„ä½œç”¨ï¼š

```rust
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. RpcRequest - å»ºç«‹"é—®é¢˜-ç­”æ¡ˆ"çš„ç±»å‹å…³è”ï¼ˆå®šä¹‰äº actr-protocolï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub trait RpcRequest: prost::Message + Default + Send + Sync + 'static {
    type Response: prost::Message + Default + Send + Sync + 'static;
    fn route_key() -> &'static str;
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2. å…·ä½“ Handler traitï¼ˆç”±ä»£ç ç”Ÿæˆå™¨ç”Ÿæˆï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ä¾‹å¦‚ï¼šEchoServiceHandler
pub trait EchoServiceHandler: Send + Sync + 'static {
    async fn echo<C: Context>(&self, req: EchoRequest, ctx: &C) -> ActorResult<EchoResponse>;
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 3. MessageDispatcher - æ¶ˆæ¯åˆ†å‘å™¨ï¼ˆé™æ€è·¯ç”±ï¼‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub trait MessageDispatcher: Send + Sync + 'static {
    type Workload: Workload<Dispatcher = Self>;
    async fn dispatch<C: Context>(
        workload: &Self::Workload,
        envelope: RpcEnvelope,
        ctx: &C,
    ) -> ActorResult<Bytes>;
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 4. Workload - å·¥ä½œå•å…ƒ + å…³è”åˆ†å‘å™¨
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
pub trait Workload: Send + Sync + 'static {
    type Dispatcher: MessageDispatcher<Workload = Self>;
    async fn on_start<C: Context>(&self, _ctx: &C) -> ActorResult<()> { Ok(()) }
    async fn on_stop<C: Context>(&self, _ctx: &C) -> ActorResult<()> { Ok(()) }
}
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦è¿™ 4 ä¸ª Traitï¼Ÿ

| Trait | ä½œç”¨ | ä¸å¯æ›¿ä»£çš„ç†ç”± |
|-------|------|----------------|
| **RpcRequest** | ç¼–è¯‘æ—¶ç±»å‹å…³è” | `ctx.call(target, req)` çš„è¿”å›ç±»å‹ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ï¼ŒåŒæ—¶æä¾› `route_key()` é™æ€è·¯ç”± |
| **Handler trait** | ç”¨æˆ·å‹å¥½çš„ä¸šåŠ¡æ¥å£ | å…·ä½“æ–¹æ³•åï¼ˆå¦‚ `echo()`ï¼‰ï¼Œç”¨æˆ·å®ç°ä¸šåŠ¡é€»è¾‘ |
| **MessageDispatcher** | ç»Ÿä¸€åˆ†å‘æ¥å£ | é™æ€è·¯ç”±ï¼šroute_key â†’ handler methodï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ |
| **Workload** | ç”Ÿå‘½å‘¨æœŸ + åˆ†å‘å™¨å…³è” | æä¾› `on_start`/`on_stop` é’©å­ï¼Œå…³è” Dispatcher ç±»å‹ |

**å…³é”®æ´å¯Ÿï¼šMessageDispatcher æ˜¯æ ¸å¿ƒæ¡¥æ¢**

è¿™æ˜¯æ•´ä¸ªç³»ç»Ÿä¸­æœ€å…³é”®çš„ traitï¼å®ƒè§£å†³äº†"ç¼–è¯‘æ—¶å¤šä¸ªç±»å‹åŒ–æ–¹æ³• â†’ è¿è¡Œæ—¶ç»Ÿä¸€è°ƒç”¨"çš„æ ¹æœ¬çŸ›ç›¾ï¼š

```rust
// ç”¨æˆ·å†™çš„ï¼šå…·ä½“çš„ Handler trait æ–¹æ³•
impl EchoServiceHandler for MyService {
    async fn echo<C: Context>(&self, req: EchoRequest, ctx: &C) -> ActorResult<EchoResponse> {}
    async fn batch<C: Context>(&self, req: BatchRequest, ctx: &C) -> ActorResult<BatchResponse> {}
}

// è¿è¡Œæ—¶éœ€è¦ï¼šç»Ÿä¸€çš„è°ƒç”¨æ¥å£
MessageDispatcher::dispatch(workload, envelope, ctx).await

// MessageDispatcher æä¾›æ¡¥æ¢ï¼ˆä»£ç ç”Ÿæˆï¼‰
impl<T: EchoServiceHandler> MessageDispatcher for EchoServiceRouter<T> {
    async fn dispatch<C: Context>(
        workload: &Self::Workload, envelope: RpcEnvelope, ctx: &C
    ) -> ActorResult<Bytes> {
        match envelope.route_key.as_str() {
            "echo.EchoService.Echo" => {
                let req = EchoRequest::decode(&*envelope.payload)?;
                let resp = workload.0.echo(req, ctx).await?;
                Ok(resp.encode_to_vec().into())
            }
            _ => Err(...)
        }
    }
}
```

### 1.3 ä¸ä¼ ç»Ÿ Actor æ¨¡å‹çš„æœ¬è´¨åŒºåˆ«

**é©å‘½æ€§çªç ´**ï¼š
- âœ… **ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨** - æ‰€æœ‰æ¶ˆæ¯è·¯ç”±åœ¨ç¼–è¯‘æœŸç¡®å®šï¼Œè¿è¡Œæ—¶é›¶ç±»å‹æ£€æŸ¥å¼€é”€
- âœ… **é›¶æˆæœ¬æŠ½è±¡** - æ¶ˆé™¤è™šå‡½æ•°è°ƒç”¨ï¼Œç›´æ¥å‡½æ•°è°ƒç”¨æ€§èƒ½
- âœ… **æ™ºèƒ½ä»£ç ç”Ÿæˆ** - åŸºäº .proto å¥‘çº¦è‡ªåŠ¨ç”Ÿæˆæœ€å°å¿…è¦ä»£ç 
- âœ… **ä¿æŒç®€æ´ API** - `.attach(workload)` çš„é­”æ³•èƒŒåæ˜¯ç¼–è¯‘æ—¶æ™ºèƒ½

**ä¸ä¼ ç»Ÿ Actor çš„ç›¸åŒä¹‹å¤„**ï¼š
- âœ… **çŠ¶æ€éš”ç¦»** - Workload çš„å†…éƒ¨çŠ¶æ€å®Œå…¨å°è£…
- âœ… **æ¶ˆæ¯é©±åŠ¨** - æ‰€æœ‰è¡Œä¸ºéƒ½ç”±å¼ºç±»å‹çš„æ¶ˆæ¯è§¦å‘
- âœ… **ä½ç½®é€æ˜** - é€šè¿‡ ActrId å®ç°æ— æ„ŸçŸ¥çš„æœ¬åœ°/è¿œç¨‹è°ƒç”¨

> **[ä¾‹å¤–æƒ…å†µ] é«˜æ€§èƒ½"å¿«é€Ÿè·¯å¾„"**:
> æ¡†æ¶æä¾›äº†"å¿«é€Ÿè·¯å¾„ï¼ˆFast Pathï¼‰"æœºåˆ¶ï¼Œç”¨äºå¤„ç†é«˜ååé‡çš„éçŠ¶æ€æ•°æ®ï¼ˆå¦‚éŸ³è§†é¢‘æµï¼‰ã€‚æ­¤è·¯å¾„ä¼šç»•è¿‡å¸¸è§„çš„ Mailbox å’ŒæŒä¹…åŒ–é€»è¾‘ï¼Œå› æ­¤å¼€å‘è€…éœ€è¦è‡ªè¡Œè´Ÿè´£å…¶æ•°æ®ä¸€è‡´æ€§ã€‚è¯¦è§ã€Š[3.8-Fast-Path-Internals.zh.md](./3.8-fast-path-internals.zh.md)ã€‹ã€‚

**æœ¬è´¨ä¸åŒ**ï¼š
- âœ… **æ€§èƒ½é©å‘½** - ç¼–è¯‘æ—¶å•æ€åŒ– vs. è¿è¡Œæ—¶åå°„
- âœ… **ç±»å‹å®‰å…¨** - ç¼–è¯‘æœŸæ•è·é”™è¯¯ vs. è¿è¡Œæ—¶å¤±è´¥
- âœ… **ä»£ç ç®€æ´** - è‡ªåŠ¨ç”Ÿæˆ vs. æ‰‹å†™æ ·æ¿ä»£ç 

---

## 2. ç¼–è¯‘æ—¶å¹¶å‘ä¿è¯ä¸æ€§èƒ½ä¼˜åŒ–

### 2.1 ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨ä¿è¯

è¿™æ˜¯ç†è§£æœ¬æ¡†æ¶æœ€æ ¸å¿ƒçš„åˆ›æ–°ï¼š**æˆ‘ä»¬å°†ä¼ ç»Ÿè¿è¡Œæ—¶çš„å¹¶å‘ä¿è¯æå‡åˆ°äº†ç¼–è¯‘æ—¶**ã€‚

```rust
// âœ… ç¼–è¯‘æœŸä¿è¯ï¼šç±»å‹å®‰å…¨çš„æ¶ˆæ¯å¤„ç†
impl MessageHandler<EchoRequest> for MyActor {
    async fn handle(&self, req: EchoRequest, ctx: &Context) -> ActorResult<EchoResponse> {
        // æ¡†æ¶ä¿è¯ï¼šMailbox ä¸­çš„æ¶ˆæ¯ä¸²è¡Œè°ƒåº¦
        // å¼€å‘è€…ä¿è¯ï¼šå†…éƒ¨é€»è¾‘çš„çº¿ç¨‹å®‰å…¨æ€§
        Ok(EchoResponse {
            text: format!("Echo: {}", req.text)
        })
    }
}

// âŒ ç¼–è¯‘æœŸé˜»æ­¢ï¼šå‘é€ä¸æ”¯æŒçš„æ¶ˆæ¯
ctx.call(actor_id, UnsupportedMessage {}).await?;
//                ^^^^^^^^^^^^^^^^^ ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

### 2.2 é›¶å¼€é”€æ¶ˆæ¯åˆ†å‘æœºåˆ¶

æ¡†æ¶çš„æ ¸å¿ƒåˆ›æ–°åœ¨äº**ç¼–è¯‘æ—¶æ¶ˆæ¯åˆ†å‘è¡¨æ„å»º**ï¼š

```rust
// ç¼–è¯‘æ—¶ç”Ÿæˆçš„é«˜æ•ˆåˆ†å‘æœºåˆ¶ï¼ˆå¯¹å¼€å‘è€…é€æ˜ï¼‰
impl<T: EchoServiceHandler> MessageDispatcher for EchoServiceRouter<T> {
    type Workload = EchoServiceWorkload<T>;

    async fn dispatch<C: Context>(
        workload: &Self::Workload,
        envelope: RpcEnvelope,
        ctx: &C,
    ) -> ActorResult<Bytes> {
        // ğŸ”¥ ç¼–è¯‘æ—¶é™æ€ matchï¼Œé›¶è¿è¡Œæ—¶æŸ¥æ‰¾å¼€é”€
        match envelope.route_key.as_str() {
            "echo.EchoService.Echo" => {
                let req = EchoRequest::decode(&*envelope.payload.unwrap())?;
                let resp = workload.0.echo(req, ctx).await?;
                Ok(resp.encode_to_vec().into())
            }
            _ => Err(ProtocolError::Actr(ActrError::UnknownRoute {
                route_key: envelope.route_key.to_string()
            }))
        }
    }
}
```

### 2.3 æ€§èƒ½å¯¹æ¯”ï¼šé©å‘½æ€§æå‡

| ç‰¹æ€§ | ä¼ ç»Ÿ Actor æ¡†æ¶ | **actr æ¡†æ¶** |
|------|---------------|----------------|
| æ¶ˆæ¯åˆ†å‘ | 3-5 å±‚è™šå‡½æ•°è°ƒç”¨ | **ç›´æ¥å‡½æ•°è°ƒç”¨** |
| ç±»å‹æ£€æŸ¥ | è¿è¡Œæ—¶åå°„+é”™è¯¯å¤„ç† | **ç¼–è¯‘æ—¶éªŒè¯** |
| å†…å­˜å¼€é”€ | æ¯æ¶ˆæ¯å¤šæ¬¡å †åˆ†é… | **é›¶é¢å¤–åˆ†é…** |
| ä»£ç å¤æ‚åº¦ | å¤§é‡æ ·æ¿ä»£ç  | **æœ€å°ç”¨æˆ·ä»£ç ** |

### 2.4 å®ç°å±‚æ¬¡æ¾„æ¸…

**ğŸ—ï¸ ç³»ç»Ÿå®ç°å±‚**ï¼šActrSystem æœ¬èº«é‡‡ç”¨ç¼–è¯‘æ—¶ç±»å‹æ¨æ–­å’Œé›¶æˆæœ¬æŠ½è±¡æŠ€æœ¯ã€‚

**ğŸŒ åè®®äº¤äº’å±‚**ï¼šæ‰€æœ‰æ¶ˆæ¯å¤„ç†é€šè¿‡ç¼–è¯‘æ—¶ç”Ÿæˆçš„ç›´æ¥å‡½æ•°è°ƒç”¨è¿›è¡Œåˆ†å‘ï¼Œå®ç°é›¶è¿è¡Œæ—¶è·¯ç”±å¼€é”€ã€‚

è¿™ç§åˆ†å±‚è®¾è®¡å®ç°äº†ä»ç³»ç»Ÿå±‚åˆ°åè®®å±‚çš„å…¨é¢ç¼–è¯‘æ—¶ä¼˜åŒ–ï¼šç³»ç»Ÿå®ç°å±‚æä¾›é›¶æˆæœ¬æŠ½è±¡çš„æ¡†æ¶åŸºç¡€ï¼Œåè®®äº¤äº’å±‚é€šè¿‡ç¼–è¯‘æ—¶è·¯ç”±å®ç°é›¶å¼€é”€çš„æ¶ˆæ¯åˆ†å‘ï¼Œä¸¤å±‚ååŒæä¾›äº†çœŸæ­£çš„åˆ†å¸ƒå¼é›¶æˆæœ¬æŠ½è±¡ã€‚

---

## 3. ActrSystemï¼šæ™ºèƒ½è¿è¡Œæ—¶ç¯å¢ƒ

### 3.1 å¹³è¡Œç»„åˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ActrSystem     â”‚          â”‚    Workload      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚          â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”   â”‚
â”‚  è¿è¡Œæ—¶åŸºç¡€è®¾æ–½   â”‚          â”‚  ä¸šåŠ¡é€»è¾‘å•å…ƒ     â”‚
â”‚                  â”‚          â”‚                  â”‚
â”‚  â€¢ Scheduler     â”‚          â”‚  â€¢ Handler æ–¹æ³•  â”‚
â”‚  â€¢ Mailbox       â”‚          â”‚  â€¢ ä¸šåŠ¡çŠ¶æ€      â”‚
â”‚  â€¢ Registry      â”‚          â”‚  â€¢ å¤„ç†é€»è¾‘      â”‚
â”‚  â€¢ Network       â”‚          â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                            â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ attach â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚      ActrNode           â”‚
         â”‚  å®Œæ•´çš„è¿è¡Œæ—¶èŠ‚ç‚¹        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ç‰¹æ€§**ï¼š
- ActrSystem æœ¬èº«**ä¸ç›´æ¥å­˜å‚¨** Workloadï¼›attach ä¹‹åç”± ActrNode<W> ä»¥ `Arc<W>` æŒæœ‰
- HandlerRegistry **å­˜å‚¨** æŒ‡å‘ Workload çš„ Arc å¼•ç”¨
- attach æ“ä½œå»ºç«‹è¿æ¥ï¼Œ**å®Œæˆç»„è£…**

### 3.2 æç®€å¯åŠ¨ä»£ç 

```rust
// ğŸ¯ å¼€å‘è€…ä»£ç ï¼šæè‡´ç®€æ´
let my_service = MyEchoService::default();

ActrSystem::new(config)?
    .attach(my_service)   // âœ¨ å¹³è¡Œç»„åˆ
    .start()              // ğŸ”¥ å¯åŠ¨æ—¶æ‰€æœ‰è·¯ç”±å·²ç¡®å®š
    .await?;
```

### 3.3 ç³»ç»ŸèŒè´£çš„ç°ä»£åŒ–å®šä¹‰

**1. ç¼–è¯‘æ—¶ç±»å‹åˆ†æ**
   - è‡ªåŠ¨åˆ†æ Workload çš„ Handler å®ç°
   - æ„å»ºç±»å‹åŒ–çš„æ¶ˆæ¯åˆ†å‘è¡¨
   - ç”Ÿæˆé›¶å¼€é”€çš„æ¶ˆæ¯è·¯ç”±ä»£ç 

**2. è¿è¡Œæ—¶é«˜æ€§èƒ½æ‰§è¡Œ**
   - é¢„ç¼–è¯‘çš„æ¶ˆæ¯åˆ†å‘è·¯å¾„
   - æ— åŠ¨æ€ç±»å‹æ£€æŸ¥çš„ç›´æ¥è°ƒç”¨
   - æœ€å°åŒ–å†…å­˜åˆ†é…å’Œæ‹·è´

**3. æ™ºèƒ½ç½‘ç»œå±‚é›†æˆ**
   - ç±»å‹å®‰å…¨çš„ Protobuf åºåˆ—åŒ–/ååºåˆ—åŒ–
   - è‡ªåŠ¨çš„æœ¬åœ°/è¿œç¨‹æ¶ˆæ¯è·¯ç”±
   - WebRTC æ•°æ®é€šé“çš„é€æ˜ç®¡ç†

**4. ç”Ÿå‘½å‘¨æœŸçš„ç²¾ç¡®æ§åˆ¶**
   - ä¼˜é›…å…³åœæ—¶çš„ç±»å‹åŒ–æ¶ˆæ¯æ¸…ç†
   - ç”Ÿå‘½å‘¨æœŸé’©å­çš„ç¼–è¯‘æ—¶æ³¨å†Œ
   - èµ„æºé‡Šæ”¾çš„è‡ªåŠ¨åŒ–ç®¡ç†

---

## 4. Workloadï¼šé›¶æ ·æ¿ä»£ç çš„ä¸šåŠ¡é€»è¾‘

### 4.1 é©å‘½æ€§çš„å¼€å‘ä½“éªŒ

Workload ä»£è¡¨äº†ç°ä»£æ¡†æ¶è®¾è®¡çš„æœ€é«˜æ°´å‡†ï¼š

```rust
// ğŸ¯ ç”¨æˆ·åªéœ€è¦å†™è¿™äº›ï¼
pub struct MyBusinessService {
    state: Arc<Mutex<BusinessState>>,
}

// å®ç°ä¸šåŠ¡é€»è¾‘ï¼ˆç”±ä»£ç ç”Ÿæˆå™¨ç”Ÿæˆçš„ traitï¼‰
impl BusinessServiceHandler for MyBusinessService {
    async fn process_order<C: Context>(
        &self,
        order: ProcessOrderRequest,
        ctx: &C,
    ) -> ActorResult<ProcessOrderResponse> {
        // ç¼–è¯‘æ—¶ä¿è¯çš„ä¸²è¡Œå¤„ç†å…¥å£
        let mut state = self.state.lock().await;
        state.process(order.id);

        // é€šè¿‡åˆ«åå®¢æˆ·ç«¯ï¼Œè¿›è¡Œç±»å‹å®‰å…¨çš„æœåŠ¡è°ƒç”¨
        let payment = ctx.payment_service()
            .process(PaymentRequest { amount: order.amount })
            .await?;

        Ok(ProcessOrderResponse {
            success: payment.confirmed
        })
    }
}

// ä»¥ä¸‹ä»£ç ç”±ä»£ç ç”Ÿæˆå™¨è‡ªåŠ¨ç”Ÿæˆï¼Œå¼€å‘è€…æ— éœ€ç¼–å†™ï¼š

// MessageDispatcher åˆ†å‘å™¨ï¼ˆé›¶å¤§å°ç±»å‹ï¼‰
pub struct BusinessServiceRouter<T>(PhantomData<T>);

impl<T: BusinessServiceHandler> MessageDispatcher for BusinessServiceRouter<T> {
    type Workload = BusinessServiceWorkload<T>;

    async fn dispatch<C: Context>(
        workload: &Self::Workload, 
        envelope: RpcEnvelope,
        ctx: &C,
    ) -> ActorResult<Bytes> {
        match envelope.route_key.as_str() {
            "business.BusinessService.ProcessOrder" => {
                let req = ProcessOrderRequest::decode(&*envelope.payload.unwrap())?;
                let resp = workload.0.process_order(req, ctx).await?;
                Ok(resp.encode_to_vec().into())
            }
            _ => Err(...)
        }
    }
}

// Workload wrapper ç±»å‹
pub struct BusinessServiceWorkload<T: BusinessServiceHandler>(pub T);

impl<T: BusinessServiceHandler> Workload for BusinessServiceWorkload<T> {
    type Dispatcher = BusinessServiceRouter<T>;
}
```

**è‡ªåŠ¨è·å¾—çš„èƒ½åŠ›**ï¼š

å®ç° `BusinessServiceHandler` åï¼Œ`MyBusinessService` è‡ªåŠ¨è·å¾—ï¼š
- âœ… `Workload` traitï¼ˆé€šè¿‡ wrapper ç±»å‹ `BusinessServiceWorkload`ï¼‰
- âœ… `MessageDispatcher` å®ç°ï¼ˆé€šè¿‡ `BusinessServiceRouter`ï¼‰
- âœ… ç”Ÿå‘½å‘¨æœŸé’©å­ `on_start`/`on_stop`ï¼ˆå¯é€‰è¦†ç›–ï¼‰

### 4.2 ActrId ç½‘ç»œåˆ†é…æœºåˆ¶

ActrId é‡‡ç”¨**æ··åˆåˆ†é…**æ¨¡å¼ï¼Œç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼š

- **Realm**: å®‰å…¨é¢†åŸŸæ ‡è¯†ï¼Œç”±å¤–éƒ¨ç³»ç»Ÿé¢„åˆ†é…ï¼Œå¼€å‘è€…å†™å…¥ `Actr.toml`
- **serial_number**: ä¿¡ä»¤æœåŠ¡å™¨åŠ¨æ€åˆ†é…ï¼Œç¡®ä¿ Realm å†…å”¯ä¸€
- **ActrType**: å¼€å‘è€…å®šä¹‰çš„æœåŠ¡ç±»å‹æ ‡è¯†ï¼ˆmanufacturer + nameï¼‰

```mermaid
sequenceDiagram
    participant Dev as å¼€å‘è€…
    participant RealmAPI as Realm API
    participant Config as Actr.toml
    participant Actor as ActrSystem
    participant Signaling as ä¿¡ä»¤æœåŠ¡å™¨

    Dev->>RealmAPI: 1. ç”³è¯· Realm ID
    RealmAPI-->>Dev: Realm ID (å¦‚ 1001)
    Dev->>Config: 2. å†™å…¥é…ç½® realm = 1001

    Actor->>Signaling: 3. RegisterRequest(actr_type, realm)
    Signaling->>Signaling: 4. ç”Ÿæˆ serial_number
    Signaling-->>Actor: 5. è¿”å›å®Œæ•´ ActrId
    Actor->>Actor: 6. è¿›å…¥ Ready çŠ¶æ€
```

**åˆ†é…æµç¨‹ä¸ç”Ÿå‘½å‘¨æœŸ**ï¼š

1. **é¢„é…ç½®é˜¶æ®µ**: å¼€å‘è€…é€šè¿‡ Realm API è·å–é¢†åŸŸ IDï¼Œå†™å…¥ `Actr.toml`
2. **å¯åŠ¨é˜¶æ®µ**: ActrSystem è¯»å–é…ç½®ï¼Œå‡†å¤‡æ³¨å†Œä¿¡æ¯
**æ³¨å†Œé˜¶æ®µ**: å‘ä¿¡ä»¤æœåŠ¡å™¨å‘é€ `RegisterRequest`ï¼ŒåŒ…å« `actr_type` å’Œ `realm`
4. **åˆ†é…é˜¶æ®µ**: ä¿¡ä»¤æœåŠ¡å™¨ç”Ÿæˆ `serial_number`ï¼Œç¡®ä¿åœ¨è¯¥ Realm ä¸‹å”¯ä¸€
5. **å®Œæˆé˜¶æ®µ**: è¿”å›å®Œæ•´ ActrIdï¼ŒActor è¿›å…¥ Ready çŠ¶æ€

**çŠ¶æ€è½¬æ¢**ï¼š
```
[é…ç½®å®Œæˆ] â†’ Realm ID å·²å†™å…¥ Actr.toml
    â†“ .start()
[è¿æ¥ä¸­] â†’ è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨
    (actr_type + realm)
[æ³¨å†Œä¸­] â†’ ç­‰å¾… serial_number åˆ†é…
    â†“ æ”¶åˆ°å®Œæ•´ ActrId
[Ready] â†’ å¼€å§‹å¤„ç†ä¸šåŠ¡æ¶ˆæ¯
```

**ä¼˜åŠ¿**ï¼š
- âœ… **å…¨å±€å”¯ä¸€æ€§** - ç”±ä¸­å¤®æœåŠ¡ä¿è¯ï¼Œé¿å…å†²çª
- âœ… **åŠ¨æ€ç®¡ç†** - æ”¯æŒçƒ­æ’æ‹”ï¼Œæ— éœ€é¢„é…ç½®
- âœ… **æœåŠ¡å‘ç°** - ActrId è‡ªåŠ¨æ³¨å†Œåˆ°æœåŠ¡ç›®å½•

### 4.3 ç±»å‹å®‰å…¨çš„ Context API

```rust
// Context æ˜¯ä¸€ä¸ª traitï¼Œç”± Runtime å®ç°
#[async_trait]
pub trait Context: Send + Sync + Clone + 'static {
    // ç±»å‹å®‰å…¨çš„ç‚¹å¯¹ç‚¹è°ƒç”¨ï¼ˆä½¿ç”¨ Dest æŒ‡å®šç›®æ ‡ï¼‰
    async fn call<R: RpcRequest>(&self, target: &Dest, req: R)
        -> ActorResult<R::Response>;

    // ç±»å‹å®‰å…¨çš„å¼‚æ­¥é€šçŸ¥
    async fn tell<R: RpcRequest>(&self, target: &Dest, req: R)
        -> ActorResult<()>;

    // è·å–å½“å‰ Actor ID
    fn self_id(&self) -> &ActrId;
    
    // è·å–è°ƒç”¨æ–¹ Actor ID
    fn caller_id(&self) -> Option<&ActrId>;
    
    // è·å–è¯·æ±‚å”¯ä¸€ ID
    fn request_id(&self) -> &str;
}

// æ³¨æ„ï¼šé™¤äº†ç›´æ¥å¯»å€çš„ 'call' å’Œ 'tell'ï¼Œæ¡†æ¶é€šè¿‡ä»£ç ç”Ÿæˆï¼Œ
// ä¼šä¸º Actr.toml ä¸­å£°æ˜çš„æ¯ä¸ªä¾èµ–åˆ«åï¼Œç”Ÿæˆå¯¹åº”çš„å®¢æˆ·ç«¯æ‰©å±•ã€‚
// ä¾‹å¦‚ï¼Œå¼€å‘è€…ä¼šä½¿ç”¨ï¼š
//   ctx.echo_service().send_echo(req).await?
//   ctx.user_service().get_profile(req).await?
// æ¥è¿›è¡Œç±»å‹å®‰å…¨çš„ã€å¯æ˜¾å¼é€‰æ‹©çš„è¿œç¨‹è°ƒç”¨ã€‚
```

---

## 5. æ¶æ„ä¼˜åŠ¿æ€»ç»“

### 5.1 æ€§èƒ½é©å‘½
- âœ… **é›¶è¿è¡Œæ—¶åå°„** - æ‰€æœ‰ç±»å‹ä¿¡æ¯åœ¨ç¼–è¯‘æ—¶ç¡®å®š
- âœ… **ç›´æ¥å‡½æ•°è°ƒç”¨** - æ¶ˆé™¤è™šå‡½æ•°è°ƒç”¨å¼€é”€
- âœ… **æœ€å°å†…å­˜å ç”¨** - æ— å†—ä½™æ•°æ®ç»“æ„å’Œä¸­é—´å±‚

### 5.2 å¼€å‘ä½“éªŒ
- âœ… **æç®€ç”¨æˆ·ä»£ç ** - åªéœ€å®ç°ç”Ÿæˆçš„ Handler trait
- âœ… **ä¿æŒ attach é­”æ³•** - `ActrSystem::new().attach(workload).start()`
- âœ… **å®Œæ•´ç±»å‹å®‰å…¨** - ç¼–è¯‘æœŸæ•è·æ‰€æœ‰ç±»å‹é”™è¯¯

### 5.3 å¯ç»´æŠ¤æ€§
- âœ… **æ¦‚å¿µç®€æ´** - åªæœ‰ 4 ä¸ªæ ¸å¿ƒ traitï¼Œè¯­ä¹‰æ¸…æ™°
- âœ… **ä»£ç ç”Ÿæˆæœ€å°** - æ¯”ä¼ ç»Ÿæ¡†æ¶å‡å°‘ 80% çš„ç”Ÿæˆä»£ç 
- âœ… **è°ƒè¯•å‹å¥½** - ç›´æ¥è°ƒç”¨æ ˆï¼Œæ— å¤æ‚é—´æ¥å±‚

### 5.4 å¯æµ‹è¯•æ€§
- âœ… **å•å…ƒæµ‹è¯•å‹å¥½** - Handler å¯ä»¥ç‹¬ç«‹æµ‹è¯•ï¼Œåªéœ€æ¨¡æ‹Ÿ Context
- âœ… **é›†æˆæµ‹è¯•ç®€åŒ–** - ç±»å‹å®‰å…¨çš„æ¶ˆæ¯æ„é€ å’ŒéªŒè¯
- âœ… **æ€§èƒ½æµ‹è¯•å‡†ç¡®** - æ— æ¡†æ¶å¼€é”€çš„çº¯ä¸šåŠ¡é€»è¾‘æ€§èƒ½æµ‹é‡

---

## 6. å®Œæ•´ç¤ºä¾‹ï¼šä» .proto åˆ°è¿è¡Œ

### 6.1 å®šä¹‰å¥‘çº¦

```protobuf
// proto/echo.v1.proto
syntax = "proto3";

message EchoRequest {
  string text = 1;
}

message EchoResponse {
  string text = 1;
  int64 timestamp = 2;
}

service EchoService {
  rpc SendEcho(EchoRequest) returns (EchoResponse);
}
```

### 6.2 é…ç½®è§’è‰²

```toml
# Actr.toml
[package]
name = "echo-service"
manufacturer = "acme"

exports = ["proto/echo.v1.proto"]
```

### 6.3 å®ç°ä¸šåŠ¡é€»è¾‘

```rust
// src/main.rs
pub struct MyEchoService;

// å®ç°ç”Ÿæˆçš„ trait
impl EchoServiceHandler for MyEchoService {
    async fn send_echo(
        &self,
        req: EchoRequest,
        ctx: &Context,
    ) -> ActorResult<EchoResponse> {
        Ok(EchoResponse {
            text: format!("Echo: {}", req.text),
            timestamp: chrono::Utc::now().timestamp(),
        })
    }
}
```

### 6.4 å¯åŠ¨ç³»ç»Ÿ

```rust
#[tokio::main]
async fn main() -> ActorResult<()> {
    let actor_system = ActrSystem::new(config)?;
    let my_service = MyEchoService;

    actor_system
        .attach(my_service)  // å¹³è¡Œç»„åˆ
        .start()
        .await?
        .wait_for_shutdown()
        .await
}
```

---

## 7. ç»“è®ºï¼šç°ä»£ Actor æ¡†æ¶çš„æœ€ä¼˜è§£

è¿™ç§æ¶æ„çœŸæ­£å®ç°äº†**æ€§èƒ½ã€ç®€æ´æ€§å’Œæ˜“ç”¨æ€§**çš„å®Œç¾å¹³è¡¡ï¼š

```rust
// ğŸ† æœ€ç»ˆçš„å¼€å‘ä½“éªŒï¼šç®€æ´è€Œå¼ºå¤§

// 1. å®šä¹‰ä¸šåŠ¡é€»è¾‘
impl MyServiceHandler for MyService {
    async fn handle_request(&self, req: MyRequest, ctx: &Context)
        -> ActorResult<MyResponse>
    {
        // ä¸šåŠ¡é€»è¾‘ï¼šç®€æ´ã€ç±»å‹å®‰å…¨ã€é«˜æ€§èƒ½
        let result = ctx.other_service()
            .process(Transform { data: req.data })
            .await?;

        Ok(MyResponse { result })
    }
}

// 2. å¯åŠ¨ï¼šä¸€è¡Œä»£ç ï¼Œç¼–è¯‘æ—¶ä¼˜åŒ–ä¸€åˆ‡
ActrSystem::new(config)?.attach(MyService).start().await?;
```

è¿™å°±æ˜¯ç°ä»£ Rust Actor æ¡†æ¶åº”æœ‰çš„æ ·å­ï¼š

**ç¼–è¯‘æ—¶æ™ºèƒ½ï¼Œè¿è¡Œæ—¶é›¶å¼€é”€ï¼Œå¼€å‘æ—¶æç®€æ´**
